/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@fullcalendar/bootstrap/main.js":
/*!******************************************************!*\
  !*** ./node_modules/@fullcalendar/bootstrap/main.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\nFullCalendar Bootstrap Plugin v4.1.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ \"./node_modules/@fullcalendar/core/main.js\")) :\n    undefined;\n}(this, function (exports, core) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\n\n    var BootstrapTheme = /** @class */ (function (_super) {\n        __extends(BootstrapTheme, _super);\n        function BootstrapTheme() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return BootstrapTheme;\n    }(core.Theme));\n    BootstrapTheme.prototype.classes = {\n        widget: 'fc-bootstrap',\n        tableGrid: 'table-bordered',\n        tableList: 'table',\n        tableListHeading: 'table-active',\n        buttonGroup: 'btn-group',\n        button: 'btn btn-primary',\n        buttonActive: 'active',\n        today: 'alert alert-info',\n        popover: 'card card-primary',\n        popoverHeader: 'card-header',\n        popoverContent: 'card-body',\n        // day grid\n        // for left/right border color when border is inset from edges (all-day in timeGrid view)\n        // avoid `table` class b/c don't want margins/padding/structure. only border color.\n        headerRow: 'table-bordered',\n        dayRow: 'table-bordered',\n        // list view\n        listView: 'card card-primary'\n    };\n    BootstrapTheme.prototype.baseIconClass = 'fa';\n    BootstrapTheme.prototype.iconClasses = {\n        close: 'fa-times',\n        prev: 'fa-chevron-left',\n        next: 'fa-chevron-right',\n        prevYear: 'fa-angle-double-left',\n        nextYear: 'fa-angle-double-right'\n    };\n    BootstrapTheme.prototype.iconOverrideOption = 'bootstrapFontAwesome';\n    BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';\n    BootstrapTheme.prototype.iconOverridePrefix = 'fa-';\n    var main = core.createPlugin({\n        themeClasses: {\n            bootstrap: BootstrapTheme\n        }\n    });\n\n    exports.BootstrapTheme = BootstrapTheme;\n    exports.default = main;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9ib290c3RyYXAvbWFpbi5qcz8yZWY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMscUVBQW9CO0FBQ2hILElBQUksU0FDMEY7QUFDOUYsQ0FBQyxpQ0FBaUM7O0FBRWxDO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLGtEQUFrRCxjQUFjOztBQUVoRSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvYm9vdHN0cmFwL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciBCb290c3RyYXAgUGx1Z2luIHY0LjEuMFxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuKGMpIDIwMTkgQWRhbSBTaGF3XG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0BmdWxsY2FsZW5kYXIvY29yZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAZnVsbGNhbGVuZGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuRnVsbENhbGVuZGFyQm9vdHN0cmFwID0ge30sIGdsb2JhbC5GdWxsQ2FsZW5kYXIpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGNvcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XG5cbiAgICB2YXIgQm9vdHN0cmFwVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCb290c3RyYXBUaGVtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQm9vdHN0cmFwVGhlbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJvb3RzdHJhcFRoZW1lO1xuICAgIH0oY29yZS5UaGVtZSkpO1xuICAgIEJvb3RzdHJhcFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xuICAgICAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXAnLFxuICAgICAgICB0YWJsZUdyaWQ6ICd0YWJsZS1ib3JkZXJlZCcsXG4gICAgICAgIHRhYmxlTGlzdDogJ3RhYmxlJyxcbiAgICAgICAgdGFibGVMaXN0SGVhZGluZzogJ3RhYmxlLWFjdGl2ZScsXG4gICAgICAgIGJ1dHRvbkdyb3VwOiAnYnRuLWdyb3VwJyxcbiAgICAgICAgYnV0dG9uOiAnYnRuIGJ0bi1wcmltYXJ5JyxcbiAgICAgICAgYnV0dG9uQWN0aXZlOiAnYWN0aXZlJyxcbiAgICAgICAgdG9kYXk6ICdhbGVydCBhbGVydC1pbmZvJyxcbiAgICAgICAgcG9wb3ZlcjogJ2NhcmQgY2FyZC1wcmltYXJ5JyxcbiAgICAgICAgcG9wb3ZlckhlYWRlcjogJ2NhcmQtaGVhZGVyJyxcbiAgICAgICAgcG9wb3ZlckNvbnRlbnQ6ICdjYXJkLWJvZHknLFxuICAgICAgICAvLyBkYXkgZ3JpZFxuICAgICAgICAvLyBmb3IgbGVmdC9yaWdodCBib3JkZXIgY29sb3Igd2hlbiBib3JkZXIgaXMgaW5zZXQgZnJvbSBlZGdlcyAoYWxsLWRheSBpbiB0aW1lR3JpZCB2aWV3KVxuICAgICAgICAvLyBhdm9pZCBgdGFibGVgIGNsYXNzIGIvYyBkb24ndCB3YW50IG1hcmdpbnMvcGFkZGluZy9zdHJ1Y3R1cmUuIG9ubHkgYm9yZGVyIGNvbG9yLlxuICAgICAgICBoZWFkZXJSb3c6ICd0YWJsZS1ib3JkZXJlZCcsXG4gICAgICAgIGRheVJvdzogJ3RhYmxlLWJvcmRlcmVkJyxcbiAgICAgICAgLy8gbGlzdCB2aWV3XG4gICAgICAgIGxpc3RWaWV3OiAnY2FyZCBjYXJkLXByaW1hcnknXG4gICAgfTtcbiAgICBCb290c3RyYXBUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYSc7XG4gICAgQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xuICAgICAgICBjbG9zZTogJ2ZhLXRpbWVzJyxcbiAgICAgICAgcHJldjogJ2ZhLWNoZXZyb24tbGVmdCcsXG4gICAgICAgIG5leHQ6ICdmYS1jaGV2cm9uLXJpZ2h0JyxcbiAgICAgICAgcHJldlllYXI6ICdmYS1hbmdsZS1kb3VibGUtbGVmdCcsXG4gICAgICAgIG5leHRZZWFyOiAnZmEtYW5nbGUtZG91YmxlLXJpZ2h0J1xuICAgIH07XG4gICAgQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdib290c3RyYXBGb250QXdlc29tZSc7XG4gICAgQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdib290c3RyYXBGb250QXdlc29tZSc7XG4gICAgQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICdmYS0nO1xuICAgIHZhciBtYWluID0gY29yZS5jcmVhdGVQbHVnaW4oe1xuICAgICAgICB0aGVtZUNsYXNzZXM6IHtcbiAgICAgICAgICAgIGJvb3RzdHJhcDogQm9vdHN0cmFwVGhlbWVcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhwb3J0cy5Cb290c3RyYXBUaGVtZSA9IEJvb3RzdHJhcFRoZW1lO1xuICAgIGV4cG9ydHMuZGVmYXVsdCA9IG1haW47XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/bootstrap/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\nFullCalendar Core Package v4.1.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\n(function (global, factory) {\n     true ? factory(exports) :\n    undefined;\n}(this, function (exports) { 'use strict';\n\n    // Creating\n    // ----------------------------------------------------------------------------------------------------------------\n    var elementPropHash = {\n        className: true,\n        colSpan: true,\n        rowSpan: true\n    };\n    var containerTagHash = {\n        '<tr': 'tbody',\n        '<td': 'tr'\n    };\n    function createElement(tagName, attrs, content) {\n        var el = document.createElement(tagName);\n        if (attrs) {\n            for (var attrName in attrs) {\n                if (attrName === 'style') {\n                    applyStyle(el, attrs[attrName]);\n                }\n                else if (elementPropHash[attrName]) {\n                    el[attrName] = attrs[attrName];\n                }\n                else {\n                    el.setAttribute(attrName, attrs[attrName]);\n                }\n            }\n        }\n        if (typeof content === 'string') {\n            el.innerHTML = content; // shortcut. no need to process HTML in any way\n        }\n        else if (content != null) {\n            appendToElement(el, content);\n        }\n        return el;\n    }\n    function htmlToElement(html) {\n        html = html.trim();\n        var container = document.createElement(computeContainerTag(html));\n        container.innerHTML = html;\n        return container.firstChild;\n    }\n    function htmlToElements(html) {\n        return Array.prototype.slice.call(htmlToNodeList(html));\n    }\n    function htmlToNodeList(html) {\n        html = html.trim();\n        var container = document.createElement(computeContainerTag(html));\n        container.innerHTML = html;\n        return container.childNodes;\n    }\n    // assumes html already trimmed and tag names are lowercase\n    function computeContainerTag(html) {\n        return containerTagHash[html.substr(0, 3) // faster than using regex\n        ] || 'div';\n    }\n    function appendToElement(el, content) {\n        var childNodes = normalizeContent(content);\n        for (var i = 0; i < childNodes.length; i++) {\n            el.appendChild(childNodes[i]);\n        }\n    }\n    function prependToElement(parent, content) {\n        var newEls = normalizeContent(content);\n        var afterEl = parent.firstChild || null; // if no firstChild, will append to end, but that's okay, b/c there were no children\n        for (var i = 0; i < newEls.length; i++) {\n            parent.insertBefore(newEls[i], afterEl);\n        }\n    }\n    function insertAfterElement(refEl, content) {\n        var newEls = normalizeContent(content);\n        var afterEl = refEl.nextSibling || null;\n        for (var i = 0; i < newEls.length; i++) {\n            refEl.parentNode.insertBefore(newEls[i], afterEl);\n        }\n    }\n    function normalizeContent(content) {\n        var els;\n        if (typeof content === 'string') {\n            els = htmlToElements(content);\n        }\n        else if (content instanceof Node) {\n            els = [content];\n        }\n        else { // Node[] or NodeList\n            els = Array.prototype.slice.call(content);\n        }\n        return els;\n    }\n    function removeElement(el) {\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n    // Querying\n    // ----------------------------------------------------------------------------------------------------------------\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    var matchesMethod = Element.prototype.matches ||\n        Element.prototype.matchesSelector ||\n        Element.prototype.msMatchesSelector;\n    var closestMethod = Element.prototype.closest || function (selector) {\n        // polyfill\n        var el = this;\n        if (!document.documentElement.contains(el)) {\n            return null;\n        }\n        do {\n            if (elementMatches(el, selector)) {\n                return el;\n            }\n            el = el.parentElement || el.parentNode;\n        } while (el !== null && el.nodeType === 1);\n        return null;\n    };\n    function elementClosest(el, selector) {\n        return closestMethod.call(el, selector);\n    }\n    function elementMatches(el, selector) {\n        return matchesMethod.call(el, selector);\n    }\n    // accepts multiple subject els\n    // returns a real array. good for methods like forEach\n    function findElements(container, selector) {\n        var containers = container instanceof HTMLElement ? [container] : container;\n        var allMatches = [];\n        for (var i = 0; i < containers.length; i++) {\n            var matches = containers[i].querySelectorAll(selector);\n            for (var j = 0; j < matches.length; j++) {\n                allMatches.push(matches[j]);\n            }\n        }\n        return allMatches;\n    }\n    // accepts multiple subject els\n    // only queries direct child elements\n    function findChildren(parent, selector) {\n        var parents = parent instanceof HTMLElement ? [parent] : parent;\n        var allMatches = [];\n        for (var i = 0; i < parents.length; i++) {\n            var childNodes = parents[i].children; // only ever elements\n            for (var j = 0; j < childNodes.length; j++) {\n                var childNode = childNodes[j];\n                if (!selector || elementMatches(childNode, selector)) {\n                    allMatches.push(childNode);\n                }\n            }\n        }\n        return allMatches;\n    }\n    // Attributes\n    // ----------------------------------------------------------------------------------------------------------------\n    function forceClassName(el, className, bool) {\n        if (bool) {\n            el.classList.add(className);\n        }\n        else {\n            el.classList.remove(className);\n        }\n    }\n    // Style\n    // ----------------------------------------------------------------------------------------------------------------\n    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n    function applyStyle(el, props) {\n        for (var propName in props) {\n            applyStyleProp(el, propName, props[propName]);\n        }\n    }\n    function applyStyleProp(el, name, val) {\n        if (val == null) {\n            el.style[name] = '';\n        }\n        else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n            el.style[name] = val + 'px';\n        }\n        else {\n            el.style[name] = val;\n        }\n    }\n\n    function pointInsideRect(point, rect) {\n        return point.left >= rect.left &&\n            point.left < rect.right &&\n            point.top >= rect.top &&\n            point.top < rect.bottom;\n    }\n    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n    function intersectRects(rect1, rect2) {\n        var res = {\n            left: Math.max(rect1.left, rect2.left),\n            right: Math.min(rect1.right, rect2.right),\n            top: Math.max(rect1.top, rect2.top),\n            bottom: Math.min(rect1.bottom, rect2.bottom)\n        };\n        if (res.left < res.right && res.top < res.bottom) {\n            return res;\n        }\n        return false;\n    }\n    function translateRect(rect, deltaX, deltaY) {\n        return {\n            left: rect.left + deltaX,\n            right: rect.right + deltaX,\n            top: rect.top + deltaY,\n            bottom: rect.bottom + deltaY\n        };\n    }\n    // Returns a new point that will have been moved to reside within the given rectangle\n    function constrainPoint(point, rect) {\n        return {\n            left: Math.min(Math.max(point.left, rect.left), rect.right),\n            top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n        };\n    }\n    // Returns a point that is the center of the given rectangle\n    function getRectCenter(rect) {\n        return {\n            left: (rect.left + rect.right) / 2,\n            top: (rect.top + rect.bottom) / 2\n        };\n    }\n    // Subtracts point2's coordinates from point1's coordinates, returning a delta\n    function diffPoints(point1, point2) {\n        return {\n            left: point1.left - point2.left,\n            top: point1.top - point2.top\n        };\n    }\n\n    // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\n    var isRtlScrollbarOnLeft = null;\n    function getIsRtlScrollbarOnLeft() {\n        if (isRtlScrollbarOnLeft === null) {\n            isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n        }\n        return isRtlScrollbarOnLeft;\n    }\n    function computeIsRtlScrollbarOnLeft() {\n        var outerEl = createElement('div', {\n            style: {\n                position: 'absolute',\n                top: -1000,\n                left: 0,\n                border: 0,\n                padding: 0,\n                overflow: 'scroll',\n                direction: 'rtl'\n            }\n        }, '<div></div>');\n        document.body.appendChild(outerEl);\n        var innerEl = outerEl.firstChild;\n        var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n        removeElement(outerEl);\n        return res;\n    }\n    // The scrollbar width computations in computeEdges are sometimes flawed when it comes to\n    // retina displays, rounding, and IE11. Massage them into a usable value.\n    function sanitizeScrollbarWidth(width) {\n        width = Math.max(0, width); // no negatives\n        width = Math.round(width);\n        return width;\n    }\n\n    function computeEdges(el, getPadding) {\n        if (getPadding === void 0) { getPadding = false; }\n        var computedStyle = window.getComputedStyle(el);\n        var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n        var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n        var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n        var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n        var scrollbarLeftRight = sanitizeScrollbarWidth(el.offsetWidth - el.clientWidth - borderLeft - borderRight);\n        var scrollbarBottom = sanitizeScrollbarWidth(el.offsetHeight - el.clientHeight - borderTop - borderBottom);\n        var res = {\n            borderLeft: borderLeft,\n            borderRight: borderRight,\n            borderTop: borderTop,\n            borderBottom: borderBottom,\n            scrollbarBottom: scrollbarBottom,\n            scrollbarLeft: 0,\n            scrollbarRight: 0\n        };\n        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?\n            res.scrollbarLeft = scrollbarLeftRight;\n        }\n        else {\n            res.scrollbarRight = scrollbarLeftRight;\n        }\n        if (getPadding) {\n            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n        }\n        return res;\n    }\n    function computeInnerRect(el, goWithinPadding) {\n        if (goWithinPadding === void 0) { goWithinPadding = false; }\n        var outerRect = computeRect(el);\n        var edges = computeEdges(el, goWithinPadding);\n        var res = {\n            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n            right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n            top: outerRect.top + edges.borderTop,\n            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n        };\n        if (goWithinPadding) {\n            res.left += edges.paddingLeft;\n            res.right -= edges.paddingRight;\n            res.top += edges.paddingTop;\n            res.bottom -= edges.paddingBottom;\n        }\n        return res;\n    }\n    function computeRect(el) {\n        var rect = el.getBoundingClientRect();\n        return {\n            left: rect.left + window.pageXOffset,\n            top: rect.top + window.pageYOffset,\n            right: rect.right + window.pageXOffset,\n            bottom: rect.bottom + window.pageYOffset\n        };\n    }\n    function computeViewportRect() {\n        return {\n            left: window.pageXOffset,\n            right: window.pageXOffset + document.documentElement.clientWidth,\n            top: window.pageYOffset,\n            bottom: window.pageYOffset + document.documentElement.clientHeight\n        };\n    }\n    function computeHeightAndMargins(el) {\n        var computed = window.getComputedStyle(el);\n        return el.getBoundingClientRect().height +\n            parseInt(computed.marginTop, 10) +\n            parseInt(computed.marginBottom, 10);\n    }\n    // does not return window\n    function getClippingParents(el) {\n        var parents = [];\n        while (el instanceof HTMLElement) { // will stop when gets to document or null\n            var computedStyle = window.getComputedStyle(el);\n            if (computedStyle.position === 'fixed') {\n                break;\n            }\n            if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n                parents.push(el);\n            }\n            el = el.parentNode;\n        }\n        return parents;\n    }\n    function computeClippingRect(el) {\n        return getClippingParents(el)\n            .map(function (el) {\n            return computeInnerRect(el);\n        })\n            .concat(computeViewportRect())\n            .reduce(function (rect0, rect1) {\n            return intersectRects(rect0, rect1) || rect1; // should always intersect\n        });\n    }\n\n    // Stops a mouse/touch event from doing it's native browser action\n    function preventDefault(ev) {\n        ev.preventDefault();\n    }\n    // Event Delegation\n    // ----------------------------------------------------------------------------------------------------------------\n    function listenBySelector(container, eventType, selector, handler) {\n        function realHandler(ev) {\n            var matchedChild = elementClosest(ev.target, selector);\n            if (matchedChild) {\n                handler.call(matchedChild, ev, matchedChild);\n            }\n        }\n        container.addEventListener(eventType, realHandler);\n        return function () {\n            container.removeEventListener(eventType, realHandler);\n        };\n    }\n    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n        var currentMatchedChild;\n        return listenBySelector(container, 'mouseover', selector, function (ev, matchedChild) {\n            if (matchedChild !== currentMatchedChild) {\n                currentMatchedChild = matchedChild;\n                onMouseEnter(ev, matchedChild);\n                var realOnMouseLeave_1 = function (ev) {\n                    currentMatchedChild = null;\n                    onMouseLeave(ev, matchedChild);\n                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n                };\n                // listen to the next mouseleave, and then unattach\n                matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n            }\n        });\n    }\n    // Animation\n    // ----------------------------------------------------------------------------------------------------------------\n    var transitionEventNames = [\n        'webkitTransitionEnd',\n        'otransitionend',\n        'oTransitionEnd',\n        'msTransitionEnd',\n        'transitionend'\n    ];\n    // triggered only when the next single subsequent transition finishes\n    function whenTransitionDone(el, callback) {\n        var realCallback = function (ev) {\n            callback(ev);\n            transitionEventNames.forEach(function (eventName) {\n                el.removeEventListener(eventName, realCallback);\n            });\n        };\n        transitionEventNames.forEach(function (eventName) {\n            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n        });\n    }\n\n    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n    // Adding\n    function addWeeks(m, n) {\n        var a = dateToUtcArray(m);\n        a[2] += n * 7;\n        return arrayToUtcDate(a);\n    }\n    function addDays(m, n) {\n        var a = dateToUtcArray(m);\n        a[2] += n;\n        return arrayToUtcDate(a);\n    }\n    function addMs(m, n) {\n        var a = dateToUtcArray(m);\n        a[6] += n;\n        return arrayToUtcDate(a);\n    }\n    // Diffing (all return floats)\n    function diffWeeks(m0, m1) {\n        return diffDays(m0, m1) / 7;\n    }\n    function diffDays(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n    }\n    function diffHours(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n    }\n    function diffMinutes(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n    }\n    function diffSeconds(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / 1000;\n    }\n    function diffDayAndTime(m0, m1) {\n        var m0day = startOfDay(m0);\n        var m1day = startOfDay(m1);\n        return {\n            years: 0,\n            months: 0,\n            days: Math.round(diffDays(m0day, m1day)),\n            milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf())\n        };\n    }\n    // Diffing Whole Units\n    function diffWholeWeeks(m0, m1) {\n        var d = diffWholeDays(m0, m1);\n        if (d !== null && d % 7 === 0) {\n            return d / 7;\n        }\n        return null;\n    }\n    function diffWholeDays(m0, m1) {\n        if (timeAsMs(m0) === timeAsMs(m1)) {\n            return Math.round(diffDays(m0, m1));\n        }\n        return null;\n    }\n    // Start-Of\n    function startOfDay(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate()\n        ]);\n    }\n    function startOfHour(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours()\n        ]);\n    }\n    function startOfMinute(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes()\n        ]);\n    }\n    function startOfSecond(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes(),\n            m.getUTCSeconds()\n        ]);\n    }\n    // Week Computation\n    function weekOfYear(marker, dow, doy) {\n        var y = marker.getUTCFullYear();\n        var w = weekOfGivenYear(marker, y, dow, doy);\n        if (w < 1) {\n            return weekOfGivenYear(marker, y - 1, dow, doy);\n        }\n        var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n        if (nextW >= 1) {\n            return Math.min(w, nextW);\n        }\n        return w;\n    }\n    function weekOfGivenYear(marker, year, dow, doy) {\n        var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n        var dayStart = startOfDay(marker);\n        var days = Math.round(diffDays(firstWeekStart, dayStart));\n        return Math.floor(days / 7) + 1; // zero-indexed\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        var fwd = 7 + dow - doy;\n        // first-week day local weekday -- which local weekday is fwd\n        var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // Array Conversion\n    function dateToLocalArray(date) {\n        return [\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds()\n        ];\n    }\n    function arrayToLocalDate(a) {\n        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n        a[3] || 0, a[4] || 0, a[5] || 0);\n    }\n    function dateToUtcArray(date) {\n        return [\n            date.getUTCFullYear(),\n            date.getUTCMonth(),\n            date.getUTCDate(),\n            date.getUTCHours(),\n            date.getUTCMinutes(),\n            date.getUTCSeconds(),\n            date.getUTCMilliseconds()\n        ];\n    }\n    function arrayToUtcDate(a) {\n        // according to web standards (and Safari), a month index is required.\n        // massage if only given a year.\n        if (a.length === 1) {\n            a = a.concat([0]);\n        }\n        return new Date(Date.UTC.apply(Date, a));\n    }\n    // Other Utils\n    function isValidDate(m) {\n        return !isNaN(m.valueOf());\n    }\n    function timeAsMs(m) {\n        return m.getUTCHours() * 1000 * 60 * 60 +\n            m.getUTCMinutes() * 1000 * 60 +\n            m.getUTCSeconds() * 1000 +\n            m.getUTCMilliseconds();\n    }\n\n    var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\n    var PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n    // Parsing and Creation\n    function createDuration(input, unit) {\n        var _a;\n        if (typeof input === 'string') {\n            return parseString(input);\n        }\n        else if (typeof input === 'object' && input) { // non-null object\n            return normalizeObject(input);\n        }\n        else if (typeof input === 'number') {\n            return normalizeObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n        }\n        else {\n            return null;\n        }\n    }\n    function parseString(s) {\n        var m = PARSE_RE.exec(s);\n        if (m) {\n            var sign = m[1] ? -1 : 1;\n            return {\n                years: 0,\n                months: 0,\n                days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n                    (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n                    (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n                    (m[6] ? parseInt(m[6], 10) : 0) // ms\n                )\n            };\n        }\n        return null;\n    }\n    function normalizeObject(obj) {\n        return {\n            years: obj.years || obj.year || 0,\n            months: obj.months || obj.month || 0,\n            days: (obj.days || obj.day || 0) +\n                getWeeksFromInput(obj) * 7,\n            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n                (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n                (obj.seconds || obj.second || 0) * 1000 + // seconds\n                (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n        };\n    }\n    function getWeeksFromInput(obj) {\n        return obj.weeks || obj.week || 0;\n    }\n    // Equality\n    function durationsEqual(d0, d1) {\n        return d0.years === d1.years &&\n            d0.months === d1.months &&\n            d0.days === d1.days &&\n            d0.milliseconds === d1.milliseconds;\n    }\n    function isSingleDay(dur) {\n        return dur.years === 0 && dur.months === 0 && dur.days === 1 && dur.milliseconds === 0;\n    }\n    // Simple Math\n    function addDurations(d0, d1) {\n        return {\n            years: d0.years + d1.years,\n            months: d0.months + d1.months,\n            days: d0.days + d1.days,\n            milliseconds: d0.milliseconds + d1.milliseconds\n        };\n    }\n    function subtractDurations(d1, d0) {\n        return {\n            years: d1.years - d0.years,\n            months: d1.months - d0.months,\n            days: d1.days - d0.days,\n            milliseconds: d1.milliseconds - d0.milliseconds\n        };\n    }\n    function multiplyDuration(d, n) {\n        return {\n            years: d.years * n,\n            months: d.months * n,\n            days: d.days * n,\n            milliseconds: d.milliseconds * n\n        };\n    }\n    // Conversions\n    // \"Rough\" because they are based on average-case Gregorian months/years\n    function asRoughYears(dur) {\n        return asRoughDays(dur) / 365;\n    }\n    function asRoughMonths(dur) {\n        return asRoughDays(dur) / 30;\n    }\n    function asRoughDays(dur) {\n        return asRoughMs(dur) / 864e5;\n    }\n    function asRoughMinutes(dur) {\n        return asRoughMs(dur) / (1000 * 60);\n    }\n    function asRoughSeconds(dur) {\n        return asRoughMs(dur) / 1000;\n    }\n    function asRoughMs(dur) {\n        return dur.years * (365 * 864e5) +\n            dur.months * (30 * 864e5) +\n            dur.days * 864e5 +\n            dur.milliseconds;\n    }\n    // Advanced Math\n    function wholeDivideDurations(numerator, denominator) {\n        var res = null;\n        for (var i = 0; i < INTERNAL_UNITS.length; i++) {\n            var unit = INTERNAL_UNITS[i];\n            if (denominator[unit]) {\n                var localRes = numerator[unit] / denominator[unit];\n                if (!isInt(localRes) || (res !== null && res !== localRes)) {\n                    return null;\n                }\n                res = localRes;\n            }\n            else if (numerator[unit]) {\n                // needs to divide by something but can't!\n                return null;\n            }\n        }\n        return res;\n    }\n    function greatestDurationDenominator(dur, dontReturnWeeks) {\n        var ms = dur.milliseconds;\n        if (ms) {\n            if (ms % 1000 !== 0) {\n                return { unit: 'millisecond', value: ms };\n            }\n            if (ms % (1000 * 60) !== 0) {\n                return { unit: 'second', value: ms / 1000 };\n            }\n            if (ms % (1000 * 60 * 60) !== 0) {\n                return { unit: 'minute', value: ms / (1000 * 60) };\n            }\n            if (ms) {\n                return { unit: 'hour', value: ms / (1000 * 60 * 60) };\n            }\n        }\n        if (dur.days) {\n            if (!dontReturnWeeks && dur.days % 7 === 0) {\n                return { unit: 'week', value: dur.days / 7 };\n            }\n            return { unit: 'day', value: dur.days };\n        }\n        if (dur.months) {\n            return { unit: 'month', value: dur.months };\n        }\n        if (dur.years) {\n            return { unit: 'year', value: dur.years };\n        }\n        return { unit: 'millisecond', value: 0 };\n    }\n\n    /* FullCalendar-specific DOM Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\n    // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\n    function compensateScroll(rowEl, scrollbarWidths) {\n        if (scrollbarWidths.left) {\n            applyStyle(rowEl, {\n                borderLeftWidth: 1,\n                marginLeft: scrollbarWidths.left - 1\n            });\n        }\n        if (scrollbarWidths.right) {\n            applyStyle(rowEl, {\n                borderRightWidth: 1,\n                marginRight: scrollbarWidths.right - 1\n            });\n        }\n    }\n    // Undoes compensateScroll and restores all borders/margins\n    function uncompensateScroll(rowEl) {\n        applyStyle(rowEl, {\n            marginLeft: '',\n            marginRight: '',\n            borderLeftWidth: '',\n            borderRightWidth: ''\n        });\n    }\n    // Make the mouse cursor express that an event is not allowed in the current area\n    function disableCursor() {\n        document.body.classList.add('fc-not-allowed');\n    }\n    // Returns the mouse cursor to its original look\n    function enableCursor() {\n        document.body.classList.remove('fc-not-allowed');\n    }\n    // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\n    // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\n    // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and\n    // reduces the available height.\n    function distributeHeight(els, availableHeight, shouldRedistribute) {\n        // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\n        // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\n        var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\n        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\n        var flexEls = []; // elements that are allowed to expand. array of DOM nodes\n        var flexOffsets = []; // amount of vertical space it takes up\n        var flexHeights = []; // actual css height\n        var usedHeight = 0;\n        undistributeHeight(els); // give all elements their natural height\n        // find elements that are below the recommended height (expandable).\n        // important to query for heights in a single first pass (to avoid reflow oscillation).\n        els.forEach(function (el, i) {\n            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\n            var naturalOffset = computeHeightAndMargins(el);\n            if (naturalOffset < minOffset) {\n                flexEls.push(el);\n                flexOffsets.push(naturalOffset);\n                flexHeights.push(el.offsetHeight);\n            }\n            else {\n                // this element stretches past recommended height (non-expandable). mark the space as occupied.\n                usedHeight += naturalOffset;\n            }\n        });\n        // readjust the recommended height to only consider the height available to non-maxed-out rows.\n        if (shouldRedistribute) {\n            availableHeight -= usedHeight;\n            minOffset1 = Math.floor(availableHeight / flexEls.length);\n            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\n        }\n        // assign heights to all expandable elements\n        flexEls.forEach(function (el, i) {\n            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\n            var naturalOffset = flexOffsets[i];\n            var naturalHeight = flexHeights[i];\n            var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\n            if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things\n                el.style.height = newHeight + 'px';\n            }\n        });\n    }\n    // Undoes distrubuteHeight, restoring all els to their natural height\n    function undistributeHeight(els) {\n        els.forEach(function (el) {\n            el.style.height = '';\n        });\n    }\n    // Given `els`, a set of <td> cells, find the cell with the largest natural width and set the widths of all the\n    // cells to be that width.\n    // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\n    function matchCellWidths(els) {\n        var maxInnerWidth = 0;\n        els.forEach(function (el) {\n            var innerEl = el.firstChild; // hopefully an element\n            if (innerEl instanceof HTMLElement) {\n                var innerWidth_1 = innerEl.offsetWidth;\n                if (innerWidth_1 > maxInnerWidth) {\n                    maxInnerWidth = innerWidth_1;\n                }\n            }\n        });\n        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\n        els.forEach(function (el) {\n            el.style.width = maxInnerWidth + 'px';\n        });\n        return maxInnerWidth;\n    }\n    // Given one element that resides inside another,\n    // Subtracts the height of the inner element from the outer element.\n    function subtractInnerElHeight(outerEl, innerEl) {\n        // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\n        var reflowStyleProps = {\n            position: 'relative',\n            left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\n        };\n        applyStyle(outerEl, reflowStyleProps);\n        applyStyle(innerEl, reflowStyleProps);\n        var diff = outerEl.offsetHeight - innerEl.offsetHeight; // grab the dimensions\n        // undo hack\n        var resetStyleProps = { position: '', left: '' };\n        applyStyle(outerEl, resetStyleProps);\n        applyStyle(innerEl, resetStyleProps);\n        return diff;\n    }\n    /* Selection\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function preventSelection(el) {\n        el.classList.add('fc-unselectable');\n        el.addEventListener('selectstart', preventDefault);\n    }\n    function allowSelection(el) {\n        el.classList.remove('fc-unselectable');\n        el.removeEventListener('selectstart', preventDefault);\n    }\n    /* Context Menu\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function preventContextMenu(el) {\n        el.addEventListener('contextmenu', preventDefault);\n    }\n    function allowContextMenu(el) {\n        el.removeEventListener('contextmenu', preventDefault);\n    }\n    /* Object Ordering by Field\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function parseFieldSpecs(input) {\n        var specs = [];\n        var tokens = [];\n        var i;\n        var token;\n        if (typeof input === 'string') {\n            tokens = input.split(/\\s*,\\s*/);\n        }\n        else if (typeof input === 'function') {\n            tokens = [input];\n        }\n        else if (Array.isArray(input)) {\n            tokens = input;\n        }\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            if (typeof token === 'string') {\n                specs.push(token.charAt(0) === '-' ?\n                    { field: token.substring(1), order: -1 } :\n                    { field: token, order: 1 });\n            }\n            else if (typeof token === 'function') {\n                specs.push({ func: token });\n            }\n        }\n        return specs;\n    }\n    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n        var i;\n        var cmp;\n        for (i = 0; i < fieldSpecs.length; i++) {\n            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n            if (cmp) {\n                return cmp;\n            }\n        }\n        return 0;\n    }\n    function compareByFieldSpec(obj0, obj1, fieldSpec) {\n        if (fieldSpec.func) {\n            return fieldSpec.func(obj0, obj1);\n        }\n        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])\n            * (fieldSpec.order || 1);\n    }\n    function flexibleCompare(a, b) {\n        if (!a && !b) {\n            return 0;\n        }\n        if (b == null) {\n            return -1;\n        }\n        if (a == null) {\n            return 1;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            return String(a).localeCompare(String(b));\n        }\n        return a - b;\n    }\n    /* String Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function capitaliseFirstLetter(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n    function padStart(val, len) {\n        var s = String(val);\n        return '000'.substr(0, len - s.length) + s;\n    }\n    /* Number Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n    function isInt(n) {\n        return n % 1 === 0;\n    }\n    /* Weird Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function applyAll(functions, thisObj, args) {\n        if (typeof functions === 'function') { // supplied a single function\n            functions = [functions];\n        }\n        if (functions) {\n            var i = void 0;\n            var ret = void 0;\n            for (i = 0; i < functions.length; i++) {\n                ret = functions[i].apply(thisObj, args) || ret;\n            }\n            return ret;\n        }\n    }\n    function firstDefined() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        for (var i = 0; i < args.length; i++) {\n            if (args[i] !== undefined) {\n                return args[i];\n            }\n        }\n    }\n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds. If `immediate` is passed, trigger the function on the\n    // leading edge, instead of the trailing.\n    // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\n    function debounce(func, wait) {\n        var timeout;\n        var args;\n        var context;\n        var timestamp;\n        var result;\n        var later = function () {\n            var last = new Date().valueOf() - timestamp;\n            if (last < wait) {\n                timeout = setTimeout(later, wait - last);\n            }\n            else {\n                timeout = null;\n                result = func.apply(context, args);\n                context = args = null;\n            }\n        };\n        return function () {\n            context = this;\n            args = arguments;\n            timestamp = new Date().valueOf();\n            if (!timeout) {\n                timeout = setTimeout(later, wait);\n            }\n            return result;\n        };\n    }\n    // Number and Boolean are only types that defaults or not computed for\n    // TODO: write more comments\n    function refineProps(rawProps, processors, defaults, leftoverProps) {\n        if (defaults === void 0) { defaults = {}; }\n        var refined = {};\n        for (var key in processors) {\n            var processor = processors[key];\n            if (rawProps[key] !== undefined) {\n                // found\n                if (processor === Function) {\n                    refined[key] = typeof rawProps[key] === 'function' ? rawProps[key] : null;\n                }\n                else if (processor) { // a refining function?\n                    refined[key] = processor(rawProps[key]);\n                }\n                else {\n                    refined[key] = rawProps[key];\n                }\n            }\n            else if (defaults[key] !== undefined) {\n                // there's an explicit default\n                refined[key] = defaults[key];\n            }\n            else {\n                // must compute a default\n                if (processor === String) {\n                    refined[key] = ''; // empty string is default for String\n                }\n                else if (!processor || processor === Number || processor === Boolean || processor === Function) {\n                    refined[key] = null; // assign null for other non-custom processor funcs\n                }\n                else {\n                    refined[key] = processor(null); // run the custom processor func\n                }\n            }\n        }\n        if (leftoverProps) {\n            for (var key in rawProps) {\n                if (processors[key] === undefined) {\n                    leftoverProps[key] = rawProps[key];\n                }\n            }\n        }\n        return refined;\n    }\n    /*\n    Get a snapshot of an object, so we can compare it to later revisions.\n    Intentionally only works with arrays, jaja\n    */\n    function freezeRaw(raw) {\n        if (Array.isArray(raw)) {\n            return Array.prototype.slice.call(raw);\n        }\n        return raw;\n    }\n    /* Date stuff that doesn't belong in datelib core\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // given a timed range, computes an all-day range that has the same exact duration,\n    // but whose start time is aligned with the start of the day.\n    function computeAlignedDayRange(timedRange) {\n        var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n        var start = startOfDay(timedRange.start);\n        var end = addDays(start, dayCnt);\n        return { start: start, end: end };\n    }\n    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n    // TODO: give nextDayThreshold a default arg\n    function computeVisibleDayRange(timedRange, nextDayThreshold) {\n        if (nextDayThreshold === void 0) { nextDayThreshold = createDuration(0); }\n        var startDay = null;\n        var endDay = null;\n        if (timedRange.end) {\n            endDay = startOfDay(timedRange.end);\n            var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n            // If the end time is actually inclusively part of the next day and is equal to or\n            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n                endDay = addDays(endDay, 1);\n            }\n        }\n        if (timedRange.start) {\n            startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n            if (endDay && endDay <= startDay) {\n                endDay = addDays(startDay, 1);\n            }\n        }\n        return { start: startDay, end: endDay };\n    }\n    // spans from one day into another?\n    function isMultiDayRange(range) {\n        var visibleRange = computeVisibleDayRange(range);\n        return diffDays(visibleRange.start, visibleRange.end) > 1;\n    }\n    function diffDates(date0, date1, dateEnv, largeUnit) {\n        if (largeUnit === 'year') {\n            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n        }\n        else if (largeUnit === 'month') {\n            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n        }\n        else {\n            return diffDayAndTime(date0, date1); // returns a duration\n        }\n    }\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    function parseRecurring(eventInput, allDayDefault, dateEnv, recurringTypes, leftovers) {\n        for (var i = 0; i < recurringTypes.length; i++) {\n            var localLeftovers = {};\n            var parsed = recurringTypes[i].parse(eventInput, localLeftovers, dateEnv);\n            if (parsed) {\n                var allDay = localLeftovers.allDay;\n                delete localLeftovers.allDay; // remove from leftovers\n                if (allDay == null) {\n                    allDay = allDayDefault;\n                    if (allDay == null) {\n                        allDay = parsed.allDayGuess;\n                        if (allDay == null) {\n                            allDay = false;\n                        }\n                    }\n                }\n                __assign(leftovers, localLeftovers);\n                return {\n                    allDay: allDay,\n                    duration: parsed.duration,\n                    typeData: parsed.typeData,\n                    typeId: i\n                };\n            }\n        }\n        return null;\n    }\n    /*\n    Event MUST have a recurringDef\n    */\n    function expandRecurringRanges(eventDef, framingRange, dateEnv, recurringTypes) {\n        var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n        var markers = typeDef.expand(eventDef.recurringDef.typeData, framingRange, dateEnv);\n        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n        if (eventDef.allDay) {\n            markers = markers.map(startOfDay);\n        }\n        return markers;\n    }\n\n    // Merges an array of objects into a single object.\n    // The second argument allows for an array of property names who's object values will be merged together.\n    function mergeProps(propObjs, complexProps) {\n        var dest = {};\n        var i;\n        var name;\n        var complexObjs;\n        var j;\n        var val;\n        var props;\n        if (complexProps) {\n            for (i = 0; i < complexProps.length; i++) {\n                name = complexProps[i];\n                complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for (j = propObjs.length - 1; j >= 0; j--) {\n                    val = propObjs[j][name];\n                    if (typeof val === 'object' && val) { // non-null object\n                        complexObjs.unshift(val);\n                    }\n                    else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n        // copy values into the destination, going from last to first\n        for (i = propObjs.length - 1; i >= 0; i--) {\n            props = propObjs[i];\n            for (name in props) {\n                if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\n                    dest[name] = props[name];\n                }\n            }\n        }\n        return dest;\n    }\n    function filterHash(hash, func) {\n        var filtered = {};\n        for (var key in hash) {\n            if (func(hash[key], key)) {\n                filtered[key] = hash[key];\n            }\n        }\n        return filtered;\n    }\n    function mapHash(hash, func) {\n        var newHash = {};\n        for (var key in hash) {\n            newHash[key] = func(hash[key], key);\n        }\n        return newHash;\n    }\n    function arrayToHash(a) {\n        var hash = {};\n        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n            var item = a_1[_i];\n            hash[item] = true;\n        }\n        return hash;\n    }\n    function hashValuesToArray(obj) {\n        var a = [];\n        for (var key in obj) {\n            a.push(obj[key]);\n        }\n        return a;\n    }\n\n    function parseEvents(rawEvents, sourceId, calendar, allowOpenRange) {\n        var eventStore = createEmptyEventStore();\n        for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n            var rawEvent = rawEvents_1[_i];\n            var tuple = parseEvent(rawEvent, sourceId, calendar, allowOpenRange);\n            if (tuple) {\n                eventTupleToStore(tuple, eventStore);\n            }\n        }\n        return eventStore;\n    }\n    function eventTupleToStore(tuple, eventStore) {\n        if (eventStore === void 0) { eventStore = createEmptyEventStore(); }\n        eventStore.defs[tuple.def.defId] = tuple.def;\n        if (tuple.instance) {\n            eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n        }\n        return eventStore;\n    }\n    function expandRecurring(eventStore, framingRange, calendar) {\n        var dateEnv = calendar.dateEnv;\n        var defs = eventStore.defs, instances = eventStore.instances;\n        // remove existing recurring instances\n        instances = filterHash(instances, function (instance) {\n            return !defs[instance.defId].recurringDef;\n        });\n        for (var defId in defs) {\n            var def = defs[defId];\n            if (def.recurringDef) {\n                var starts = expandRecurringRanges(def, framingRange, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes);\n                var duration = def.recurringDef.duration;\n                if (!duration) {\n                    duration = def.allDay ?\n                        calendar.defaultAllDayEventDuration :\n                        calendar.defaultTimedEventDuration;\n                }\n                for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n                    var start = starts_1[_i];\n                    var instance = createEventInstance(defId, {\n                        start: start,\n                        end: dateEnv.add(start, duration)\n                    });\n                    instances[instance.instanceId] = instance;\n                }\n            }\n        }\n        return { defs: defs, instances: instances };\n    }\n    // retrieves events that have the same groupId as the instance specified by `instanceId`\n    // or they are the same as the instance.\n    // why might instanceId not be in the store? an event from another calendar?\n    function getRelevantEvents(eventStore, instanceId) {\n        var instance = eventStore.instances[instanceId];\n        if (instance) {\n            var def_1 = eventStore.defs[instance.defId];\n            // get events/instances with same group\n            var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n                return isEventDefsGrouped(def_1, lookDef);\n            });\n            // add the original\n            // TODO: wish we could use eventTupleToStore or something like it\n            newStore.defs[def_1.defId] = def_1;\n            newStore.instances[instance.instanceId] = instance;\n            return newStore;\n        }\n        return createEmptyEventStore();\n    }\n    function isEventDefsGrouped(def0, def1) {\n        return Boolean(def0.groupId && def0.groupId === def1.groupId);\n    }\n    function transformRawEvents(rawEvents, eventSource, calendar) {\n        var calEachTransform = calendar.opt('eventDataTransform');\n        var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n        if (sourceEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n        }\n        if (calEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n        }\n        return rawEvents;\n    }\n    function transformEachRawEvent(rawEvents, func) {\n        var refinedEvents;\n        if (!func) {\n            refinedEvents = rawEvents;\n        }\n        else {\n            refinedEvents = [];\n            for (var _i = 0, rawEvents_2 = rawEvents; _i < rawEvents_2.length; _i++) {\n                var rawEvent = rawEvents_2[_i];\n                var refinedEvent = func(rawEvent);\n                if (refinedEvent) {\n                    refinedEvents.push(refinedEvent);\n                }\n                else if (refinedEvent == null) {\n                    refinedEvents.push(rawEvent);\n                } // if a different falsy value, do nothing\n            }\n        }\n        return refinedEvents;\n    }\n    function createEmptyEventStore() {\n        return { defs: {}, instances: {} };\n    }\n    function mergeEventStores(store0, store1) {\n        return {\n            defs: __assign({}, store0.defs, store1.defs),\n            instances: __assign({}, store0.instances, store1.instances)\n        };\n    }\n    function filterEventStoreDefs(eventStore, filterFunc) {\n        var defs = filterHash(eventStore.defs, filterFunc);\n        var instances = filterHash(eventStore.instances, function (instance) {\n            return defs[instance.defId]; // still exists?\n        });\n        return { defs: defs, instances: instances };\n    }\n\n    function parseRange(input, dateEnv) {\n        var start = null;\n        var end = null;\n        if (input.start) {\n            start = dateEnv.createMarker(input.start);\n        }\n        if (input.end) {\n            end = dateEnv.createMarker(input.end);\n        }\n        if (!start && !end) {\n            return null;\n        }\n        if (start && end && end < start) {\n            return null;\n        }\n        return { start: start, end: end };\n    }\n    // SIDE-EFFECT: will mutate ranges.\n    // Will return a new array result.\n    function invertRanges(ranges, constraintRange) {\n        var invertedRanges = [];\n        var start = constraintRange.start; // the end of the previous range. the start of the new range\n        var i;\n        var dateRange;\n        // ranges need to be in order. required for our date-walking algorithm\n        ranges.sort(compareRanges);\n        for (i = 0; i < ranges.length; i++) {\n            dateRange = ranges[i];\n            // add the span of time before the event (if there is any)\n            if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)\n                invertedRanges.push({ start: start, end: dateRange.start });\n            }\n            if (dateRange.end > start) {\n                start = dateRange.end;\n            }\n        }\n        // add the span of time after the last event (if there is any)\n        if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)\n            invertedRanges.push({ start: start, end: constraintRange.end });\n        }\n        return invertedRanges;\n    }\n    function compareRanges(range0, range1) {\n        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n    }\n    function intersectRanges(range0, range1) {\n        var start = range0.start;\n        var end = range0.end;\n        var newRange = null;\n        if (range1.start !== null) {\n            if (start === null) {\n                start = range1.start;\n            }\n            else {\n                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n            }\n        }\n        if (range1.end != null) {\n            if (end === null) {\n                end = range1.end;\n            }\n            else {\n                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n            }\n        }\n        if (start === null || end === null || start < end) {\n            newRange = { start: start, end: end };\n        }\n        return newRange;\n    }\n    function rangesEqual(range0, range1) {\n        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&\n            (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n    }\n    function rangesIntersect(range0, range1) {\n        return (range0.end === null || range1.start === null || range0.end > range1.start) &&\n            (range0.start === null || range1.end === null || range0.start < range1.end);\n    }\n    function rangeContainsRange(outerRange, innerRange) {\n        return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&\n            (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));\n    }\n    function rangeContainsMarker(range, date) {\n        return (range.start === null || date >= range.start) &&\n            (range.end === null || date < range.end);\n    }\n    // If the given date is not within the given range, move it inside.\n    // (If it's past the end, make it one millisecond before the end).\n    function constrainMarkerToRange(date, range) {\n        if (range.start != null && date < range.start) {\n            return range.start;\n        }\n        if (range.end != null && date >= range.end) {\n            return new Date(range.end.valueOf() - 1);\n        }\n        return date;\n    }\n\n    function removeExact(array, exactVal) {\n        var removeCnt = 0;\n        var i = 0;\n        while (i < array.length) {\n            if (array[i] === exactVal) {\n                array.splice(i, 1);\n                removeCnt++;\n            }\n            else {\n                i++;\n            }\n        }\n        return removeCnt;\n    }\n    function isArraysEqual(a0, a1) {\n        var len = a0.length;\n        var i;\n        if (len !== a1.length) { // not array? or not same length?\n            return false;\n        }\n        for (i = 0; i < len; i++) {\n            if (a0[i] !== a1[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function memoize(workerFunc) {\n        var args;\n        var res;\n        return function () {\n            if (!args || !isArraysEqual(args, arguments)) {\n                args = arguments;\n                res = workerFunc.apply(this, arguments);\n            }\n            return res;\n        };\n    }\n    /*\n    always executes the workerFunc, but if the result is equal to the previous result,\n    return the previous result instead.\n    */\n    function memoizeOutput(workerFunc, equalityFunc) {\n        var cachedRes = null;\n        return function () {\n            var newRes = workerFunc.apply(this, arguments);\n            if (cachedRes === null || !(cachedRes === newRes || equalityFunc(cachedRes, newRes))) {\n                cachedRes = newRes;\n            }\n            return cachedRes;\n        };\n    }\n\n    var EXTENDED_SETTINGS_AND_SEVERITIES = {\n        week: 3,\n        separator: 0,\n        omitZeroMinute: 0,\n        meridiem: 0,\n        omitCommas: 0\n    };\n    var STANDARD_DATE_PROP_SEVERITIES = {\n        timeZoneName: 7,\n        era: 6,\n        year: 5,\n        month: 4,\n        day: 2,\n        weekday: 2,\n        hour: 1,\n        minute: 1,\n        second: 1\n    };\n    var MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n    var COMMA_RE = /,/g; // we need re for globalness\n    var MULTI_SPACE_RE = /\\s+/g;\n    var LTR_RE = /\\u200e/g; // control character\n    var UTC_RE = /UTC|GMT/;\n    var NativeFormatter = /** @class */ (function () {\n        function NativeFormatter(formatSettings) {\n            var standardDateProps = {};\n            var extendedSettings = {};\n            var severity = 0;\n            for (var name_1 in formatSettings) {\n                if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                    extendedSettings[name_1] = formatSettings[name_1];\n                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n                }\n                else {\n                    standardDateProps[name_1] = formatSettings[name_1];\n                    if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n                    }\n                }\n            }\n            this.standardDateProps = standardDateProps;\n            this.extendedSettings = extendedSettings;\n            this.severity = severity;\n            this.buildFormattingFunc = memoize(buildFormattingFunc);\n        }\n        NativeFormatter.prototype.format = function (date, context) {\n            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n        };\n        NativeFormatter.prototype.formatRange = function (start, end, context) {\n            var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;\n            var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n            if (!diffSeverity) {\n                return this.format(start, context);\n            }\n            var biggestUnitForPartial = diffSeverity;\n            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n                (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&\n                (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&\n                (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n            }\n            var full0 = this.format(start, context);\n            var full1 = this.format(end, context);\n            if (full0 === full1) {\n                return full0;\n            }\n            var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n            var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n            var partial0 = partialFormattingFunc(start);\n            var partial1 = partialFormattingFunc(end);\n            var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n            var separator = extendedSettings.separator || '';\n            if (insertion) {\n                return insertion.before + partial0 + separator + partial1 + insertion.after;\n            }\n            return full0 + separator + full1;\n        };\n        NativeFormatter.prototype.getLargestUnit = function () {\n            switch (this.severity) {\n                case 7:\n                case 6:\n                case 5:\n                    return 'year';\n                case 4:\n                    return 'month';\n                case 3:\n                    return 'week';\n                default:\n                    return 'day';\n            }\n        };\n        return NativeFormatter;\n    }());\n    function buildFormattingFunc(standardDateProps, extendedSettings, context) {\n        var standardDatePropCnt = Object.keys(standardDateProps).length;\n        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n            return function (date) {\n                return formatTimeZoneOffset(date.timeZoneOffset);\n            };\n        }\n        if (standardDatePropCnt === 0 && extendedSettings.week) {\n            return function (date) {\n                return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekLabel, context.locale, extendedSettings.week);\n            };\n        }\n        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n    }\n    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n        standardDateProps = __assign({}, standardDateProps); // copy\n        extendedSettings = __assign({}, extendedSettings); // copy\n        sanitizeSettings(standardDateProps, extendedSettings);\n        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n        var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n        var zeroFormat; // needed?\n        if (extendedSettings.omitZeroMinute) {\n            var zeroProps = __assign({}, standardDateProps);\n            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n        }\n        return function (date) {\n            var marker = date.marker;\n            var format;\n            if (zeroFormat && !marker.getUTCMinutes()) {\n                format = zeroFormat;\n            }\n            else {\n                format = normalFormat;\n            }\n            var s = format.format(marker);\n            return postProcess(s, date, standardDateProps, extendedSettings, context);\n        };\n    }\n    function sanitizeSettings(standardDateProps, extendedSettings) {\n        // deal with a browser inconsistency where formatting the timezone\n        // requires that the hour/minute be present.\n        if (standardDateProps.timeZoneName) {\n            if (!standardDateProps.hour) {\n                standardDateProps.hour = '2-digit';\n            }\n            if (!standardDateProps.minute) {\n                standardDateProps.minute = '2-digit';\n            }\n        }\n        // only support short timezone names\n        if (standardDateProps.timeZoneName === 'long') {\n            standardDateProps.timeZoneName = 'short';\n        }\n        // if requesting to display seconds, MUST display minutes\n        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n            delete extendedSettings.omitZeroMinute;\n        }\n    }\n    function postProcess(s, date, standardDateProps, extendedSettings, context) {\n        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n        if (standardDateProps.timeZoneName === 'short') {\n            s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?\n                'UTC' : // important to normalize for IE, which does \"GMT\"\n                formatTimeZoneOffset(date.timeZoneOffset));\n        }\n        if (extendedSettings.omitCommas) {\n            s = s.replace(COMMA_RE, '').trim();\n        }\n        if (extendedSettings.omitZeroMinute) {\n            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n        }\n        // ^ do anything that might create adjacent spaces before this point,\n        // because MERIDIEM_RE likes to eat up loading spaces\n        if (extendedSettings.meridiem === false) {\n            s = s.replace(MERIDIEM_RE, '').trim();\n        }\n        else if (extendedSettings.meridiem === 'narrow') { // a/p\n            s = s.replace(MERIDIEM_RE, function (m0, m1) {\n                return m1.toLocaleLowerCase();\n            });\n        }\n        else if (extendedSettings.meridiem === 'short') { // am/pm\n            s = s.replace(MERIDIEM_RE, function (m0, m1) {\n                return m1.toLocaleLowerCase() + 'm';\n            });\n        }\n        else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase\n            s = s.replace(MERIDIEM_RE, function (m0) {\n                return m0.toLocaleLowerCase();\n            });\n        }\n        s = s.replace(MULTI_SPACE_RE, ' ');\n        s = s.trim();\n        return s;\n    }\n    function injectTzoStr(s, tzoStr) {\n        var replaced = false;\n        s = s.replace(UTC_RE, function () {\n            replaced = true;\n            return tzoStr;\n        });\n        // IE11 doesn't include UTC/GMT in the original string, so append to end\n        if (!replaced) {\n            s += ' ' + tzoStr;\n        }\n        return s;\n    }\n    function formatWeekNumber(num, weekLabel, locale, display) {\n        var parts = [];\n        if (display === 'narrow') {\n            parts.push(weekLabel);\n        }\n        else if (display === 'short') {\n            parts.push(weekLabel, ' ');\n        }\n        // otherwise, considered 'numeric'\n        parts.push(locale.simpleNumberFormat.format(num));\n        if (locale.options.isRtl) { // TODO: use control characters instead?\n            parts.reverse();\n        }\n        return parts.join('');\n    }\n    // Range Formatting Utils\n    // 0 = exactly the same\n    // 1 = different by time\n    // and bigger\n    function computeMarkerDiffSeverity(d0, d1, ca) {\n        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n            return 5;\n        }\n        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n            return 4;\n        }\n        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n            return 2;\n        }\n        if (timeAsMs(d0) !== timeAsMs(d1)) {\n            return 1;\n        }\n        return 0;\n    }\n    function computePartialFormattingOptions(options, biggestUnit) {\n        var partialOptions = {};\n        for (var name_2 in options) {\n            if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n                STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n                partialOptions[name_2] = options[name_2];\n            }\n        }\n        return partialOptions;\n    }\n    function findCommonInsertion(full0, partial0, full1, partial1) {\n        var i0 = 0;\n        while (i0 < full0.length) {\n            var found0 = full0.indexOf(partial0, i0);\n            if (found0 === -1) {\n                break;\n            }\n            var before0 = full0.substr(0, found0);\n            i0 = found0 + partial0.length;\n            var after0 = full0.substr(i0);\n            var i1 = 0;\n            while (i1 < full1.length) {\n                var found1 = full1.indexOf(partial1, i1);\n                if (found1 === -1) {\n                    break;\n                }\n                var before1 = full1.substr(0, found1);\n                i1 = found1 + partial1.length;\n                var after1 = full1.substr(i1);\n                if (before0 === before1 && after0 === after1) {\n                    return {\n                        before: before0,\n                        after: after0\n                    };\n                }\n            }\n        }\n        return null;\n    }\n\n    /*\n    TODO: fix the terminology of \"formatter\" vs \"formatting func\"\n    */\n    /*\n    At the time of instantiation, this object does not know which cmd-formatting system it will use.\n    It receives this at the time of formatting, as a setting.\n    */\n    var CmdFormatter = /** @class */ (function () {\n        function CmdFormatter(cmdStr, separator) {\n            this.cmdStr = cmdStr;\n            this.separator = separator;\n        }\n        CmdFormatter.prototype.format = function (date, context) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, this.separator));\n        };\n        CmdFormatter.prototype.formatRange = function (start, end, context) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, this.separator));\n        };\n        return CmdFormatter;\n    }());\n\n    var FuncFormatter = /** @class */ (function () {\n        function FuncFormatter(func) {\n            this.func = func;\n        }\n        FuncFormatter.prototype.format = function (date, context) {\n            return this.func(createVerboseFormattingArg(date, null, context));\n        };\n        FuncFormatter.prototype.formatRange = function (start, end, context) {\n            return this.func(createVerboseFormattingArg(start, end, context));\n        };\n        return FuncFormatter;\n    }());\n\n    // Formatter Object Creation\n    function createFormatter(input, defaultSeparator) {\n        if (typeof input === 'object' && input) { // non-null object\n            if (typeof defaultSeparator === 'string') {\n                input = __assign({ separator: defaultSeparator }, input);\n            }\n            return new NativeFormatter(input);\n        }\n        else if (typeof input === 'string') {\n            return new CmdFormatter(input, defaultSeparator);\n        }\n        else if (typeof input === 'function') {\n            return new FuncFormatter(input);\n        }\n    }\n    // String Utils\n    // timeZoneOffset is in minutes\n    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n        if (stripZeroTime === void 0) { stripZeroTime = false; }\n        var s = marker.toISOString();\n        s = s.replace('.000', '');\n        if (stripZeroTime) {\n            s = s.replace('T00:00:00Z', '');\n        }\n        if (s.length > 10) { // time part wasn't stripped, can add timezone info\n            if (timeZoneOffset == null) {\n                s = s.replace('Z', '');\n            }\n            else if (timeZoneOffset !== 0) {\n                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n            }\n            // otherwise, its UTC-0 and we want to keep the Z\n        }\n        return s;\n    }\n    function formatIsoTimeString(marker) {\n        return padStart(marker.getUTCHours(), 2) + ':' +\n            padStart(marker.getUTCMinutes(), 2) + ':' +\n            padStart(marker.getUTCSeconds(), 2);\n    }\n    function formatTimeZoneOffset(minutes, doIso) {\n        if (doIso === void 0) { doIso = false; }\n        var sign = minutes < 0 ? '-' : '+';\n        var abs = Math.abs(minutes);\n        var hours = Math.floor(abs / 60);\n        var mins = Math.round(abs % 60);\n        if (doIso) {\n            return sign + padStart(hours, 2) + ':' + padStart(mins, 2);\n        }\n        else {\n            return 'GMT' + sign + hours + (mins ? ':' + padStart(mins, 2) : '');\n        }\n    }\n    // Arg Utils\n    function createVerboseFormattingArg(start, end, context, separator) {\n        var startInfo = expandZonedMarker(start, context.calendarSystem);\n        var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n        return {\n            date: startInfo,\n            start: startInfo,\n            end: endInfo,\n            timeZone: context.timeZone,\n            localeCodes: context.locale.codes,\n            separator: separator\n        };\n    }\n    function expandZonedMarker(dateInfo, calendarSystem) {\n        var a = calendarSystem.markerToArray(dateInfo.marker);\n        return {\n            marker: dateInfo.marker,\n            timeZoneOffset: dateInfo.timeZoneOffset,\n            array: a,\n            year: a[0],\n            month: a[1],\n            day: a[2],\n            hour: a[3],\n            minute: a[4],\n            second: a[5],\n            millisecond: a[6]\n        };\n    }\n\n    var EventSourceApi = /** @class */ (function () {\n        function EventSourceApi(calendar, internalEventSource) {\n            this.calendar = calendar;\n            this.internalEventSource = internalEventSource;\n        }\n        EventSourceApi.prototype.remove = function () {\n            this.calendar.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: this.internalEventSource.sourceId\n            });\n        };\n        EventSourceApi.prototype.refetch = function () {\n            this.calendar.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                sourceIds: [this.internalEventSource.sourceId]\n            });\n        };\n        Object.defineProperty(EventSourceApi.prototype, \"id\", {\n            get: function () {\n                return this.internalEventSource.publicId;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventSourceApi.prototype, \"url\", {\n            // only relevant to json-feed event sources\n            get: function () {\n                return this.internalEventSource.meta.url;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return EventSourceApi;\n    }());\n\n    var EventApi = /** @class */ (function () {\n        function EventApi(calendar, def, instance) {\n            this._calendar = calendar;\n            this._def = def;\n            this._instance = instance || null;\n        }\n        /*\n        TODO: make event struct more responsible for this\n        */\n        EventApi.prototype.setProp = function (name, val) {\n            var _a, _b;\n            if (name in DATE_PROPS) ;\n            else if (name in NON_DATE_PROPS) {\n                if (typeof NON_DATE_PROPS[name] === 'function') {\n                    val = NON_DATE_PROPS[name](val);\n                }\n                this.mutate({\n                    standardProps: (_a = {}, _a[name] = val, _a)\n                });\n            }\n            else if (name in UNSCOPED_EVENT_UI_PROPS) {\n                var ui = void 0;\n                if (typeof UNSCOPED_EVENT_UI_PROPS[name] === 'function') {\n                    val = UNSCOPED_EVENT_UI_PROPS[name](val);\n                }\n                if (name === 'color') {\n                    ui = { backgroundColor: val, borderColor: val };\n                }\n                else if (name === 'editable') {\n                    ui = { startEditable: val, durationEditable: val };\n                }\n                else {\n                    ui = (_b = {}, _b[name] = val, _b);\n                }\n                this.mutate({\n                    standardProps: { ui: ui }\n                });\n            }\n        };\n        EventApi.prototype.setExtendedProp = function (name, val) {\n            var _a;\n            this.mutate({\n                extendedProps: (_a = {}, _a[name] = val, _a)\n            });\n        };\n        EventApi.prototype.setStart = function (startInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._calendar.dateEnv;\n            var start = dateEnv.createMarker(startInput);\n            if (start && this._instance) { // TODO: warning if parsed bad\n                var instanceRange = this._instance.range;\n                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n                var endDelta = null;\n                if (options.maintainDuration) {\n                    var origDuration = diffDates(instanceRange.start, instanceRange.end, dateEnv, options.granularity);\n                    var newDuration = diffDates(start, instanceRange.end, dateEnv, options.granularity);\n                    endDelta = subtractDurations(origDuration, newDuration);\n                }\n                this.mutate({ startDelta: startDelta, endDelta: endDelta });\n            }\n        };\n        EventApi.prototype.setEnd = function (endInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._calendar.dateEnv;\n            var end;\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return; // TODO: warning if parsed bad\n                }\n            }\n            if (this._instance) {\n                if (end) {\n                    var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                    this.mutate({ endDelta: endDelta });\n                }\n                else {\n                    this.mutate({ standardProps: { hasEnd: false } });\n                }\n            }\n        };\n        EventApi.prototype.setDates = function (startInput, endInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._calendar.dateEnv;\n            var standardProps = { allDay: options.allDay };\n            var start = dateEnv.createMarker(startInput);\n            var end;\n            if (!start) {\n                return; // TODO: warning if parsed bad\n            }\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) { // TODO: warning if parsed bad\n                    return;\n                }\n            }\n            if (this._instance) {\n                var instanceRange = this._instance.range;\n                // when computing the diff for an event being converted to all-day,\n                // compute diff off of the all-day values the way event-mutation does.\n                if (options.allDay === true) {\n                    instanceRange = computeAlignedDayRange(instanceRange);\n                }\n                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n                if (end) {\n                    var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                    this.mutate({ startDelta: startDelta, endDelta: endDelta, standardProps: standardProps });\n                }\n                else {\n                    standardProps.hasEnd = false;\n                    this.mutate({ startDelta: startDelta, standardProps: standardProps });\n                }\n            }\n        };\n        EventApi.prototype.moveStart = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ startDelta: delta });\n            }\n        };\n        EventApi.prototype.moveEnd = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ endDelta: delta });\n            }\n        };\n        EventApi.prototype.moveDates = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ startDelta: delta, endDelta: delta });\n            }\n        };\n        EventApi.prototype.setAllDay = function (allDay, options) {\n            if (options === void 0) { options = {}; }\n            var standardProps = { allDay: allDay };\n            var maintainDuration = options.maintainDuration;\n            if (maintainDuration == null) {\n                maintainDuration = this._calendar.opt('allDayMaintainDuration');\n            }\n            if (this._def.allDay !== allDay) {\n                standardProps.hasEnd = maintainDuration;\n            }\n            this.mutate({ standardProps: standardProps });\n        };\n        EventApi.prototype.formatRange = function (formatInput) {\n            var dateEnv = this._calendar.dateEnv;\n            var instance = this._instance;\n            var formatter = createFormatter(formatInput, this._calendar.opt('defaultRangeSeparator'));\n            if (this._def.hasEnd) {\n                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                    forcedStartTzo: instance.forcedStartTzo,\n                    forcedEndTzo: instance.forcedEndTzo\n                });\n            }\n            else {\n                return dateEnv.format(instance.range.start, formatter, {\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n        };\n        EventApi.prototype.mutate = function (mutation) {\n            var def = this._def;\n            var instance = this._instance;\n            if (instance) {\n                this._calendar.dispatch({\n                    type: 'MUTATE_EVENTS',\n                    instanceId: instance.instanceId,\n                    mutation: mutation,\n                    fromApi: true\n                });\n                var eventStore = this._calendar.state.eventStore;\n                this._def = eventStore.defs[def.defId];\n                this._instance = eventStore.instances[instance.instanceId];\n            }\n        };\n        EventApi.prototype.remove = function () {\n            this._calendar.dispatch({\n                type: 'REMOVE_EVENT_DEF',\n                defId: this._def.defId\n            });\n        };\n        Object.defineProperty(EventApi.prototype, \"source\", {\n            get: function () {\n                var sourceId = this._def.sourceId;\n                if (sourceId) {\n                    return new EventSourceApi(this._calendar, this._calendar.state.eventSources[sourceId]);\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"start\", {\n            get: function () {\n                return this._instance ?\n                    this._calendar.dateEnv.toDate(this._instance.range.start) :\n                    null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"end\", {\n            get: function () {\n                return (this._instance && this._def.hasEnd) ?\n                    this._calendar.dateEnv.toDate(this._instance.range.end) :\n                    null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"id\", {\n            // computable props that all access the def\n            // TODO: find a TypeScript-compatible way to do this at scale\n            get: function () { return this._def.publicId; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"groupId\", {\n            get: function () { return this._def.groupId; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"allDay\", {\n            get: function () { return this._def.allDay; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"title\", {\n            get: function () { return this._def.title; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"url\", {\n            get: function () { return this._def.url; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"rendering\", {\n            get: function () { return this._def.rendering; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"startEditable\", {\n            get: function () { return this._def.ui.startEditable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n            get: function () { return this._def.ui.durationEditable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"constraint\", {\n            get: function () { return this._def.ui.constraints[0] || null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"overlap\", {\n            get: function () { return this._def.ui.overlap; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"allow\", {\n            get: function () { return this._def.ui.allows[0] || null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n            get: function () { return this._def.ui.backgroundColor; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"borderColor\", {\n            get: function () { return this._def.ui.borderColor; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"textColor\", {\n            get: function () { return this._def.ui.textColor; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"classNames\", {\n            // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n            get: function () { return this._def.ui.classNames; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n            get: function () { return this._def.extendedProps; },\n            enumerable: true,\n            configurable: true\n        });\n        return EventApi;\n    }());\n\n    /*\n    Specifying nextDayThreshold signals that all-day ranges should be sliced.\n    */\n    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n        var inverseBgByGroupId = {};\n        var inverseBgByDefId = {};\n        var defByGroupId = {};\n        var bgRanges = [];\n        var fgRanges = [];\n        var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n        for (var defId in eventStore.defs) {\n            var def = eventStore.defs[defId];\n            if (def.rendering === 'inverse-background') {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId] = [];\n                    if (!defByGroupId[def.groupId]) {\n                        defByGroupId[def.groupId] = def;\n                    }\n                }\n                else {\n                    inverseBgByDefId[defId] = [];\n                }\n            }\n        }\n        for (var instanceId in eventStore.instances) {\n            var instance = eventStore.instances[instanceId];\n            var def = eventStore.defs[instance.defId];\n            var ui = eventUis[def.defId];\n            var origRange = instance.range;\n            var normalRange = (!def.allDay && nextDayThreshold) ?\n                computeVisibleDayRange(origRange, nextDayThreshold) :\n                origRange;\n            var slicedRange = intersectRanges(normalRange, framingRange);\n            if (slicedRange) {\n                if (def.rendering === 'inverse-background') {\n                    if (def.groupId) {\n                        inverseBgByGroupId[def.groupId].push(slicedRange);\n                    }\n                    else {\n                        inverseBgByDefId[instance.defId].push(slicedRange);\n                    }\n                }\n                else {\n                    (def.rendering === 'background' ? bgRanges : fgRanges).push({\n                        def: def,\n                        ui: ui,\n                        instance: instance,\n                        range: slicedRange,\n                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                    });\n                }\n            }\n        }\n        for (var groupId in inverseBgByGroupId) { // BY GROUP\n            var ranges = inverseBgByGroupId[groupId];\n            var invertedRanges = invertRanges(ranges, framingRange);\n            for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n                var invertedRange = invertedRanges_1[_i];\n                var def = defByGroupId[groupId];\n                var ui = eventUis[def.defId];\n                bgRanges.push({\n                    def: def,\n                    ui: ui,\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        for (var defId in inverseBgByDefId) {\n            var ranges = inverseBgByDefId[defId];\n            var invertedRanges = invertRanges(ranges, framingRange);\n            for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n                var invertedRange = invertedRanges_2[_a];\n                bgRanges.push({\n                    def: eventStore.defs[defId],\n                    ui: eventUis[defId],\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        return { bg: bgRanges, fg: fgRanges };\n    }\n    function hasBgRendering(def) {\n        return def.rendering === 'background' || def.rendering === 'inverse-background';\n    }\n    function filterSegsViaEls(view, segs, isMirror) {\n        if (view.hasPublicHandlers('eventRender')) {\n            segs = segs.filter(function (seg) {\n                var custom = view.publiclyTrigger('eventRender', [\n                    {\n                        event: new EventApi(view.calendar, seg.eventRange.def, seg.eventRange.instance),\n                        isMirror: isMirror,\n                        isStart: seg.isStart,\n                        isEnd: seg.isEnd,\n                        // TODO: include seg.range once all components consistently generate it\n                        el: seg.el,\n                        view: view\n                    }\n                ]);\n                if (custom === false) { // means don't render at all\n                    return false;\n                }\n                else if (custom && custom !== true) {\n                    seg.el = custom;\n                }\n                return true;\n            });\n        }\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n            var seg = segs_1[_i];\n            setElSeg(seg.el, seg);\n        }\n        return segs;\n    }\n    function setElSeg(el, seg) {\n        el.fcSeg = seg;\n    }\n    function getElSeg(el) {\n        return el.fcSeg || null;\n    }\n    // event ui computation\n    function compileEventUis(eventDefs, eventUiBases) {\n        return mapHash(eventDefs, function (eventDef) {\n            return compileEventUi(eventDef, eventUiBases);\n        });\n    }\n    function compileEventUi(eventDef, eventUiBases) {\n        var uis = [];\n        if (eventUiBases['']) {\n            uis.push(eventUiBases['']);\n        }\n        if (eventUiBases[eventDef.defId]) {\n            uis.push(eventUiBases[eventDef.defId]);\n        }\n        uis.push(eventDef.ui);\n        return combineEventUis(uis);\n    }\n\n    // applies the mutation to ALL defs/instances within the event store\n    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, calendar) {\n        var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n        var dest = createEmptyEventStore();\n        for (var defId in eventStore.defs) {\n            var def = eventStore.defs[defId];\n            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, calendar.pluginSystem.hooks.eventDefMutationAppliers, calendar);\n        }\n        for (var instanceId in eventStore.instances) {\n            var instance = eventStore.instances[instanceId];\n            var def = dest.defs[instance.defId]; // important to grab the newly modified def\n            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, calendar);\n        }\n        return dest;\n    }\n    function applyMutationToEventDef(eventDef, eventConfig, mutation, appliers, calendar) {\n        var standardProps = mutation.standardProps || {};\n        // if hasEnd has not been specified, guess a good value based on deltas.\n        // if duration will change, there's no way the default duration will persist,\n        // and thus, we need to mark the event as having a real end\n        if (standardProps.hasEnd == null &&\n            eventConfig.durationEditable &&\n            willDeltasAffectDuration(eventConfig.startEditable ? mutation.startDelta : null, mutation.endDelta || null)) {\n            standardProps.hasEnd = true; // TODO: is this mutation okay?\n        }\n        var copy = __assign({}, eventDef, standardProps, { ui: __assign({}, eventDef.ui, standardProps.ui) });\n        if (mutation.extendedProps) {\n            copy.extendedProps = __assign({}, copy.extendedProps, mutation.extendedProps);\n        }\n        for (var _i = 0, appliers_1 = appliers; _i < appliers_1.length; _i++) {\n            var applier = appliers_1[_i];\n            applier(copy, mutation, calendar);\n        }\n        if (!copy.hasEnd && calendar.opt('forceEventDuration')) {\n            copy.hasEnd = true;\n        }\n        return copy;\n    }\n    function willDeltasAffectDuration(startDelta, endDelta) {\n        if (startDelta && !asRoughMs(startDelta)) {\n            startDelta = null;\n        }\n        if (endDelta && !asRoughMs(endDelta)) {\n            endDelta = null;\n        }\n        if (!startDelta && !endDelta) {\n            return false;\n        }\n        if (Boolean(startDelta) !== Boolean(endDelta)) {\n            return true;\n        }\n        return !durationsEqual(startDelta, endDelta);\n    }\n    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\n    eventConfig, mutation, calendar) {\n        var dateEnv = calendar.dateEnv;\n        var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n        var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n        var copy = __assign({}, eventInstance);\n        if (forceAllDay) {\n            copy.range = computeAlignedDayRange(copy.range);\n        }\n        if (mutation.startDelta && eventConfig.startEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.startDelta),\n                end: copy.range.end\n            };\n        }\n        if (clearEnd) {\n            copy.range = {\n                start: copy.range.start,\n                end: calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start)\n            };\n        }\n        else if (mutation.endDelta &&\n            (eventConfig.durationEditable ||\n                !willDeltasAffectDuration(// TODO: nonDRY logic above\n                eventConfig.startEditable ? mutation.startDelta : null, mutation.endDelta))) {\n            copy.range = {\n                start: copy.range.start,\n                end: dateEnv.add(copy.range.end, mutation.endDelta)\n            };\n        }\n        // in case event was all-day but the supplied deltas were not\n        // better util for this?\n        if (eventDef.allDay) {\n            copy.range = {\n                start: startOfDay(copy.range.start),\n                end: startOfDay(copy.range.end)\n            };\n        }\n        // handle invalid durations\n        if (copy.range.end < copy.range.start) {\n            copy.range.end = calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start);\n        }\n        return copy;\n    }\n\n    function reduceEventStore (eventStore, action, eventSources, dateProfile, calendar) {\n        switch (action.type) {\n            case 'RECEIVE_EVENTS': // raw\n                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, calendar);\n            case 'ADD_EVENTS': // already parsed, but not expanded\n                return addEvent(eventStore, action.eventStore, // new ones\n                dateProfile ? dateProfile.activeRange : null, calendar);\n            case 'MERGE_EVENTS': // already parsed and expanded\n                return mergeEventStores(eventStore, action.eventStore);\n            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n            case 'NEXT':\n            case 'SET_DATE':\n            case 'SET_VIEW_TYPE':\n                if (dateProfile) {\n                    return expandRecurring(eventStore, dateProfile.activeRange, calendar);\n                }\n                else {\n                    return eventStore;\n                }\n            case 'CHANGE_TIMEZONE':\n                return rezoneDates(eventStore, action.oldDateEnv, calendar.dateEnv);\n            case 'MUTATE_EVENTS':\n                return applyMutationToRelated(eventStore, action.instanceId, action.mutation, action.fromApi, calendar);\n            case 'REMOVE_EVENT_INSTANCES':\n                return excludeInstances(eventStore, action.instances);\n            case 'REMOVE_EVENT_DEF':\n                return filterEventStoreDefs(eventStore, function (eventDef) {\n                    return eventDef.defId !== action.defId;\n                });\n            case 'REMOVE_EVENT_SOURCE':\n                return excludeEventsBySourceId(eventStore, action.sourceId);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return filterEventStoreDefs(eventStore, function (eventDef) {\n                    return !eventDef.sourceId; // only keep events with no source id\n                });\n            case 'REMOVE_ALL_EVENTS':\n                return createEmptyEventStore();\n            case 'RESET_EVENTS':\n                return {\n                    defs: eventStore.defs,\n                    instances: eventStore.instances\n                };\n            default:\n                return eventStore;\n        }\n    }\n    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, calendar) {\n        if (eventSource && // not already removed\n            fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n        ) {\n            var subset = parseEvents(transformRawEvents(rawEvents, eventSource, calendar), eventSource.sourceId, calendar);\n            if (fetchRange) {\n                subset = expandRecurring(subset, fetchRange, calendar);\n            }\n            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n        }\n        return eventStore;\n    }\n    function addEvent(eventStore, subset, expandRange, calendar) {\n        if (expandRange) {\n            subset = expandRecurring(subset, expandRange, calendar);\n        }\n        return mergeEventStores(eventStore, subset);\n    }\n    function rezoneDates(eventStore, oldDateEnv, newDateEnv) {\n        var defs = eventStore.defs;\n        var instances = mapHash(eventStore.instances, function (instance) {\n            var def = defs[instance.defId];\n            if (def.allDay || def.recurringDef) {\n                return instance; // isn't dependent on timezone\n            }\n            else {\n                return __assign({}, instance, { range: {\n                        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n                    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });\n            }\n        });\n        return { defs: defs, instances: instances };\n    }\n    function applyMutationToRelated(eventStore, instanceId, mutation, fromApi, calendar) {\n        var relevant = getRelevantEvents(eventStore, instanceId);\n        var eventConfigBase = fromApi ?\n            { '': {\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: '',\n                    borderColor: '',\n                    textColor: '',\n                    classNames: []\n                } } :\n            calendar.eventUiBases;\n        relevant = applyMutationToEventStore(relevant, eventConfigBase, mutation, calendar);\n        return mergeEventStores(eventStore, relevant);\n    }\n    function excludeEventsBySourceId(eventStore, sourceId) {\n        return filterEventStoreDefs(eventStore, function (eventDef) {\n            return eventDef.sourceId !== sourceId;\n        });\n    }\n    // QUESTION: why not just return instances? do a general object-property-exclusion util\n    function excludeInstances(eventStore, removals) {\n        return {\n            defs: eventStore.defs,\n            instances: filterHash(eventStore.instances, function (instance) {\n                return !removals[instance.instanceId];\n            })\n        };\n    }\n\n    // high-level segmenting-aware tester functions\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionValid(interaction, calendar) {\n        return isNewPropsValid({ eventDrag: interaction }, calendar); // HACK: the eventDrag props is used for ALL interactions\n    }\n    function isDateSelectionValid(dateSelection, calendar) {\n        return isNewPropsValid({ dateSelection: dateSelection }, calendar);\n    }\n    function isNewPropsValid(newProps, calendar) {\n        var view = calendar.view;\n        var props = __assign({ businessHours: view ? view.props.businessHours : createEmptyEventStore(), dateSelection: '', eventStore: calendar.state.eventStore, eventUiBases: calendar.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);\n        return (calendar.pluginSystem.hooks.isPropsValid || isPropsValid)(props, calendar);\n    }\n    function isPropsValid(state, calendar, dateSpanMeta, filterConfig) {\n        if (dateSpanMeta === void 0) { dateSpanMeta = {}; }\n        if (state.eventDrag && !isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        if (state.dateSelection && !isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        return true;\n    }\n    // Moving Event Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig) {\n        var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n        var subjectEventStore = interaction.mutatedEvents;\n        var subjectDefs = subjectEventStore.defs;\n        var subjectInstances = subjectEventStore.instances;\n        var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?\n            state.eventUiBases :\n            { '': calendar.selectionConfig } // if not a real event, validate as a selection\n        );\n        if (filterConfig) {\n            subjectConfigs = mapHash(subjectConfigs, filterConfig);\n        }\n        var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances); // exclude the subject events. TODO: exclude defs too?\n        var otherDefs = otherEventStore.defs;\n        var otherInstances = otherEventStore.instances;\n        var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n        for (var subjectInstanceId in subjectInstances) {\n            var subjectInstance = subjectInstances[subjectInstanceId];\n            var subjectRange = subjectInstance.range;\n            var subjectConfig = subjectConfigs[subjectInstance.defId];\n            var subjectDef = subjectDefs[subjectInstance.defId];\n            // constraint\n            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, calendar)) {\n                return false;\n            }\n            // overlap\n            var overlapFunc = calendar.opt('eventOverlap');\n            if (typeof overlapFunc !== 'function') {\n                overlapFunc = null;\n            }\n            for (var otherInstanceId in otherInstances) {\n                var otherInstance = otherInstances[otherInstanceId];\n                // intersect! evaluate\n                if (rangesIntersect(subjectRange, otherInstance.range)) {\n                    var otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                    // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                    if (otherOverlap === false && interaction.isEvent) {\n                        return false;\n                    }\n                    if (subjectConfig.overlap === false) {\n                        return false;\n                    }\n                    if (overlapFunc && !overlapFunc(new EventApi(calendar, otherDefs[otherInstance.defId], otherInstance), // still event\n                    new EventApi(calendar, subjectDef, subjectInstance) // moving event\n                    )) {\n                        return false;\n                    }\n                }\n            }\n            // allow (a function)\n            for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n                var subjectAllow = _a[_i];\n                var subjectDateSpan = __assign({}, dateSpanMeta, { range: subjectInstance.range, allDay: subjectDef.allDay });\n                var origDef = state.eventStore.defs[subjectDef.defId];\n                var origInstance = state.eventStore.instances[subjectInstanceId];\n                var eventApi = void 0;\n                if (origDef) { // was previously in the calendar\n                    eventApi = new EventApi(calendar, origDef, origInstance);\n                }\n                else { // was an external event\n                    eventApi = new EventApi(calendar, subjectDef); // no instance, because had no dates\n                }\n                if (!subjectAllow(calendar.buildDateSpanApi(subjectDateSpan), eventApi)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // Date Selection Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig) {\n        var relevantEventStore = state.eventStore;\n        var relevantDefs = relevantEventStore.defs;\n        var relevantInstances = relevantEventStore.instances;\n        var selection = state.dateSelection;\n        var selectionRange = selection.range;\n        var selectionConfig = calendar.selectionConfig;\n        if (filterConfig) {\n            selectionConfig = filterConfig(selectionConfig);\n        }\n        // constraint\n        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, calendar)) {\n            return false;\n        }\n        // overlap\n        var overlapFunc = calendar.opt('selectOverlap');\n        if (typeof overlapFunc !== 'function') {\n            overlapFunc = null;\n        }\n        for (var relevantInstanceId in relevantInstances) {\n            var relevantInstance = relevantInstances[relevantInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(selectionRange, relevantInstance.range)) {\n                if (selectionConfig.overlap === false) {\n                    return false;\n                }\n                if (overlapFunc && !overlapFunc(new EventApi(calendar, relevantDefs[relevantInstance.defId], relevantInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n            var selectionAllow = _a[_i];\n            var fullDateSpan = __assign({}, dateSpanMeta, selection);\n            if (!selectionAllow(calendar.buildDateSpanApi(fullDateSpan), null)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Constraint Utils\n    // ------------------------------------------------------------------------------------------------------------------------\n    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, calendar) {\n        for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n            var constraint = constraints_1[_i];\n            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, calendar), subjectRange)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\n    otherEventStore, // for if constraint is an even group ID\n    businessHoursUnexpanded, // for if constraint is 'businessHours'\n    calendar // for expanding businesshours\n    ) {\n        if (constraint === 'businessHours') {\n            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, calendar));\n        }\n        else if (typeof constraint === 'string') { // an group ID\n            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n                return eventDef.groupId === constraint;\n            }));\n        }\n        else if (typeof constraint === 'object' && constraint) { // non-null object\n            return eventStoreToRanges(expandRecurring(constraint, subjectRange, calendar));\n        }\n        return []; // if it's false\n    }\n    // TODO: move to event-store file?\n    function eventStoreToRanges(eventStore) {\n        var instances = eventStore.instances;\n        var ranges = [];\n        for (var instanceId in instances) {\n            ranges.push(instances[instanceId].range);\n        }\n        return ranges;\n    }\n    // TODO: move to geom file?\n    function anyRangesContainRange(outerRanges, innerRange) {\n        for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n            var outerRange = outerRanges_1[_i];\n            if (rangeContainsRange(outerRange, innerRange)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Parsing\n    // ------------------------------------------------------------------------------------------------------------------------\n    function normalizeConstraint(input, calendar) {\n        if (Array.isArray(input)) {\n            return parseEvents(input, '', calendar, true); // allowOpenRange=true\n        }\n        else if (typeof input === 'object' && input) { // non-null object\n            return parseEvents([input], '', calendar, true); // allowOpenRange=true\n        }\n        else if (input != null) {\n            return String(input);\n        }\n        else {\n            return null;\n        }\n    }\n\n    function htmlEscape(s) {\n        return (s + '').replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/'/g, '&#039;')\n            .replace(/\"/g, '&quot;')\n            .replace(/\\n/g, '<br />');\n    }\n    // Given a hash of CSS properties, returns a string of CSS.\n    // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\n    function cssToStr(cssProps) {\n        var statements = [];\n        for (var name_1 in cssProps) {\n            var val = cssProps[name_1];\n            if (val != null && val !== '') {\n                statements.push(name_1 + ':' + val);\n            }\n        }\n        return statements.join(';');\n    }\n    // Given an object hash of HTML attribute names to values,\n    // generates a string that can be injected between < > in HTML\n    function attrsToStr(attrs) {\n        var parts = [];\n        for (var name_2 in attrs) {\n            var val = attrs[name_2];\n            if (val != null) {\n                parts.push(name_2 + '=\"' + htmlEscape(val) + '\"');\n            }\n        }\n        return parts.join(' ');\n    }\n    function parseClassName(raw) {\n        if (Array.isArray(raw)) {\n            return raw;\n        }\n        else if (typeof raw === 'string') {\n            return raw.split(/\\s+/);\n        }\n        else {\n            return [];\n        }\n    }\n\n    var UNSCOPED_EVENT_UI_PROPS = {\n        editable: Boolean,\n        startEditable: Boolean,\n        durationEditable: Boolean,\n        constraint: null,\n        overlap: null,\n        allow: null,\n        className: parseClassName,\n        classNames: parseClassName,\n        color: String,\n        backgroundColor: String,\n        borderColor: String,\n        textColor: String\n    };\n    function processUnscopedUiProps(rawProps, calendar, leftovers) {\n        var props = refineProps(rawProps, UNSCOPED_EVENT_UI_PROPS, {}, leftovers);\n        var constraint = normalizeConstraint(props.constraint, calendar);\n        return {\n            startEditable: props.startEditable != null ? props.startEditable : props.editable,\n            durationEditable: props.durationEditable != null ? props.durationEditable : props.editable,\n            constraints: constraint != null ? [constraint] : [],\n            overlap: props.overlap,\n            allows: props.allow != null ? [props.allow] : [],\n            backgroundColor: props.backgroundColor || props.color,\n            borderColor: props.borderColor || props.color,\n            textColor: props.textColor,\n            classNames: props.classNames.concat(props.className)\n        };\n    }\n    function processScopedUiProps(prefix, rawScoped, calendar, leftovers) {\n        var rawUnscoped = {};\n        var wasFound = {};\n        for (var key in UNSCOPED_EVENT_UI_PROPS) {\n            var scopedKey = prefix + capitaliseFirstLetter(key);\n            rawUnscoped[key] = rawScoped[scopedKey];\n            wasFound[scopedKey] = true;\n        }\n        if (prefix === 'event') {\n            rawUnscoped.editable = rawScoped.editable; // special case. there is no 'eventEditable', just 'editable'\n        }\n        if (leftovers) {\n            for (var key in rawScoped) {\n                if (!wasFound[key]) {\n                    leftovers[key] = rawScoped[key];\n                }\n            }\n        }\n        return processUnscopedUiProps(rawUnscoped, calendar);\n    }\n    var EMPTY_EVENT_UI = {\n        startEditable: null,\n        durationEditable: null,\n        constraints: [],\n        overlap: null,\n        allows: [],\n        backgroundColor: '',\n        borderColor: '',\n        textColor: '',\n        classNames: []\n    };\n    // prevent against problems with <2 args!\n    function combineEventUis(uis) {\n        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n    }\n    function combineTwoEventUis(item0, item1) {\n        return {\n            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n            constraints: item0.constraints.concat(item1.constraints),\n            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n            allows: item0.allows.concat(item1.allows),\n            backgroundColor: item1.backgroundColor || item0.backgroundColor,\n            borderColor: item1.borderColor || item0.borderColor,\n            textColor: item1.textColor || item0.textColor,\n            classNames: item0.classNames.concat(item1.classNames)\n        };\n    }\n\n    var NON_DATE_PROPS = {\n        id: String,\n        groupId: String,\n        title: String,\n        url: String,\n        rendering: String,\n        extendedProps: null\n    };\n    var DATE_PROPS = {\n        start: null,\n        date: null,\n        end: null,\n        allDay: null\n    };\n    var uid = 0;\n    function parseEvent(raw, sourceId, calendar, allowOpenRange) {\n        var allDayDefault = computeIsAllDayDefault(sourceId, calendar);\n        var leftovers0 = {};\n        var recurringRes = parseRecurring(raw, // raw, but with single-event stuff stripped out\n        allDayDefault, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes, leftovers0 // will populate with non-recurring props\n        );\n        if (recurringRes) {\n            var def = parseEventDef(leftovers0, sourceId, recurringRes.allDay, Boolean(recurringRes.duration), calendar);\n            def.recurringDef = {\n                typeId: recurringRes.typeId,\n                typeData: recurringRes.typeData,\n                duration: recurringRes.duration\n            };\n            return { def: def, instance: null };\n        }\n        else {\n            var leftovers1 = {};\n            var singleRes = parseSingle(raw, allDayDefault, calendar, leftovers1, allowOpenRange);\n            if (singleRes) {\n                var def = parseEventDef(leftovers1, sourceId, singleRes.allDay, singleRes.hasEnd, calendar);\n                var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n                return { def: def, instance: instance };\n            }\n        }\n        return null;\n    }\n    /*\n    Will NOT populate extendedProps with the leftover properties.\n    Will NOT populate date-related props.\n    The EventNonDateInput has been normalized (id => publicId, etc).\n    */\n    function parseEventDef(raw, sourceId, allDay, hasEnd, calendar) {\n        var leftovers = {};\n        var def = pluckNonDateProps(raw, calendar, leftovers);\n        def.defId = String(uid++);\n        def.sourceId = sourceId;\n        def.allDay = allDay;\n        def.hasEnd = hasEnd;\n        for (var _i = 0, _a = calendar.pluginSystem.hooks.eventDefParsers; _i < _a.length; _i++) {\n            var eventDefParser = _a[_i];\n            var newLeftovers = {};\n            eventDefParser(def, leftovers, newLeftovers);\n            leftovers = newLeftovers;\n        }\n        def.extendedProps = __assign(leftovers, def.extendedProps || {});\n        // help out EventApi from having user modify props\n        Object.freeze(def.ui.classNames);\n        Object.freeze(def.extendedProps);\n        return def;\n    }\n    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n        return {\n            instanceId: String(uid++),\n            defId: defId,\n            range: range,\n            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n        };\n    }\n    function parseSingle(raw, allDayDefault, calendar, leftovers, allowOpenRange) {\n        var props = pluckDateProps(raw, leftovers);\n        var allDay = props.allDay;\n        var startMeta;\n        var startMarker = null;\n        var hasEnd = false;\n        var endMeta;\n        var endMarker = null;\n        startMeta = calendar.dateEnv.createMarkerMeta(props.start);\n        if (startMeta) {\n            startMarker = startMeta.marker;\n        }\n        else if (!allowOpenRange) {\n            return null;\n        }\n        if (props.end != null) {\n            endMeta = calendar.dateEnv.createMarkerMeta(props.end);\n        }\n        if (allDay == null) {\n            if (allDayDefault != null) {\n                allDay = allDayDefault;\n            }\n            else {\n                // fall back to the date props LAST\n                allDay = (!startMeta || startMeta.isTimeUnspecified) &&\n                    (!endMeta || endMeta.isTimeUnspecified);\n            }\n        }\n        if (allDay && startMarker) {\n            startMarker = startOfDay(startMarker);\n        }\n        if (endMeta) {\n            endMarker = endMeta.marker;\n            if (allDay) {\n                endMarker = startOfDay(endMarker);\n            }\n            if (startMarker && endMarker <= startMarker) {\n                endMarker = null;\n            }\n        }\n        if (endMarker) {\n            hasEnd = true;\n        }\n        else if (!allowOpenRange) {\n            hasEnd = calendar.opt('forceEventDuration') || false;\n            endMarker = calendar.dateEnv.add(startMarker, allDay ?\n                calendar.defaultAllDayEventDuration :\n                calendar.defaultTimedEventDuration);\n        }\n        return {\n            allDay: allDay,\n            hasEnd: hasEnd,\n            range: { start: startMarker, end: endMarker },\n            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n            forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n        };\n    }\n    function pluckDateProps(raw, leftovers) {\n        var props = refineProps(raw, DATE_PROPS, {}, leftovers);\n        props.start = (props.start !== null) ? props.start : props.date;\n        delete props.date;\n        return props;\n    }\n    function pluckNonDateProps(raw, calendar, leftovers) {\n        var preLeftovers = {};\n        var props = refineProps(raw, NON_DATE_PROPS, {}, preLeftovers);\n        var ui = processUnscopedUiProps(preLeftovers, calendar, leftovers);\n        props.publicId = props.id;\n        delete props.id;\n        props.ui = ui;\n        return props;\n    }\n    function computeIsAllDayDefault(sourceId, calendar) {\n        var res = null;\n        if (sourceId) {\n            var source = calendar.state.eventSources[sourceId];\n            res = source.allDayDefault;\n        }\n        if (res == null) {\n            res = calendar.opt('allDayDefault');\n        }\n        return res;\n    }\n\n    var DEF_DEFAULTS = {\n        startTime: '09:00',\n        endTime: '17:00',\n        daysOfWeek: [1, 2, 3, 4, 5],\n        rendering: 'inverse-background',\n        classNames: 'fc-nonbusiness',\n        groupId: '_businessHours' // so multiple defs get grouped\n    };\n    /*\n    TODO: pass around as EventDefHash!!!\n    */\n    function parseBusinessHours(input, calendar) {\n        return parseEvents(refineInputs(input), '', calendar);\n    }\n    function refineInputs(input) {\n        var rawDefs;\n        if (input === true) {\n            rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n        }\n        else if (Array.isArray(input)) {\n            // if specifying an array, every sub-definition NEEDS a day-of-week\n            rawDefs = input.filter(function (rawDef) {\n                return rawDef.daysOfWeek;\n            });\n        }\n        else if (typeof input === 'object' && input) { // non-null object\n            rawDefs = [input];\n        }\n        else { // is probably false\n            rawDefs = [];\n        }\n        rawDefs = rawDefs.map(function (rawDef) {\n            return __assign({}, DEF_DEFAULTS, rawDef);\n        });\n        return rawDefs;\n    }\n\n    function memoizeRendering(renderFunc, unrenderFunc, dependencies) {\n        if (dependencies === void 0) { dependencies = []; }\n        var dependents = [];\n        var thisContext;\n        var prevArgs;\n        function unrender() {\n            if (prevArgs) {\n                for (var _i = 0, dependents_1 = dependents; _i < dependents_1.length; _i++) {\n                    var dependent = dependents_1[_i];\n                    dependent.unrender();\n                }\n                if (unrenderFunc) {\n                    unrenderFunc.apply(thisContext, prevArgs);\n                }\n                prevArgs = null;\n            }\n        }\n        function res() {\n            if (!prevArgs || !isArraysEqual(prevArgs, arguments)) {\n                unrender();\n                thisContext = this;\n                prevArgs = arguments;\n                renderFunc.apply(this, arguments);\n            }\n        }\n        res.dependents = dependents;\n        res.unrender = unrender;\n        for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {\n            var dependency = dependencies_1[_i];\n            dependency.dependents.push(res);\n        }\n        return res;\n    }\n\n    function isValuesSimilar(val0, val1, depth) {\n        if (depth === void 0) { depth = 1; }\n        if (val0 === val1) {\n            return true;\n        }\n        else if (Array.isArray(val0) && Array.isArray(val1)) {\n            return isArraysSimilar(val0, val1, depth);\n        }\n        else if (typeof val0 === 'object' && val0 && typeof val1 === 'object' && val1) { // non-null objects\n            return isObjectsSimilar(val0, val1, depth);\n        }\n        else {\n            return false;\n        }\n    }\n    function isArraysSimilar(a0, a1, depth) {\n        if (depth === void 0) { depth = 1; }\n        if (a0 === a1) {\n            return true;\n        }\n        else if (depth > 0) {\n            if (a0.length !== a1.length) {\n                return false;\n            }\n            else {\n                for (var i = 0; i < a0.length; i++) {\n                    if (!isValuesSimilar(a0[i], a1[i], depth - 1)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    function isObjectsSimilar(obj0, obj1, depth) {\n        if (depth === void 0) { depth = 1; }\n        if (obj0 === obj1) {\n            return true;\n        }\n        else if (depth > 0) {\n            for (var prop in obj0) {\n                if (!(prop in obj1)) {\n                    return false;\n                }\n            }\n            for (var prop in obj1) {\n                if (!(prop in obj0)) {\n                    return false;\n                }\n                else {\n                    if (!isValuesSimilar(obj0[prop], obj1[prop], depth - 1)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    function computeChangedProps(obj0, obj1, depth) {\n        if (depth === void 0) { depth = 1; }\n        var res = {};\n        for (var prop in obj1) {\n            if (!(prop in obj0) ||\n                !isValuesSimilar(obj0[prop], obj1[prop], depth - 1)) {\n                res[prop] = obj1[prop];\n            }\n        }\n        return res;\n    }\n    function anyKeysRemoved(obj0, obj1) {\n        for (var prop in obj0) {\n            if (!(prop in obj1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n    var Splitter = /** @class */ (function () {\n        function Splitter() {\n            this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n            this.splitDateSelection = memoize(this._splitDateSpan);\n            this.splitEventStore = memoize(this._splitEventStore);\n            this.splitIndividualUi = memoize(this._splitIndividualUi);\n            this.splitEventDrag = memoize(this._splitInteraction);\n            this.splitEventResize = memoize(this._splitInteraction);\n            this.eventUiBuilders = {}; // TODO: typescript protection\n        }\n        Splitter.prototype.splitProps = function (props) {\n            var _this = this;\n            var keyInfos = this.getKeyInfo(props);\n            var defKeys = this.getKeysForEventDefs(props.eventStore);\n            var dateSelections = this.splitDateSelection(props.dateSelection);\n            var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n            var eventStores = this.splitEventStore(props.eventStore, defKeys);\n            var eventDrags = this.splitEventDrag(props.eventDrag);\n            var eventResizes = this.splitEventResize(props.eventResize);\n            var splitProps = {};\n            this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n                return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n            });\n            for (var key in keyInfos) {\n                var keyInfo = keyInfos[key];\n                var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n                var buildEventUi = this.eventUiBuilders[key];\n                splitProps[key] = {\n                    businessHours: keyInfo.businessHours || props.businessHours,\n                    dateSelection: dateSelections[key] || null,\n                    eventStore: eventStore,\n                    eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n                    eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n                    eventDrag: eventDrags[key] || null,\n                    eventResize: eventResizes[key] || null\n                };\n            }\n            return splitProps;\n        };\n        Splitter.prototype._splitDateSpan = function (dateSpan) {\n            var dateSpans = {};\n            if (dateSpan) {\n                var keys = this.getKeysForDateSpan(dateSpan);\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                    var key = keys_1[_i];\n                    dateSpans[key] = dateSpan;\n                }\n            }\n            return dateSpans;\n        };\n        Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n            var _this = this;\n            return mapHash(eventStore.defs, function (eventDef) {\n                return _this.getKeysForEventDef(eventDef);\n            });\n        };\n        Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n            var defs = eventStore.defs, instances = eventStore.instances;\n            var splitStores = {};\n            for (var defId in defs) {\n                for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    if (!splitStores[key]) {\n                        splitStores[key] = createEmptyEventStore();\n                    }\n                    splitStores[key].defs[defId] = defs[defId];\n                }\n            }\n            for (var instanceId in instances) {\n                var instance = instances[instanceId];\n                for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n                    var key = _c[_b];\n                    if (splitStores[key]) { // must have already been created\n                        splitStores[key].instances[instanceId] = instance;\n                    }\n                }\n            }\n            return splitStores;\n        };\n        Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n            var splitHashes = {};\n            for (var defId in eventUiBases) {\n                if (defId) { // not the '' key\n                    for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n                        var key = _a[_i];\n                        if (!splitHashes[key]) {\n                            splitHashes[key] = {};\n                        }\n                        splitHashes[key][defId] = eventUiBases[defId];\n                    }\n                }\n            }\n            return splitHashes;\n        };\n        Splitter.prototype._splitInteraction = function (interaction) {\n            var splitStates = {};\n            if (interaction) {\n                var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents) // can't use cached. might be events from other calendar\n                );\n                // can't rely on defKeys because event data is mutated\n                var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n                var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n                var populate = function (key) {\n                    if (!splitStates[key]) {\n                        splitStates[key] = {\n                            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n                            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n                            isEvent: interaction.isEvent,\n                            origSeg: interaction.origSeg\n                        };\n                    }\n                };\n                for (var key in affectedStores_1) {\n                    populate(key);\n                }\n                for (var key in mutatedStores_1) {\n                    populate(key);\n                }\n            }\n            return splitStates;\n        };\n        return Splitter;\n    }());\n    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n        var baseParts = [];\n        if (allUi) {\n            baseParts.push(allUi);\n        }\n        if (eventUiForKey) {\n            baseParts.push(eventUiForKey);\n        }\n        var stuff = {\n            '': combineEventUis(baseParts)\n        };\n        if (individualUi) {\n            __assign(stuff, individualUi);\n        }\n        return stuff;\n    }\n\n    // Generates HTML for an anchor to another view into the calendar.\n    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\n    // `gotoOptions` can either be a DateMarker, or an object with the form:\n    // { date, type, forceOff }\n    // `type` is a view-type like \"day\" or \"week\". default value is \"day\".\n    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\n    function buildGotoAnchorHtml(component, gotoOptions, attrs, innerHtml) {\n        var dateEnv = component.dateEnv;\n        var date;\n        var type;\n        var forceOff;\n        var finalOptions;\n        if (gotoOptions instanceof Date) {\n            date = gotoOptions; // a single date-like input\n        }\n        else {\n            date = gotoOptions.date;\n            type = gotoOptions.type;\n            forceOff = gotoOptions.forceOff;\n        }\n        finalOptions = {\n            date: dateEnv.formatIso(date, { omitTime: true }),\n            type: type || 'day'\n        };\n        if (typeof attrs === 'string') {\n            innerHtml = attrs;\n            attrs = null;\n        }\n        attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space\n        innerHtml = innerHtml || '';\n        if (!forceOff && component.opt('navLinks')) {\n            return '<a' + attrs +\n                ' data-goto=\"' + htmlEscape(JSON.stringify(finalOptions)) + '\">' +\n                innerHtml +\n                '</a>';\n        }\n        else {\n            return '<span' + attrs + '>' +\n                innerHtml +\n                '</span>';\n        }\n    }\n    function getAllDayHtml(component) {\n        return component.opt('allDayHtml') || htmlEscape(component.opt('allDayText'));\n    }\n    // Computes HTML classNames for a single-day element\n    function getDayClasses(date, dateProfile, context, noThemeHighlight) {\n        var calendar = context.calendar, view = context.view, theme = context.theme, dateEnv = context.dateEnv;\n        var classes = [];\n        var todayStart;\n        var todayEnd;\n        if (!rangeContainsMarker(dateProfile.activeRange, date)) {\n            classes.push('fc-disabled-day');\n        }\n        else {\n            classes.push('fc-' + DAY_IDS[date.getUTCDay()]);\n            if (view.opt('monthMode') &&\n                dateEnv.getMonth(date) !== dateEnv.getMonth(dateProfile.currentRange.start)) {\n                classes.push('fc-other-month');\n            }\n            todayStart = startOfDay(calendar.getNow());\n            todayEnd = addDays(todayStart, 1);\n            if (date < todayStart) {\n                classes.push('fc-past');\n            }\n            else if (date >= todayEnd) {\n                classes.push('fc-future');\n            }\n            else {\n                classes.push('fc-today');\n                if (noThemeHighlight !== true) {\n                    classes.push(theme.getClass('today'));\n                }\n            }\n        }\n        return classes;\n    }\n\n    // given a function that resolves a result asynchronously.\n    // the function can either call passed-in success and failure callbacks,\n    // or it can return a promise.\n    // if you need to pass additional params to func, bind them first.\n    function unpromisify(func, success, failure) {\n        // guard against success/failure callbacks being called more than once\n        // and guard against a promise AND callback being used together.\n        var isResolved = false;\n        var wrappedSuccess = function () {\n            if (!isResolved) {\n                isResolved = true;\n                success.apply(this, arguments);\n            }\n        };\n        var wrappedFailure = function () {\n            if (!isResolved) {\n                isResolved = true;\n                if (failure) {\n                    failure.apply(this, arguments);\n                }\n            }\n        };\n        var res = func(wrappedSuccess, wrappedFailure);\n        if (res && typeof res.then === 'function') {\n            res.then(wrappedSuccess, wrappedFailure);\n        }\n    }\n\n    var Mixin = /** @class */ (function () {\n        function Mixin() {\n        }\n        // mix into a CLASS\n        Mixin.mixInto = function (destClass) {\n            this.mixIntoObj(destClass.prototype);\n        };\n        // mix into ANY object\n        Mixin.mixIntoObj = function (destObj) {\n            var _this = this;\n            Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\n                if (!destObj[name]) { // if destination doesn't already define it\n                    destObj[name] = _this.prototype[name];\n                }\n            });\n        };\n        /*\n        will override existing methods\n        TODO: remove! not used anymore\n        */\n        Mixin.mixOver = function (destClass) {\n            var _this = this;\n            Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\n                destClass.prototype[name] = _this.prototype[name];\n            });\n        };\n        return Mixin;\n    }());\n\n    /*\n    USAGE:\n      import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'\n    in class:\n      on: EmitterInterface['on']\n      one: EmitterInterface['one']\n      off: EmitterInterface['off']\n      trigger: EmitterInterface['trigger']\n      triggerWith: EmitterInterface['triggerWith']\n      hasHandlers: EmitterInterface['hasHandlers']\n    after class:\n      EmitterMixin.mixInto(TheClass)\n    */\n    var EmitterMixin = /** @class */ (function (_super) {\n        __extends(EmitterMixin, _super);\n        function EmitterMixin() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        EmitterMixin.prototype.on = function (type, handler) {\n            addToHash(this._handlers || (this._handlers = {}), type, handler);\n            return this; // for chaining\n        };\n        // todo: add comments\n        EmitterMixin.prototype.one = function (type, handler) {\n            addToHash(this._oneHandlers || (this._oneHandlers = {}), type, handler);\n            return this; // for chaining\n        };\n        EmitterMixin.prototype.off = function (type, handler) {\n            if (this._handlers) {\n                removeFromHash(this._handlers, type, handler);\n            }\n            if (this._oneHandlers) {\n                removeFromHash(this._oneHandlers, type, handler);\n            }\n            return this; // for chaining\n        };\n        EmitterMixin.prototype.trigger = function (type) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            this.triggerWith(type, this, args);\n            return this; // for chaining\n        };\n        EmitterMixin.prototype.triggerWith = function (type, context, args) {\n            if (this._handlers) {\n                applyAll(this._handlers[type], context, args);\n            }\n            if (this._oneHandlers) {\n                applyAll(this._oneHandlers[type], context, args);\n                delete this._oneHandlers[type]; // will never fire again\n            }\n            return this; // for chaining\n        };\n        EmitterMixin.prototype.hasHandlers = function (type) {\n            return (this._handlers && this._handlers[type] && this._handlers[type].length) ||\n                (this._oneHandlers && this._oneHandlers[type] && this._oneHandlers[type].length);\n        };\n        return EmitterMixin;\n    }(Mixin));\n    function addToHash(hash, type, handler) {\n        (hash[type] || (hash[type] = []))\n            .push(handler);\n    }\n    function removeFromHash(hash, type, handler) {\n        if (handler) {\n            if (hash[type]) {\n                hash[type] = hash[type].filter(function (func) {\n                    return func !== handler;\n                });\n            }\n        }\n        else {\n            delete hash[type]; // remove all handler funcs for this type\n        }\n    }\n\n    /*\n    Records offset information for a set of elements, relative to an origin element.\n    Can record the left/right OR the top/bottom OR both.\n    Provides methods for querying the cache by position.\n    */\n    var PositionCache = /** @class */ (function () {\n        function PositionCache(originEl, els, isHorizontal, isVertical) {\n            this.originEl = originEl;\n            this.els = els;\n            this.isHorizontal = isHorizontal;\n            this.isVertical = isVertical;\n        }\n        // Queries the els for coordinates and stores them.\n        // Call this method before using and of the get* methods below.\n        PositionCache.prototype.build = function () {\n            var originEl = this.originEl;\n            var originClientRect = this.originClientRect =\n                originEl.getBoundingClientRect(); // relative to viewport top-left\n            if (this.isHorizontal) {\n                this.buildElHorizontals(originClientRect.left);\n            }\n            if (this.isVertical) {\n                this.buildElVerticals(originClientRect.top);\n            }\n        };\n        // Populates the left/right internal coordinate arrays\n        PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n            var lefts = [];\n            var rights = [];\n            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n                var el = _a[_i];\n                var rect = el.getBoundingClientRect();\n                lefts.push(rect.left - originClientLeft);\n                rights.push(rect.right - originClientLeft);\n            }\n            this.lefts = lefts;\n            this.rights = rights;\n        };\n        // Populates the top/bottom internal coordinate arrays\n        PositionCache.prototype.buildElVerticals = function (originClientTop) {\n            var tops = [];\n            var bottoms = [];\n            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n                var el = _a[_i];\n                var rect = el.getBoundingClientRect();\n                tops.push(rect.top - originClientTop);\n                bottoms.push(rect.bottom - originClientTop);\n            }\n            this.tops = tops;\n            this.bottoms = bottoms;\n        };\n        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n        // If no intersection is made, returns undefined.\n        PositionCache.prototype.leftToIndex = function (leftPosition) {\n            var lefts = this.lefts;\n            var rights = this.rights;\n            var len = lefts.length;\n            var i;\n            for (i = 0; i < len; i++) {\n                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                    return i;\n                }\n            }\n        };\n        // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n        // If no intersection is made, returns undefined.\n        PositionCache.prototype.topToIndex = function (topPosition) {\n            var tops = this.tops;\n            var bottoms = this.bottoms;\n            var len = tops.length;\n            var i;\n            for (i = 0; i < len; i++) {\n                if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                    return i;\n                }\n            }\n        };\n        // Gets the width of the element at the given index\n        PositionCache.prototype.getWidth = function (leftIndex) {\n            return this.rights[leftIndex] - this.lefts[leftIndex];\n        };\n        // Gets the height of the element at the given index\n        PositionCache.prototype.getHeight = function (topIndex) {\n            return this.bottoms[topIndex] - this.tops[topIndex];\n        };\n        return PositionCache;\n    }());\n\n    /*\n    An object for getting/setting scroll-related information for an element.\n    Internally, this is done very differently for window versus DOM element,\n    so this object serves as a common interface.\n    */\n    var ScrollController = /** @class */ (function () {\n        function ScrollController() {\n        }\n        ScrollController.prototype.getMaxScrollTop = function () {\n            return this.getScrollHeight() - this.getClientHeight();\n        };\n        ScrollController.prototype.getMaxScrollLeft = function () {\n            return this.getScrollWidth() - this.getClientWidth();\n        };\n        ScrollController.prototype.canScrollVertically = function () {\n            return this.getMaxScrollTop() > 0;\n        };\n        ScrollController.prototype.canScrollHorizontally = function () {\n            return this.getMaxScrollLeft() > 0;\n        };\n        ScrollController.prototype.canScrollUp = function () {\n            return this.getScrollTop() > 0;\n        };\n        ScrollController.prototype.canScrollDown = function () {\n            return this.getScrollTop() < this.getMaxScrollTop();\n        };\n        ScrollController.prototype.canScrollLeft = function () {\n            return this.getScrollLeft() > 0;\n        };\n        ScrollController.prototype.canScrollRight = function () {\n            return this.getScrollLeft() < this.getMaxScrollLeft();\n        };\n        return ScrollController;\n    }());\n    var ElementScrollController = /** @class */ (function (_super) {\n        __extends(ElementScrollController, _super);\n        function ElementScrollController(el) {\n            var _this = _super.call(this) || this;\n            _this.el = el;\n            return _this;\n        }\n        ElementScrollController.prototype.getScrollTop = function () {\n            return this.el.scrollTop;\n        };\n        ElementScrollController.prototype.getScrollLeft = function () {\n            return this.el.scrollLeft;\n        };\n        ElementScrollController.prototype.setScrollTop = function (top) {\n            this.el.scrollTop = top;\n        };\n        ElementScrollController.prototype.setScrollLeft = function (left) {\n            this.el.scrollLeft = left;\n        };\n        ElementScrollController.prototype.getScrollWidth = function () {\n            return this.el.scrollWidth;\n        };\n        ElementScrollController.prototype.getScrollHeight = function () {\n            return this.el.scrollHeight;\n        };\n        ElementScrollController.prototype.getClientHeight = function () {\n            return this.el.clientHeight;\n        };\n        ElementScrollController.prototype.getClientWidth = function () {\n            return this.el.clientWidth;\n        };\n        return ElementScrollController;\n    }(ScrollController));\n    var WindowScrollController = /** @class */ (function (_super) {\n        __extends(WindowScrollController, _super);\n        function WindowScrollController() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        WindowScrollController.prototype.getScrollTop = function () {\n            return window.pageYOffset;\n        };\n        WindowScrollController.prototype.getScrollLeft = function () {\n            return window.pageXOffset;\n        };\n        WindowScrollController.prototype.setScrollTop = function (n) {\n            window.scroll(window.pageXOffset, n);\n        };\n        WindowScrollController.prototype.setScrollLeft = function (n) {\n            window.scroll(n, window.pageYOffset);\n        };\n        WindowScrollController.prototype.getScrollWidth = function () {\n            return document.documentElement.scrollWidth;\n        };\n        WindowScrollController.prototype.getScrollHeight = function () {\n            return document.documentElement.scrollHeight;\n        };\n        WindowScrollController.prototype.getClientHeight = function () {\n            return document.documentElement.clientHeight;\n        };\n        WindowScrollController.prototype.getClientWidth = function () {\n            return document.documentElement.clientWidth;\n        };\n        return WindowScrollController;\n    }(ScrollController));\n\n    /*\n    Embodies a div that has potential scrollbars\n    */\n    var ScrollComponent = /** @class */ (function (_super) {\n        __extends(ScrollComponent, _super);\n        function ScrollComponent(overflowX, overflowY) {\n            var _this = _super.call(this, createElement('div', {\n                className: 'fc-scroller'\n            })) || this;\n            _this.overflowX = overflowX;\n            _this.overflowY = overflowY;\n            _this.applyOverflow();\n            return _this;\n        }\n        // sets to natural height, unlocks overflow\n        ScrollComponent.prototype.clear = function () {\n            this.setHeight('auto');\n            this.applyOverflow();\n        };\n        ScrollComponent.prototype.destroy = function () {\n            removeElement(this.el);\n        };\n        // Overflow\n        // -----------------------------------------------------------------------------------------------------------------\n        ScrollComponent.prototype.applyOverflow = function () {\n            applyStyle(this.el, {\n                overflowX: this.overflowX,\n                overflowY: this.overflowY\n            });\n        };\n        // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\n        // Useful for preserving scrollbar widths regardless of future resizes.\n        // Can pass in scrollbarWidths for optimization.\n        ScrollComponent.prototype.lockOverflow = function (scrollbarWidths) {\n            var overflowX = this.overflowX;\n            var overflowY = this.overflowY;\n            scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\n            if (overflowX === 'auto') {\n                overflowX = (scrollbarWidths.bottom || // horizontal scrollbars?\n                    this.canScrollHorizontally() // OR scrolling pane with massless scrollbars?\n                ) ? 'scroll' : 'hidden';\n            }\n            if (overflowY === 'auto') {\n                overflowY = (scrollbarWidths.left || scrollbarWidths.right || // horizontal scrollbars?\n                    this.canScrollVertically() // OR scrolling pane with massless scrollbars?\n                ) ? 'scroll' : 'hidden';\n            }\n            applyStyle(this.el, { overflowX: overflowX, overflowY: overflowY });\n        };\n        ScrollComponent.prototype.setHeight = function (height) {\n            applyStyleProp(this.el, 'height', height);\n        };\n        ScrollComponent.prototype.getScrollbarWidths = function () {\n            var edges = computeEdges(this.el);\n            return {\n                left: edges.scrollbarLeft,\n                right: edges.scrollbarRight,\n                bottom: edges.scrollbarBottom\n            };\n        };\n        return ScrollComponent;\n    }(ElementScrollController));\n\n    var Theme = /** @class */ (function () {\n        function Theme(calendarOptions) {\n            this.calendarOptions = calendarOptions;\n            this.processIconOverride();\n        }\n        Theme.prototype.processIconOverride = function () {\n            if (this.iconOverrideOption) {\n                this.setIconOverride(this.calendarOptions[this.iconOverrideOption]);\n            }\n        };\n        Theme.prototype.setIconOverride = function (iconOverrideHash) {\n            var iconClassesCopy;\n            var buttonName;\n            if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object\n                iconClassesCopy = __assign({}, this.iconClasses);\n                for (buttonName in iconOverrideHash) {\n                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n                }\n                this.iconClasses = iconClassesCopy;\n            }\n            else if (iconOverrideHash === false) {\n                this.iconClasses = {};\n            }\n        };\n        Theme.prototype.applyIconOverridePrefix = function (className) {\n            var prefix = this.iconOverridePrefix;\n            if (prefix && className.indexOf(prefix) !== 0) { // if not already present\n                className = prefix + className;\n            }\n            return className;\n        };\n        Theme.prototype.getClass = function (key) {\n            return this.classes[key] || '';\n        };\n        Theme.prototype.getIconClass = function (buttonName) {\n            var className = this.iconClasses[buttonName];\n            if (className) {\n                return this.baseIconClass + ' ' + className;\n            }\n            return '';\n        };\n        Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n            var className;\n            if (this.iconOverrideCustomButtonOption) {\n                className = customButtonProps[this.iconOverrideCustomButtonOption];\n                if (className) {\n                    return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\n                }\n            }\n            return '';\n        };\n        return Theme;\n    }());\n    Theme.prototype.classes = {};\n    Theme.prototype.iconClasses = {};\n    Theme.prototype.baseIconClass = '';\n    Theme.prototype.iconOverridePrefix = '';\n\n    var guid = 0;\n    var Component = /** @class */ (function () {\n        function Component(context, isView) {\n            // HACK to populate view at top of component instantiation call chain\n            if (isView) {\n                context.view = this;\n            }\n            this.uid = String(guid++);\n            this.context = context;\n            this.dateEnv = context.dateEnv;\n            this.theme = context.theme;\n            this.view = context.view;\n            this.calendar = context.calendar;\n            this.isRtl = this.opt('dir') === 'rtl';\n        }\n        Component.addEqualityFuncs = function (newFuncs) {\n            this.prototype.equalityFuncs = __assign({}, this.prototype.equalityFuncs, newFuncs);\n        };\n        Component.prototype.opt = function (name) {\n            return this.context.options[name];\n        };\n        Component.prototype.receiveProps = function (props) {\n            var _a = recycleProps(this.props || {}, props, this.equalityFuncs), anyChanges = _a.anyChanges, comboProps = _a.comboProps;\n            this.props = comboProps;\n            if (anyChanges) {\n                this.render(comboProps);\n            }\n        };\n        Component.prototype.render = function (props) {\n        };\n        // after destroy is called, this component won't ever be used again\n        Component.prototype.destroy = function () {\n        };\n        return Component;\n    }());\n    Component.prototype.equalityFuncs = {};\n    /*\n    Reuses old values when equal. If anything is unequal, returns newProps as-is.\n    Great for PureComponent, but won't be feasible with React, so just eliminate and use React's DOM diffing.\n    */\n    function recycleProps(oldProps, newProps, equalityFuncs) {\n        var comboProps = {}; // some old, some new\n        var anyChanges = false;\n        for (var key in newProps) {\n            if (key in oldProps && (oldProps[key] === newProps[key] ||\n                (equalityFuncs[key] && equalityFuncs[key](oldProps[key], newProps[key])))) {\n                // equal to old? use old prop\n                comboProps[key] = oldProps[key];\n            }\n            else {\n                comboProps[key] = newProps[key];\n                anyChanges = true;\n            }\n        }\n        for (var key in oldProps) {\n            if (!(key in newProps)) {\n                anyChanges = true;\n                break;\n            }\n        }\n        return { anyChanges: anyChanges, comboProps: comboProps };\n    }\n\n    /*\n    PURPOSES:\n    - hook up to fg, fill, and mirror renderers\n    - interface for dragging and hits\n    */\n    var DateComponent = /** @class */ (function (_super) {\n        __extends(DateComponent, _super);\n        function DateComponent(context, el, isView) {\n            var _this = _super.call(this, context, isView) || this;\n            _this.el = el;\n            return _this;\n        }\n        DateComponent.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            removeElement(this.el);\n        };\n        // TODO: WHAT ABOUT (sourceSeg && sourceSeg.component.doesDragMirror)\n        //\n        // Event Drag-n-Drop Rendering (for both events and external elements)\n        // ---------------------------------------------------------------------------------------------------------------\n        /*\n        renderEventDragSegs(state: EventSegUiInteractionState) {\n          if (state) {\n            let { isEvent, segs, sourceSeg } = state\n      \n            if (this.eventRenderer) {\n              this.eventRenderer.hideByHash(state.affectedInstances)\n            }\n      \n            // if the user is dragging something that is considered an event with real event data,\n            // and this component likes to do drag mirrors OR the component where the seg came from\n            // likes to do drag mirrors, then render a drag mirror.\n            if (isEvent && (this.doesDragMirror || sourceSeg && sourceSeg.component.doesDragMirror)) {\n              if (this.mirrorRenderer) {\n                this.mirrorRenderer.renderSegs(segs, { isDragging: true, sourceSeg })\n              }\n            }\n      \n            // if it would be impossible to render a drag mirror OR this component likes to render\n            // highlights, then render a highlight.\n            if (!isEvent || this.doesDragHighlight) {\n              if (this.fillRenderer) {\n                this.fillRenderer.renderSegs('highlight', segs)\n              }\n            }\n          }\n        }\n        */\n        // Hit System\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.buildPositionCaches = function () {\n        };\n        DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n            return null; // this should be abstract\n        };\n        // Validation\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.isInteractionValid = function (interaction) {\n            var calendar = this.calendar;\n            var dateProfile = this.props.dateProfile; // HACK\n            var instances = interaction.mutatedEvents.instances;\n            if (dateProfile) { // HACK for DayTile\n                for (var instanceId in instances) {\n                    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n                        return false;\n                    }\n                }\n            }\n            return isInteractionValid(interaction, calendar);\n        };\n        DateComponent.prototype.isDateSelectionValid = function (selection) {\n            var dateProfile = this.props.dateProfile; // HACK\n            if (dateProfile && // HACK for DayTile\n                !rangeContainsRange(dateProfile.validRange, selection.range)) {\n                return false;\n            }\n            return isDateSelectionValid(selection, this.calendar);\n        };\n        // Triggering\n        // -----------------------------------------------------------------------------------------------------------------\n        // TODO: move to Calendar\n        DateComponent.prototype.publiclyTrigger = function (name, args) {\n            var calendar = this.calendar;\n            return calendar.publiclyTrigger(name, args);\n        };\n        DateComponent.prototype.publiclyTriggerAfterSizing = function (name, args) {\n            var calendar = this.calendar;\n            return calendar.publiclyTriggerAfterSizing(name, args);\n        };\n        DateComponent.prototype.hasPublicHandlers = function (name) {\n            var calendar = this.calendar;\n            return calendar.hasPublicHandlers(name);\n        };\n        DateComponent.prototype.triggerRenderedSegs = function (segs, isMirrors) {\n            var calendar = this.calendar;\n            if (this.hasPublicHandlers('eventPositioned')) {\n                for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                    var seg = segs_1[_i];\n                    this.publiclyTriggerAfterSizing('eventPositioned', [\n                        {\n                            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),\n                            isMirror: isMirrors,\n                            isStart: seg.isStart,\n                            isEnd: seg.isEnd,\n                            el: seg.el,\n                            view: this // ?\n                        }\n                    ]);\n                }\n            }\n            if (!calendar.state.loadingLevel) { // avoid initial empty state while pending\n                calendar.afterSizingTriggers._eventsPositioned = [null]; // fire once\n            }\n        };\n        DateComponent.prototype.triggerWillRemoveSegs = function (segs, isMirrors) {\n            var calendar = this.calendar;\n            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n                var seg = segs_2[_i];\n                calendar.trigger('eventElRemove', seg.el);\n            }\n            if (this.hasPublicHandlers('eventDestroy')) {\n                for (var _a = 0, segs_3 = segs; _a < segs_3.length; _a++) {\n                    var seg = segs_3[_a];\n                    this.publiclyTrigger('eventDestroy', [\n                        {\n                            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),\n                            isMirror: isMirrors,\n                            el: seg.el,\n                            view: this // ?\n                        }\n                    ]);\n                }\n            }\n        };\n        // Pointer Interaction Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.isValidSegDownEl = function (el) {\n            return !this.props.eventDrag && // HACK\n                !this.props.eventResize && // HACK\n                !elementClosest(el, '.fc-mirror') &&\n                (this.isPopover() || !this.isInPopover(el));\n            // ^above line ensures we don't detect a seg interaction within a nested component.\n            // it's a HACK because it only supports a popover as the nested component.\n        };\n        DateComponent.prototype.isValidDateDownEl = function (el) {\n            var segEl = elementClosest(el, this.fgSegSelector);\n            return (!segEl || segEl.classList.contains('fc-mirror')) &&\n                !elementClosest(el, '.fc-more') && // a \"more..\" link\n                !elementClosest(el, 'a[data-goto]') && // a clickable nav link\n                !this.isInPopover(el);\n        };\n        DateComponent.prototype.isPopover = function () {\n            return this.el.classList.contains('fc-popover');\n        };\n        DateComponent.prototype.isInPopover = function (el) {\n            return Boolean(elementClosest(el, '.fc-popover'));\n        };\n        return DateComponent;\n    }(Component));\n    DateComponent.prototype.fgSegSelector = '.fc-event-container > *';\n    DateComponent.prototype.bgSegSelector = '.fc-bgevent:not(.fc-nonbusiness)';\n\n    var uid$1 = 0;\n    function createPlugin(input) {\n        return {\n            id: String(uid$1++),\n            deps: input.deps || [],\n            reducers: input.reducers || [],\n            eventDefParsers: input.eventDefParsers || [],\n            eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n            eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n            dateSelectionTransformers: input.dateSelectionTransformers || [],\n            datePointTransforms: input.datePointTransforms || [],\n            dateSpanTransforms: input.dateSpanTransforms || [],\n            views: input.views || {},\n            viewPropsTransformers: input.viewPropsTransformers || [],\n            isPropsValid: input.isPropsValid || null,\n            externalDefTransforms: input.externalDefTransforms || [],\n            eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],\n            viewContainerModifiers: input.viewContainerModifiers || [],\n            eventDropTransformers: input.eventDropTransformers || [],\n            componentInteractions: input.componentInteractions || [],\n            calendarInteractions: input.calendarInteractions || [],\n            themeClasses: input.themeClasses || {},\n            eventSourceDefs: input.eventSourceDefs || [],\n            cmdFormatter: input.cmdFormatter,\n            recurringTypes: input.recurringTypes || [],\n            namedTimeZonedImpl: input.namedTimeZonedImpl,\n            defaultView: input.defaultView || '',\n            elementDraggingImpl: input.elementDraggingImpl,\n            optionChangeHandlers: input.optionChangeHandlers || {}\n        };\n    }\n    var PluginSystem = /** @class */ (function () {\n        function PluginSystem() {\n            this.hooks = {\n                reducers: [],\n                eventDefParsers: [],\n                eventDragMutationMassagers: [],\n                eventDefMutationAppliers: [],\n                dateSelectionTransformers: [],\n                datePointTransforms: [],\n                dateSpanTransforms: [],\n                views: {},\n                viewPropsTransformers: [],\n                isPropsValid: null,\n                externalDefTransforms: [],\n                eventResizeJoinTransforms: [],\n                viewContainerModifiers: [],\n                eventDropTransformers: [],\n                componentInteractions: [],\n                calendarInteractions: [],\n                themeClasses: {},\n                eventSourceDefs: [],\n                cmdFormatter: null,\n                recurringTypes: [],\n                namedTimeZonedImpl: null,\n                defaultView: '',\n                elementDraggingImpl: null,\n                optionChangeHandlers: {}\n            };\n            this.addedHash = {};\n        }\n        PluginSystem.prototype.add = function (plugin) {\n            if (!this.addedHash[plugin.id]) {\n                this.addedHash[plugin.id] = true;\n                for (var _i = 0, _a = plugin.deps; _i < _a.length; _i++) {\n                    var dep = _a[_i];\n                    this.add(dep);\n                }\n                this.hooks = combineHooks(this.hooks, plugin);\n            }\n        };\n        return PluginSystem;\n    }());\n    function combineHooks(hooks0, hooks1) {\n        return {\n            reducers: hooks0.reducers.concat(hooks1.reducers),\n            eventDefParsers: hooks0.eventDefParsers.concat(hooks1.eventDefParsers),\n            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n            views: __assign({}, hooks0.views, hooks1.views),\n            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n            eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),\n            viewContainerModifiers: hooks0.viewContainerModifiers.concat(hooks1.viewContainerModifiers),\n            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n            themeClasses: __assign({}, hooks0.themeClasses, hooks1.themeClasses),\n            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n            defaultView: hooks0.defaultView || hooks1.defaultView,\n            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n            optionChangeHandlers: __assign({}, hooks0.optionChangeHandlers, hooks1.optionChangeHandlers)\n        };\n    }\n\n    var eventSourceDef = {\n        ignoreRange: true,\n        parseMeta: function (raw) {\n            if (Array.isArray(raw)) { // short form\n                return raw;\n            }\n            else if (Array.isArray(raw.events)) {\n                return raw.events;\n            }\n            return null;\n        },\n        fetch: function (arg, success) {\n            success({\n                rawEvents: arg.eventSource.meta\n            });\n        }\n    };\n    var ArrayEventSourcePlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef]\n    });\n\n    var eventSourceDef$1 = {\n        parseMeta: function (raw) {\n            if (typeof raw === 'function') { // short form\n                return raw;\n            }\n            else if (typeof raw.events === 'function') {\n                return raw.events;\n            }\n            return null;\n        },\n        fetch: function (arg, success, failure) {\n            var dateEnv = arg.calendar.dateEnv;\n            var func = arg.eventSource.meta;\n            unpromisify(func.bind(null, {\n                start: dateEnv.toDate(arg.range.start),\n                end: dateEnv.toDate(arg.range.end),\n                startStr: dateEnv.formatIso(arg.range.start),\n                endStr: dateEnv.formatIso(arg.range.end),\n                timeZone: dateEnv.timeZone\n            }), function (rawEvents) {\n                success({ rawEvents: rawEvents }); // needs an object response\n            }, failure // send errorObj directly to failure callback\n            );\n        }\n    };\n    var FuncEventSourcePlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef$1]\n    });\n\n    function requestJson(method, url, params, successCallback, failureCallback) {\n        method = method.toUpperCase();\n        var body = null;\n        if (method === 'GET') {\n            url = injectQueryStringParams(url, params);\n        }\n        else {\n            body = encodeParams(params);\n        }\n        var xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (method !== 'GET') {\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        }\n        xhr.onload = function () {\n            if (xhr.status >= 200 && xhr.status < 400) {\n                try {\n                    var res = JSON.parse(xhr.responseText);\n                    successCallback(res, xhr);\n                }\n                catch (err) {\n                    failureCallback('Failure parsing JSON', xhr);\n                }\n            }\n            else {\n                failureCallback('Request failed', xhr);\n            }\n        };\n        xhr.onerror = function () {\n            failureCallback('Request failed', xhr);\n        };\n        xhr.send(body);\n    }\n    function injectQueryStringParams(url, params) {\n        return url +\n            (url.indexOf('?') === -1 ? '?' : '&') +\n            encodeParams(params);\n    }\n    function encodeParams(params) {\n        var parts = [];\n        for (var key in params) {\n            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n        }\n        return parts.join('&');\n    }\n\n    var eventSourceDef$2 = {\n        parseMeta: function (raw) {\n            if (typeof raw === 'string') { // short form\n                raw = { url: raw };\n            }\n            else if (!raw || typeof raw !== 'object' || !raw.url) {\n                return null;\n            }\n            return {\n                url: raw.url,\n                method: (raw.method || 'GET').toUpperCase(),\n                extraParams: raw.extraParams,\n                startParam: raw.startParam,\n                endParam: raw.endParam,\n                timeZoneParam: raw.timeZoneParam\n            };\n        },\n        fetch: function (arg, success, failure) {\n            var meta = arg.eventSource.meta;\n            var requestParams = buildRequestParams(meta, arg.range, arg.calendar);\n            requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n                success({ rawEvents: rawEvents, xhr: xhr });\n            }, function (errorMessage, xhr) {\n                failure({ message: errorMessage, xhr: xhr });\n            });\n        }\n    };\n    var JsonFeedEventSourcePlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef$2]\n    });\n    function buildRequestParams(meta, range, calendar) {\n        var dateEnv = calendar.dateEnv;\n        var startParam;\n        var endParam;\n        var timeZoneParam;\n        var customRequestParams;\n        var params = {};\n        startParam = meta.startParam;\n        if (startParam == null) {\n            startParam = calendar.opt('startParam');\n        }\n        endParam = meta.endParam;\n        if (endParam == null) {\n            endParam = calendar.opt('endParam');\n        }\n        timeZoneParam = meta.timeZoneParam;\n        if (timeZoneParam == null) {\n            timeZoneParam = calendar.opt('timeZoneParam');\n        }\n        // retrieve any outbound GET/POST data from the options\n        if (typeof meta.extraParams === 'function') {\n            // supplied as a function that returns a key/value object\n            customRequestParams = meta.extraParams();\n        }\n        else {\n            // probably supplied as a straight key/value object\n            customRequestParams = meta.extraParams || {};\n        }\n        __assign(params, customRequestParams);\n        params[startParam] = dateEnv.formatIso(range.start);\n        params[endParam] = dateEnv.formatIso(range.end);\n        if (dateEnv.timeZone !== 'local') {\n            params[timeZoneParam] = dateEnv.timeZone;\n        }\n        return params;\n    }\n\n    var recurring = {\n        parse: function (rawEvent, leftoverProps, dateEnv) {\n            var createMarker = dateEnv.createMarker.bind(dateEnv);\n            var processors = {\n                daysOfWeek: null,\n                startTime: createDuration,\n                endTime: createDuration,\n                startRecur: createMarker,\n                endRecur: createMarker\n            };\n            var props = refineProps(rawEvent, processors, {}, leftoverProps);\n            var anyValid = false;\n            for (var propName in props) {\n                if (props[propName] != null) {\n                    anyValid = true;\n                    break;\n                }\n            }\n            if (anyValid) {\n                return {\n                    allDayGuess: Boolean(!props.startTime && !props.endTime),\n                    duration: (props.startTime && props.endTime) ?\n                        subtractDurations(props.endTime, props.startTime) :\n                        null,\n                    typeData: props // doesn't need endTime anymore but oh well\n                };\n            }\n            return null;\n        },\n        expand: function (typeData, framingRange, dateEnv) {\n            var clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });\n            if (clippedFramingRange) {\n                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n            }\n            else {\n                return [];\n            }\n        }\n    };\n    var SimpleRecurrencePlugin = createPlugin({\n        recurringTypes: [recurring]\n    });\n    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n        var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n        var dayMarker = startOfDay(framingRange.start);\n        var endMarker = framingRange.end;\n        var instanceStarts = [];\n        while (dayMarker < endMarker) {\n            var instanceStart \n            // if everyday, or this particular day-of-week\n            = void 0;\n            // if everyday, or this particular day-of-week\n            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n                if (startTime) {\n                    instanceStart = dateEnv.add(dayMarker, startTime);\n                }\n                else {\n                    instanceStart = dayMarker;\n                }\n                instanceStarts.push(instanceStart);\n            }\n            dayMarker = addDays(dayMarker, 1);\n        }\n        return instanceStarts;\n    }\n\n    var DefaultOptionChangeHandlers = createPlugin({\n        optionChangeHandlers: {\n            events: function (events, calendar) {\n                handleEventSources([events], calendar);\n            },\n            eventSources: handleEventSources,\n            plugins: handlePlugins\n        }\n    });\n    function handleEventSources(inputs, calendar) {\n        var unfoundSources = hashValuesToArray(calendar.state.eventSources);\n        var newInputs = [];\n        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n            var input = inputs_1[_i];\n            var inputFound = false;\n            for (var i = 0; i < unfoundSources.length; i++) {\n                if (isValuesSimilar(unfoundSources[i]._raw, input, 2)) {\n                    unfoundSources.splice(i, 1); // delete\n                    inputFound = true;\n                    break;\n                }\n            }\n            if (!inputFound) {\n                newInputs.push(input);\n            }\n        }\n        for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n            var unfoundSource = unfoundSources_1[_a];\n            calendar.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: unfoundSource.sourceId\n            });\n        }\n        for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n            var newInput = newInputs_1[_b];\n            calendar.addEventSource(newInput);\n        }\n    }\n    // shortcoming: won't remove plugins\n    function handlePlugins(inputs, calendar) {\n        calendar.addPluginInputs(inputs); // will gracefully handle duplicates\n    }\n\n    var config = {}; // TODO: make these options\n    var globalDefaults = {\n        defaultRangeSeparator: ' - ',\n        titleRangeSeparator: ' \\u2013 ',\n        defaultTimedEventDuration: '01:00:00',\n        defaultAllDayEventDuration: { day: 1 },\n        forceEventDuration: false,\n        nextDayThreshold: '00:00:00',\n        // display\n        columnHeader: true,\n        defaultView: '',\n        aspectRatio: 1.35,\n        header: {\n            left: 'title',\n            center: '',\n            right: 'today prev,next'\n        },\n        weekends: true,\n        weekNumbers: false,\n        weekNumberCalculation: 'local',\n        editable: false,\n        // nowIndicator: false,\n        scrollTime: '06:00:00',\n        minTime: '00:00:00',\n        maxTime: '24:00:00',\n        showNonCurrentDates: true,\n        // event ajax\n        lazyFetching: true,\n        startParam: 'start',\n        endParam: 'end',\n        timeZoneParam: 'timeZone',\n        timeZone: 'local',\n        // allDayDefault: undefined,\n        // locale\n        locales: [],\n        locale: '',\n        // dir: will get this from the default locale\n        // buttonIcons: null,\n        // allows setting a min-height to the event segment to prevent short events overlapping each other\n        timeGridEventMinHeight: 0,\n        themeSystem: 'standard',\n        // eventResizableFromStart: false,\n        dragRevertDuration: 500,\n        dragScroll: true,\n        allDayMaintainDuration: false,\n        // selectable: false,\n        unselectAuto: true,\n        // selectMinDistance: 0,\n        dropAccept: '*',\n        eventOrder: 'start,-duration,allDay,title',\n        // ^ if start tie, longer events go before shorter. final tie-breaker is title text\n        // rerenderDelay: null,\n        eventLimit: false,\n        eventLimitClick: 'popover',\n        dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },\n        handleWindowResize: true,\n        windowResizeDelay: 100,\n        longPressDelay: 1000,\n        eventDragMinDistance: 5 // only applies to mouse\n    };\n    var rtlDefaults = {\n        header: {\n            left: 'next,prev today',\n            center: '',\n            right: 'title'\n        },\n        buttonIcons: {\n            // TODO: make RTL support the responibility of the theme\n            prev: 'fc-icon-chevron-right',\n            next: 'fc-icon-chevron-left',\n            prevYear: 'fc-icon-chevrons-right',\n            nextYear: 'fc-icon-chevrons-left'\n        }\n    };\n    var complexOptions = [\n        'header',\n        'footer',\n        'buttonText',\n        'buttonIcons'\n    ];\n    // Merges an array of option objects into a single object\n    function mergeOptions(optionObjs) {\n        return mergeProps(optionObjs, complexOptions);\n    }\n    // TODO: move this stuff to a \"plugin\"-related file...\n    var INTERNAL_PLUGINS = [\n        ArrayEventSourcePlugin,\n        FuncEventSourcePlugin,\n        JsonFeedEventSourcePlugin,\n        SimpleRecurrencePlugin,\n        DefaultOptionChangeHandlers\n    ];\n    function refinePluginDefs(pluginInputs) {\n        var plugins = [];\n        for (var _i = 0, pluginInputs_1 = pluginInputs; _i < pluginInputs_1.length; _i++) {\n            var pluginInput = pluginInputs_1[_i];\n            if (typeof pluginInput === 'string') {\n                var globalName = 'FullCalendar' + capitaliseFirstLetter(pluginInput);\n                if (!window[globalName]) {\n                    console.warn('Plugin file not loaded for ' + pluginInput);\n                }\n                else {\n                    plugins.push(window[globalName].default); // is an ES6 module\n                }\n            }\n            else {\n                plugins.push(pluginInput);\n            }\n        }\n        return INTERNAL_PLUGINS.concat(plugins);\n    }\n\n    var RAW_EN_LOCALE = {\n        code: 'en',\n        week: {\n            dow: 0,\n            doy: 4 // 4 days need to be within the year to be considered the first week\n        },\n        dir: 'ltr',\n        buttonText: {\n            prev: 'prev',\n            next: 'next',\n            prevYear: 'prev year',\n            nextYear: 'next year',\n            year: 'year',\n            today: 'today',\n            month: 'month',\n            week: 'week',\n            day: 'day',\n            list: 'list'\n        },\n        weekLabel: 'W',\n        allDayText: 'all-day',\n        eventLimitText: 'more',\n        noEventsMessage: 'No events to display'\n    };\n    function parseRawLocales(explicitRawLocales) {\n        var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n        var globalArray = window['FullCalendarLocalesAll'] || []; // from locales-all.js\n        var globalObject = window['FullCalendarLocales'] || {}; // from locales/*.js. keys are meaningless\n        var allRawLocales = globalArray.concat(// globalArray is low prio\n        hashValuesToArray(globalObject), // medium prio\n        explicitRawLocales // highest prio\n        );\n        var rawLocaleMap = {\n            en: RAW_EN_LOCALE // necessary?\n        };\n        for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n            var rawLocale = allRawLocales_1[_i];\n            rawLocaleMap[rawLocale.code] = rawLocale;\n        }\n        return {\n            map: rawLocaleMap,\n            defaultCode: defaultCode\n        };\n    }\n    function buildLocale(inputSingular, available) {\n        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n            return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n        }\n        else {\n            return queryLocale(inputSingular, available);\n        }\n    }\n    function queryLocale(codeArg, available) {\n        var codes = [].concat(codeArg || []); // will convert to array\n        var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n        return parseLocale(codeArg, codes, raw);\n    }\n    function queryRawLocale(codes, available) {\n        for (var i = 0; i < codes.length; i++) {\n            var parts = codes[i].toLocaleLowerCase().split('-');\n            for (var j = parts.length; j > 0; j--) {\n                var simpleId = parts.slice(0, j).join('-');\n                if (available[simpleId]) {\n                    return available[simpleId];\n                }\n            }\n        }\n        return null;\n    }\n    function parseLocale(codeArg, codes, raw) {\n        var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);\n        delete merged.code; // don't want this part of the options\n        var week = merged.week;\n        delete merged.week;\n        return {\n            codeArg: codeArg,\n            codes: codes,\n            week: week,\n            simpleNumberFormat: new Intl.NumberFormat(codeArg),\n            options: merged\n        };\n    }\n\n    var OptionsManager = /** @class */ (function () {\n        function OptionsManager(overrides) {\n            this.overrides = __assign({}, overrides); // make a copy\n            this.dynamicOverrides = {};\n            this.compute();\n        }\n        OptionsManager.prototype.add = function (props) {\n            __assign(this.overrides, props);\n            this.compute();\n        };\n        OptionsManager.prototype.addDynamic = function (props) {\n            __assign(this.dynamicOverrides, props);\n            this.compute();\n        };\n        OptionsManager.prototype.reset = function (props) {\n            this.overrides = props;\n            this.compute();\n        };\n        // Computes the flattened options hash for the calendar and assigns to `this.options`.\n        // Assumes this.overrides and this.dynamicOverrides have already been initialized.\n        OptionsManager.prototype.compute = function () {\n            // TODO: not a very efficient system\n            var locales = firstDefined(// explicit locale option given?\n            this.dynamicOverrides.locales, this.overrides.locales, globalDefaults.locales);\n            var locale = firstDefined(// explicit locales option given?\n            this.dynamicOverrides.locale, this.overrides.locale, globalDefaults.locale);\n            var available = parseRawLocales(locales);\n            var localeDefaults = buildLocale(locale || available.defaultCode, available.map).options;\n            var dir = firstDefined(// based on options computed so far, is direction RTL?\n            this.dynamicOverrides.dir, this.overrides.dir, localeDefaults.dir);\n            var dirDefaults = dir === 'rtl' ? rtlDefaults : {};\n            this.dirDefaults = dirDefaults;\n            this.localeDefaults = localeDefaults;\n            this.computed = mergeOptions([\n                globalDefaults,\n                dirDefaults,\n                localeDefaults,\n                this.overrides,\n                this.dynamicOverrides\n            ]);\n        };\n        return OptionsManager;\n    }());\n\n    var calendarSystemClassMap = {};\n    function registerCalendarSystem(name, theClass) {\n        calendarSystemClassMap[name] = theClass;\n    }\n    function createCalendarSystem(name) {\n        return new calendarSystemClassMap[name]();\n    }\n    var GregorianCalendarSystem = /** @class */ (function () {\n        function GregorianCalendarSystem() {\n        }\n        GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n            return d.getUTCFullYear();\n        };\n        GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n            return d.getUTCMonth();\n        };\n        GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n            return d.getUTCDate();\n        };\n        GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n            return arrayToUtcDate(arr);\n        };\n        GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n            return dateToUtcArray(marker);\n        };\n        return GregorianCalendarSystem;\n    }());\n    registerCalendarSystem('gregory', GregorianCalendarSystem);\n\n    var ISO_RE = /^\\s*(\\d{4})(-(\\d{2})(-(\\d{2})([T ](\\d{2}):(\\d{2})(:(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n    function parse(str) {\n        var m = ISO_RE.exec(str);\n        if (m) {\n            var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number('0.' + m[12]) * 1000 : 0));\n            if (isValidDate(marker)) {\n                var timeZoneOffset = null;\n                if (m[13]) {\n                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +\n                        Number(m[18] || 0));\n                }\n                return {\n                    marker: marker,\n                    isTimeUnspecified: !m[6],\n                    timeZoneOffset: timeZoneOffset\n                };\n            }\n        }\n        return null;\n    }\n\n    var DateEnv = /** @class */ (function () {\n        function DateEnv(settings) {\n            var timeZone = this.timeZone = settings.timeZone;\n            var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n            if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n            }\n            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n            this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n            this.locale = settings.locale;\n            this.weekDow = settings.locale.week.dow;\n            this.weekDoy = settings.locale.week.doy;\n            if (settings.weekNumberCalculation === 'ISO') {\n                this.weekDow = 1;\n                this.weekDoy = 4;\n            }\n            else if (typeof settings.firstDay === 'number') {\n                this.weekDow = settings.firstDay;\n            }\n            if (typeof settings.weekNumberCalculation === 'function') {\n                this.weekNumberFunc = settings.weekNumberCalculation;\n            }\n            this.weekLabel = settings.weekLabel != null ? settings.weekLabel : settings.locale.options.weekLabel;\n            this.cmdFormatter = settings.cmdFormatter;\n        }\n        // Creating / Parsing\n        DateEnv.prototype.createMarker = function (input) {\n            var meta = this.createMarkerMeta(input);\n            if (meta === null) {\n                return null;\n            }\n            return meta.marker;\n        };\n        DateEnv.prototype.createNowMarker = function () {\n            if (this.canComputeOffset) {\n                return this.timestampToMarker(new Date().valueOf());\n            }\n            else {\n                // if we can't compute the current date val for a timezone,\n                // better to give the current local date vals than UTC\n                return arrayToUtcDate(dateToLocalArray(new Date()));\n            }\n        };\n        DateEnv.prototype.createMarkerMeta = function (input) {\n            if (typeof input === 'string') {\n                return this.parse(input);\n            }\n            var marker = null;\n            if (typeof input === 'number') {\n                marker = this.timestampToMarker(input);\n            }\n            else if (input instanceof Date) {\n                input = input.valueOf();\n                if (!isNaN(input)) {\n                    marker = this.timestampToMarker(input);\n                }\n            }\n            else if (Array.isArray(input)) {\n                marker = arrayToUtcDate(input);\n            }\n            if (marker === null || !isValidDate(marker)) {\n                return null;\n            }\n            return { marker: marker, isTimeUnspecified: false, forcedTzo: null };\n        };\n        DateEnv.prototype.parse = function (s) {\n            var parts = parse(s);\n            if (parts === null) {\n                return null;\n            }\n            var marker = parts.marker;\n            var forcedTzo = null;\n            if (parts.timeZoneOffset !== null) {\n                if (this.canComputeOffset) {\n                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n                }\n                else {\n                    forcedTzo = parts.timeZoneOffset;\n                }\n            }\n            return { marker: marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo: forcedTzo };\n        };\n        // Accessors\n        DateEnv.prototype.getYear = function (marker) {\n            return this.calendarSystem.getMarkerYear(marker);\n        };\n        DateEnv.prototype.getMonth = function (marker) {\n            return this.calendarSystem.getMarkerMonth(marker);\n        };\n        // Adding / Subtracting\n        DateEnv.prototype.add = function (marker, dur) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] += dur.years;\n            a[1] += dur.months;\n            a[2] += dur.days;\n            a[6] += dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.subtract = function (marker, dur) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] -= dur.years;\n            a[1] -= dur.months;\n            a[2] -= dur.days;\n            a[6] -= dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.addYears = function (marker, n) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.addMonths = function (marker, n) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[1] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        // Diffing Whole Units\n        DateEnv.prototype.diffWholeYears = function (m0, m1) {\n            var calendarSystem = this.calendarSystem;\n            if (timeAsMs(m0) === timeAsMs(m1) &&\n                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&\n                calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n            }\n            return null;\n        };\n        DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n            var calendarSystem = this.calendarSystem;\n            if (timeAsMs(m0) === timeAsMs(m1) &&\n                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n                return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +\n                    (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n            }\n            return null;\n        };\n        // Range / Duration\n        DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n            var n = this.diffWholeYears(m0, m1);\n            if (n !== null) {\n                return { unit: 'year', value: n };\n            }\n            n = this.diffWholeMonths(m0, m1);\n            if (n !== null) {\n                return { unit: 'month', value: n };\n            }\n            n = diffWholeWeeks(m0, m1);\n            if (n !== null) {\n                return { unit: 'week', value: n };\n            }\n            n = diffWholeDays(m0, m1);\n            if (n !== null) {\n                return { unit: 'day', value: n };\n            }\n            n = diffHours(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'hour', value: n };\n            }\n            n = diffMinutes(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'minute', value: n };\n            }\n            n = diffSeconds(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'second', value: n };\n            }\n            return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };\n        };\n        DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n            // TODO: can use greatestWholeUnit\n            var diff;\n            if (d.years) {\n                diff = this.diffWholeYears(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughYears(d);\n                }\n            }\n            if (d.months) {\n                diff = this.diffWholeMonths(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughMonths(d);\n                }\n            }\n            if (d.days) {\n                diff = diffWholeDays(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughDays(d);\n                }\n            }\n            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n        };\n        // Start-Of\n        DateEnv.prototype.startOf = function (m, unit) {\n            if (unit === 'year') {\n                return this.startOfYear(m);\n            }\n            else if (unit === 'month') {\n                return this.startOfMonth(m);\n            }\n            else if (unit === 'week') {\n                return this.startOfWeek(m);\n            }\n            else if (unit === 'day') {\n                return startOfDay(m);\n            }\n            else if (unit === 'hour') {\n                return startOfHour(m);\n            }\n            else if (unit === 'minute') {\n                return startOfMinute(m);\n            }\n            else if (unit === 'second') {\n                return startOfSecond(m);\n            }\n        };\n        DateEnv.prototype.startOfYear = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m)\n            ]);\n        };\n        DateEnv.prototype.startOfMonth = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m)\n            ]);\n        };\n        DateEnv.prototype.startOfWeek = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m),\n                m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7)\n            ]);\n        };\n        // Week Number\n        DateEnv.prototype.computeWeekNumber = function (marker) {\n            if (this.weekNumberFunc) {\n                return this.weekNumberFunc(this.toDate(marker));\n            }\n            else {\n                return weekOfYear(marker, this.weekDow, this.weekDoy);\n            }\n        };\n        // TODO: choke on timeZoneName: long\n        DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n            if (dateOptions === void 0) { dateOptions = {}; }\n            return formatter.format({\n                marker: marker,\n                timeZoneOffset: dateOptions.forcedTzo != null ?\n                    dateOptions.forcedTzo :\n                    this.offsetForMarker(marker)\n            }, this);\n        };\n        DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n            if (dateOptions === void 0) { dateOptions = {}; }\n            if (dateOptions.isEndExclusive) {\n                end = addMs(end, -1);\n            }\n            return formatter.formatRange({\n                marker: start,\n                timeZoneOffset: dateOptions.forcedStartTzo != null ?\n                    dateOptions.forcedStartTzo :\n                    this.offsetForMarker(start)\n            }, {\n                marker: end,\n                timeZoneOffset: dateOptions.forcedEndTzo != null ?\n                    dateOptions.forcedEndTzo :\n                    this.offsetForMarker(end)\n            }, this);\n        };\n        DateEnv.prototype.formatIso = function (marker, extraOptions) {\n            if (extraOptions === void 0) { extraOptions = {}; }\n            var timeZoneOffset = null;\n            if (!extraOptions.omitTimeZoneOffset) {\n                if (extraOptions.forcedTzo != null) {\n                    timeZoneOffset = extraOptions.forcedTzo;\n                }\n                else {\n                    timeZoneOffset = this.offsetForMarker(marker);\n                }\n            }\n            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n        };\n        // TimeZone\n        DateEnv.prototype.timestampToMarker = function (ms) {\n            if (this.timeZone === 'local') {\n                return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n            }\n            else if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n                return new Date(ms);\n            }\n            else {\n                return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n            }\n        };\n        DateEnv.prototype.offsetForMarker = function (m) {\n            if (this.timeZone === 'local') {\n                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n            }\n            else if (this.timeZone === 'UTC') {\n                return 0;\n            }\n            else if (this.namedTimeZoneImpl) {\n                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n            }\n            return null;\n        };\n        // Conversion\n        DateEnv.prototype.toDate = function (m, forcedTzo) {\n            if (this.timeZone === 'local') {\n                return arrayToLocalDate(dateToUtcArray(m));\n            }\n            else if (this.timeZone === 'UTC') {\n                return new Date(m.valueOf()); // make sure it's a copy\n            }\n            else if (!this.namedTimeZoneImpl) {\n                return new Date(m.valueOf() - (forcedTzo || 0));\n            }\n            else {\n                return new Date(m.valueOf() -\n                    this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60 // convert minutes -> ms\n                );\n            }\n        };\n        return DateEnv;\n    }());\n\n    var SIMPLE_SOURCE_PROPS = {\n        id: String,\n        allDayDefault: Boolean,\n        eventDataTransform: Function,\n        success: Function,\n        failure: Function\n    };\n    var uid$2 = 0;\n    function doesSourceNeedRange(eventSource, calendar) {\n        var defs = calendar.pluginSystem.hooks.eventSourceDefs;\n        return !defs[eventSource.sourceDefId].ignoreRange;\n    }\n    function parseEventSource(raw, calendar) {\n        var defs = calendar.pluginSystem.hooks.eventSourceDefs;\n        for (var i = defs.length - 1; i >= 0; i--) { // later-added plugins take precedence\n            var def = defs[i];\n            var meta = def.parseMeta(raw);\n            if (meta) {\n                var res = parseEventSourceProps(typeof raw === 'object' ? raw : {}, meta, i, calendar);\n                res._raw = freezeRaw(raw);\n                return res;\n            }\n        }\n        return null;\n    }\n    function parseEventSourceProps(raw, meta, sourceDefId, calendar) {\n        var leftovers0 = {};\n        var props = refineProps(raw, SIMPLE_SOURCE_PROPS, {}, leftovers0);\n        var leftovers1 = {};\n        var ui = processUnscopedUiProps(leftovers0, calendar, leftovers1);\n        props.isFetching = false;\n        props.latestFetchId = '';\n        props.fetchRange = null;\n        props.publicId = String(raw.id || '');\n        props.sourceId = String(uid$2++);\n        props.sourceDefId = sourceDefId;\n        props.meta = meta;\n        props.ui = ui;\n        props.extendedProps = leftovers1;\n        return props;\n    }\n\n    function reduceEventSources (eventSources, action, dateProfile, calendar) {\n        switch (action.type) {\n            case 'ADD_EVENT_SOURCES': // already parsed\n                return addSources(eventSources, action.sources, dateProfile ? dateProfile.activeRange : null, calendar);\n            case 'REMOVE_EVENT_SOURCE':\n                return removeSource(eventSources, action.sourceId);\n            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n            case 'NEXT':\n            case 'SET_DATE':\n            case 'SET_VIEW_TYPE':\n                if (dateProfile) {\n                    return fetchDirtySources(eventSources, dateProfile.activeRange, calendar);\n                }\n                else {\n                    return eventSources;\n                }\n            case 'FETCH_EVENT_SOURCES':\n            case 'CHANGE_TIMEZONE':\n                return fetchSourcesByIds(eventSources, action.sourceIds ?\n                    arrayToHash(action.sourceIds) :\n                    excludeStaticSources(eventSources, calendar), dateProfile ? dateProfile.activeRange : null, calendar);\n            case 'RECEIVE_EVENTS':\n            case 'RECEIVE_EVENT_ERROR':\n                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return {};\n            default:\n                return eventSources;\n        }\n    }\n    var uid$3 = 0;\n    function addSources(eventSourceHash, sources, fetchRange, calendar) {\n        var hash = {};\n        for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n            var source = sources_1[_i];\n            hash[source.sourceId] = source;\n        }\n        if (fetchRange) {\n            hash = fetchDirtySources(hash, fetchRange, calendar);\n        }\n        return __assign({}, eventSourceHash, hash);\n    }\n    function removeSource(eventSourceHash, sourceId) {\n        return filterHash(eventSourceHash, function (eventSource) {\n            return eventSource.sourceId !== sourceId;\n        });\n    }\n    function fetchDirtySources(sourceHash, fetchRange, calendar) {\n        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n            return isSourceDirty(eventSource, fetchRange, calendar);\n        }), fetchRange, calendar);\n    }\n    function isSourceDirty(eventSource, fetchRange, calendar) {\n        if (!doesSourceNeedRange(eventSource, calendar)) {\n            return !eventSource.latestFetchId;\n        }\n        else {\n            return !calendar.opt('lazyFetching') ||\n                !eventSource.fetchRange ||\n                fetchRange.start < eventSource.fetchRange.start ||\n                fetchRange.end > eventSource.fetchRange.end;\n        }\n    }\n    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, calendar) {\n        var nextSources = {};\n        for (var sourceId in prevSources) {\n            var source = prevSources[sourceId];\n            if (sourceIdHash[sourceId]) {\n                nextSources[sourceId] = fetchSource(source, fetchRange, calendar);\n            }\n            else {\n                nextSources[sourceId] = source;\n            }\n        }\n        return nextSources;\n    }\n    function fetchSource(eventSource, fetchRange, calendar) {\n        var sourceDef = calendar.pluginSystem.hooks.eventSourceDefs[eventSource.sourceDefId];\n        var fetchId = String(uid$3++);\n        sourceDef.fetch({\n            eventSource: eventSource,\n            calendar: calendar,\n            range: fetchRange\n        }, function (res) {\n            var rawEvents = res.rawEvents;\n            var calSuccess = calendar.opt('eventSourceSuccess');\n            var calSuccessRes;\n            var sourceSuccessRes;\n            if (eventSource.success) {\n                sourceSuccessRes = eventSource.success(rawEvents, res.xhr);\n            }\n            if (calSuccess) {\n                calSuccessRes = calSuccess(rawEvents, res.xhr);\n            }\n            rawEvents = sourceSuccessRes || calSuccessRes || rawEvents;\n            calendar.dispatch({\n                type: 'RECEIVE_EVENTS',\n                sourceId: eventSource.sourceId,\n                fetchId: fetchId,\n                fetchRange: fetchRange,\n                rawEvents: rawEvents\n            });\n        }, function (error) {\n            var callFailure = calendar.opt('eventSourceFailure');\n            console.warn(error.message, error);\n            if (eventSource.failure) {\n                eventSource.failure(error);\n            }\n            if (callFailure) {\n                callFailure(error);\n            }\n            calendar.dispatch({\n                type: 'RECEIVE_EVENT_ERROR',\n                sourceId: eventSource.sourceId,\n                fetchId: fetchId,\n                fetchRange: fetchRange,\n                error: error\n            });\n        });\n        return __assign({}, eventSource, { isFetching: true, latestFetchId: fetchId });\n    }\n    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n        var _a;\n        var eventSource = sourceHash[sourceId];\n        if (eventSource && // not already removed\n            fetchId === eventSource.latestFetchId) {\n            return __assign({}, sourceHash, (_a = {}, _a[sourceId] = __assign({}, eventSource, { isFetching: false, fetchRange: fetchRange }), _a));\n        }\n        return sourceHash;\n    }\n    function excludeStaticSources(eventSources, calendar) {\n        return filterHash(eventSources, function (eventSource) {\n            return doesSourceNeedRange(eventSource, calendar);\n        });\n    }\n\n    var DateProfileGenerator = /** @class */ (function () {\n        function DateProfileGenerator(viewSpec, calendar) {\n            this.viewSpec = viewSpec;\n            this.options = viewSpec.options;\n            this.dateEnv = calendar.dateEnv;\n            this.calendar = calendar;\n            this.initHiddenDays();\n        }\n        /* Date Range Computation\n        ------------------------------------------------------------------------------------------------------------------*/\n        // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n        DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate) {\n            var dateEnv = this.dateEnv;\n            var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n            currentDateProfile.dateIncrement);\n            return this.build(prevDate, -1);\n        };\n        // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n        DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate) {\n            var dateEnv = this.dateEnv;\n            var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n            currentDateProfile.dateIncrement);\n            return this.build(nextDate, 1);\n        };\n        // Builds a structure holding dates/ranges for rendering around the given date.\n        // Optional direction param indicates whether the date is being incremented/decremented\n        // from its previous value. decremented = -1, incremented = 1 (default).\n        DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n            if (forceToValid === void 0) { forceToValid = false; }\n            var validRange;\n            var minTime = null;\n            var maxTime = null;\n            var currentInfo;\n            var isRangeAllDay;\n            var renderRange;\n            var activeRange;\n            var isValid;\n            validRange = this.buildValidRange();\n            validRange = this.trimHiddenDays(validRange);\n            if (forceToValid) {\n                currentDate = constrainMarkerToRange(currentDate, validRange);\n            }\n            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n            renderRange = this.trimHiddenDays(renderRange);\n            activeRange = renderRange;\n            if (!this.options.showNonCurrentDates) {\n                activeRange = intersectRanges(activeRange, currentInfo.range);\n            }\n            minTime = createDuration(this.options.minTime);\n            maxTime = createDuration(this.options.maxTime);\n            activeRange = this.adjustActiveRange(activeRange, minTime, maxTime);\n            activeRange = intersectRanges(activeRange, validRange); // might return null\n            // it's invalid if the originally requested date is not contained,\n            // or if the range is completely outside of the valid range.\n            isValid = rangesIntersect(currentInfo.range, validRange);\n            return {\n                // constraint for where prev/next operations can go and where events can be dragged/resized to.\n                // an object with optional start and end properties.\n                validRange: validRange,\n                // range the view is formally responsible for.\n                // for example, a month view might have 1st-31st, excluding padded dates\n                currentRange: currentInfo.range,\n                // name of largest unit being displayed, like \"month\" or \"week\"\n                currentRangeUnit: currentInfo.unit,\n                isRangeAllDay: isRangeAllDay,\n                // dates that display events and accept drag-n-drop\n                // will be `null` if no dates accept events\n                activeRange: activeRange,\n                // date range with a rendered skeleton\n                // includes not-active days that need some sort of DOM\n                renderRange: renderRange,\n                // Duration object that denotes the first visible time of any given day\n                minTime: minTime,\n                // Duration object that denotes the exclusive visible end time of any given day\n                maxTime: maxTime,\n                isValid: isValid,\n                // how far the current date will move for a prev/next operation\n                dateIncrement: this.buildDateIncrement(currentInfo.duration)\n                // pass a fallback (might be null) ^\n            };\n        };\n        // Builds an object with optional start/end properties.\n        // Indicates the minimum/maximum dates to display.\n        // not responsible for trimming hidden days.\n        DateProfileGenerator.prototype.buildValidRange = function () {\n            return this.getRangeOption('validRange', this.calendar.getNow()) ||\n                { start: null, end: null }; // completely open-ended\n        };\n        // Builds a structure with info about the \"current\" range, the range that is\n        // highlighted as being the current month for example.\n        // See build() for a description of `direction`.\n        // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n        DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n            var _a = this, viewSpec = _a.viewSpec, dateEnv = _a.dateEnv;\n            var duration = null;\n            var unit = null;\n            var range = null;\n            var dayCount;\n            if (viewSpec.duration) {\n                duration = viewSpec.duration;\n                unit = viewSpec.durationUnit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            else if ((dayCount = this.options.dayCount)) {\n                unit = 'day';\n                range = this.buildRangeFromDayCount(date, direction, dayCount);\n            }\n            else if ((range = this.buildCustomVisibleRange(date))) {\n                unit = dateEnv.greatestWholeUnit(range.start, range.end).unit;\n            }\n            else {\n                duration = this.getFallbackDuration();\n                unit = greatestDurationDenominator(duration).unit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            return { duration: duration, unit: unit, range: range };\n        };\n        DateProfileGenerator.prototype.getFallbackDuration = function () {\n            return createDuration({ day: 1 });\n        };\n        // Returns a new activeRange to have time values (un-ambiguate)\n        // minTime or maxTime causes the range to expand.\n        DateProfileGenerator.prototype.adjustActiveRange = function (range, minTime, maxTime) {\n            var dateEnv = this.dateEnv;\n            var start = range.start;\n            var end = range.end;\n            if (this.viewSpec.class.prototype.usesMinMaxTime) {\n                // expand active range if minTime is negative (why not when positive?)\n                if (asRoughDays(minTime) < 0) {\n                    start = startOfDay(start); // necessary?\n                    start = dateEnv.add(start, minTime);\n                }\n                // expand active range if maxTime is beyond one day (why not when positive?)\n                if (asRoughDays(maxTime) > 1) {\n                    end = startOfDay(end); // necessary?\n                    end = addDays(end, -1);\n                    end = dateEnv.add(end, maxTime);\n                }\n            }\n            return { start: start, end: end };\n        };\n        // Builds the \"current\" range when it is specified as an explicit duration.\n        // `unit` is the already-computed greatestDurationDenominator unit of duration.\n        DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n            var dateEnv = this.dateEnv;\n            var alignment = this.options.dateAlignment;\n            var dateIncrementInput;\n            var dateIncrementDuration;\n            var start;\n            var end;\n            var res;\n            // compute what the alignment should be\n            if (!alignment) {\n                dateIncrementInput = this.options.dateIncrement;\n                if (dateIncrementInput) {\n                    dateIncrementDuration = createDuration(dateIncrementInput);\n                    // use the smaller of the two units\n                    if (asRoughMs(dateIncrementDuration) < asRoughMs(duration)) {\n                        alignment = greatestDurationDenominator(dateIncrementDuration, !getWeeksFromInput(dateIncrementInput)).unit;\n                    }\n                    else {\n                        alignment = unit;\n                    }\n                }\n                else {\n                    alignment = unit;\n                }\n            }\n            // if the view displays a single day or smaller\n            if (asRoughDays(duration) <= 1) {\n                if (this.isHiddenDay(start)) {\n                    start = this.skipHiddenDays(start, direction);\n                    start = startOfDay(start);\n                }\n            }\n            function computeRes() {\n                start = dateEnv.startOf(date, alignment);\n                end = dateEnv.add(start, duration);\n                res = { start: start, end: end };\n            }\n            computeRes();\n            // if range is completely enveloped by hidden days, go past the hidden days\n            if (!this.trimHiddenDays(res)) {\n                date = this.skipHiddenDays(date, direction);\n                computeRes();\n            }\n            return res;\n        };\n        // Builds the \"current\" range when a dayCount is specified.\n        DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n            var dateEnv = this.dateEnv;\n            var customAlignment = this.options.dateAlignment;\n            var runningCount = 0;\n            var start = date;\n            var end;\n            if (customAlignment) {\n                start = dateEnv.startOf(start, customAlignment);\n            }\n            start = startOfDay(start);\n            start = this.skipHiddenDays(start, direction);\n            end = start;\n            do {\n                end = addDays(end, 1);\n                if (!this.isHiddenDay(end)) {\n                    runningCount++;\n                }\n            } while (runningCount < dayCount);\n            return { start: start, end: end };\n        };\n        // Builds a normalized range object for the \"visible\" range,\n        // which is a way to define the currentRange and activeRange at the same time.\n        DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n            var dateEnv = this.dateEnv;\n            var visibleRange = this.getRangeOption('visibleRange', dateEnv.toDate(date));\n            if (visibleRange && (visibleRange.start == null || visibleRange.end == null)) {\n                return null;\n            }\n            return visibleRange;\n        };\n        // Computes the range that will represent the element/cells for *rendering*,\n        // but which may have voided days/times.\n        // not responsible for trimming hidden days.\n        DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n            return currentRange;\n        };\n        // Compute the duration value that should be added/substracted to the current date\n        // when a prev/next operation happens.\n        DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n            var dateIncrementInput = this.options.dateIncrement;\n            var customAlignment;\n            if (dateIncrementInput) {\n                return createDuration(dateIncrementInput);\n            }\n            else if ((customAlignment = this.options.dateAlignment)) {\n                return createDuration(1, customAlignment);\n            }\n            else if (fallback) {\n                return fallback;\n            }\n            else {\n                return createDuration({ days: 1 });\n            }\n        };\n        // Arguments after name will be forwarded to a hypothetical function value\n        // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\n        // Always clone your objects if you fear mutation.\n        DateProfileGenerator.prototype.getRangeOption = function (name) {\n            var otherArgs = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                otherArgs[_i - 1] = arguments[_i];\n            }\n            var val = this.options[name];\n            if (typeof val === 'function') {\n                val = val.apply(null, otherArgs);\n            }\n            if (val) {\n                val = parseRange(val, this.dateEnv);\n            }\n            if (val) {\n                val = computeVisibleDayRange(val);\n            }\n            return val;\n        };\n        /* Hidden Days\n        ------------------------------------------------------------------------------------------------------------------*/\n        // Initializes internal variables related to calculating hidden days-of-week\n        DateProfileGenerator.prototype.initHiddenDays = function () {\n            var hiddenDays = this.options.hiddenDays || []; // array of day-of-week indices that are hidden\n            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n            var dayCnt = 0;\n            var i;\n            if (this.options.weekends === false) {\n                hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n            }\n            for (i = 0; i < 7; i++) {\n                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                    dayCnt++;\n                }\n            }\n            if (!dayCnt) {\n                throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n            }\n            this.isHiddenDayHash = isHiddenDayHash;\n        };\n        // Remove days from the beginning and end of the range that are computed as hidden.\n        // If the whole range is trimmed off, returns null\n        DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n            var start = range.start;\n            var end = range.end;\n            if (start) {\n                start = this.skipHiddenDays(start);\n            }\n            if (end) {\n                end = this.skipHiddenDays(end, -1, true);\n            }\n            if (start == null || end == null || start < end) {\n                return { start: start, end: end };\n            }\n            return null;\n        };\n        // Is the current day hidden?\n        // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n        DateProfileGenerator.prototype.isHiddenDay = function (day) {\n            if (day instanceof Date) {\n                day = day.getUTCDay();\n            }\n            return this.isHiddenDayHash[day];\n        };\n        // Incrementing the current day until it is no longer a hidden day, returning a copy.\n        // DOES NOT CONSIDER validRange!\n        // If the initial value of `date` is not a hidden day, don't do anything.\n        // Pass `isExclusive` as `true` if you are dealing with an end date.\n        // `inc` defaults to `1` (increment one day forward each time)\n        DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n            if (inc === void 0) { inc = 1; }\n            if (isExclusive === void 0) { isExclusive = false; }\n            while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n                date = addDays(date, inc);\n            }\n            return date;\n        };\n        return DateProfileGenerator;\n    }());\n    // TODO: find a way to avoid comparing DateProfiles. it's tedious\n    function isDateProfilesEqual(p0, p1) {\n        return rangesEqual(p0.activeRange, p1.activeRange) &&\n            rangesEqual(p0.validRange, p1.validRange) &&\n            durationsEqual(p0.minTime, p1.minTime) &&\n            durationsEqual(p0.maxTime, p1.maxTime);\n    }\n\n    function reduce (state, action, calendar) {\n        var viewType = reduceViewType(state.viewType, action);\n        var dateProfile = reduceDateProfile(state.dateProfile, action, state.currentDate, viewType, calendar);\n        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendar);\n        var nextState = __assign({}, state, { viewType: viewType,\n            dateProfile: dateProfile, currentDate: reduceCurrentDate(state.currentDate, action, dateProfile), eventSources: eventSources, eventStore: reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendar), dateSelection: reduceDateSelection(state.dateSelection, action, calendar), eventSelection: reduceSelectedEvent(state.eventSelection, action), eventDrag: reduceEventDrag(state.eventDrag, action, eventSources, calendar), eventResize: reduceEventResize(state.eventResize, action, eventSources, calendar), eventSourceLoadingLevel: computeLoadingLevel(eventSources), loadingLevel: computeLoadingLevel(eventSources) });\n        for (var _i = 0, _a = calendar.pluginSystem.hooks.reducers; _i < _a.length; _i++) {\n            var reducerFunc = _a[_i];\n            nextState = reducerFunc(nextState, action, calendar);\n        }\n        // console.log(action.type, nextState)\n        return nextState;\n    }\n    function reduceViewType(currentViewType, action) {\n        switch (action.type) {\n            case 'SET_VIEW_TYPE':\n                return action.viewType;\n            default:\n                return currentViewType;\n        }\n    }\n    function reduceDateProfile(currentDateProfile, action, currentDate, viewType, calendar) {\n        var newDateProfile;\n        switch (action.type) {\n            case 'PREV':\n                newDateProfile = calendar.dateProfileGenerators[viewType].buildPrev(currentDateProfile, currentDate);\n                break;\n            case 'NEXT':\n                newDateProfile = calendar.dateProfileGenerators[viewType].buildNext(currentDateProfile, currentDate);\n                break;\n            case 'SET_DATE':\n                if (!currentDateProfile.activeRange ||\n                    !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker)) {\n                    newDateProfile = calendar.dateProfileGenerators[viewType].build(action.dateMarker, undefined, true // forceToValid\n                    );\n                }\n                break;\n            case 'SET_VIEW_TYPE':\n                var generator = calendar.dateProfileGenerators[viewType];\n                if (!generator) {\n                    throw new Error(viewType ?\n                        'The FullCalendar view \"' + viewType + '\" does not exist. Make sure your plugins are loaded correctly.' :\n                        'No available FullCalendar view plugins.');\n                }\n                newDateProfile = generator.build(action.dateMarker || currentDate, undefined, true // forceToValid\n                );\n                break;\n        }\n        if (newDateProfile &&\n            newDateProfile.isValid &&\n            !(currentDateProfile && isDateProfilesEqual(currentDateProfile, newDateProfile))) {\n            return newDateProfile;\n        }\n        else {\n            return currentDateProfile;\n        }\n    }\n    function reduceCurrentDate(currentDate, action, dateProfile) {\n        switch (action.type) {\n            case 'PREV':\n            case 'NEXT':\n                if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n                    return dateProfile.currentRange.start;\n                }\n                else {\n                    return currentDate;\n                }\n            case 'SET_DATE':\n            case 'SET_VIEW_TYPE':\n                var newDate = action.dateMarker || currentDate;\n                if (dateProfile.activeRange && !rangeContainsMarker(dateProfile.activeRange, newDate)) {\n                    return dateProfile.currentRange.start;\n                }\n                else {\n                    return newDate;\n                }\n            default:\n                return currentDate;\n        }\n    }\n    function reduceDateSelection(currentSelection, action, calendar) {\n        switch (action.type) {\n            case 'SELECT_DATES':\n                return action.selection;\n            case 'UNSELECT_DATES':\n                return null;\n            default:\n                return currentSelection;\n        }\n    }\n    function reduceSelectedEvent(currentInstanceId, action) {\n        switch (action.type) {\n            case 'SELECT_EVENT':\n                return action.eventInstanceId;\n            case 'UNSELECT_EVENT':\n                return '';\n            default:\n                return currentInstanceId;\n        }\n    }\n    function reduceEventDrag(currentDrag, action, sources, calendar) {\n        switch (action.type) {\n            case 'SET_EVENT_DRAG':\n                var newDrag = action.state;\n                return {\n                    affectedEvents: newDrag.affectedEvents,\n                    mutatedEvents: newDrag.mutatedEvents,\n                    isEvent: newDrag.isEvent,\n                    origSeg: newDrag.origSeg\n                };\n            case 'UNSET_EVENT_DRAG':\n                return null;\n            default:\n                return currentDrag;\n        }\n    }\n    function reduceEventResize(currentResize, action, sources, calendar) {\n        switch (action.type) {\n            case 'SET_EVENT_RESIZE':\n                var newResize = action.state;\n                return {\n                    affectedEvents: newResize.affectedEvents,\n                    mutatedEvents: newResize.mutatedEvents,\n                    isEvent: newResize.isEvent,\n                    origSeg: newResize.origSeg\n                };\n            case 'UNSET_EVENT_RESIZE':\n                return null;\n            default:\n                return currentResize;\n        }\n    }\n    function computeLoadingLevel(eventSources) {\n        var cnt = 0;\n        for (var sourceId in eventSources) {\n            if (eventSources[sourceId].isFetching) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n\n    var STANDARD_PROPS = {\n        start: null,\n        end: null,\n        allDay: Boolean\n    };\n    function parseDateSpan(raw, dateEnv, defaultDuration) {\n        var span = parseOpenDateSpan(raw, dateEnv);\n        var range = span.range;\n        if (!range.start) {\n            return null;\n        }\n        if (!range.end) {\n            if (defaultDuration == null) {\n                return null;\n            }\n            else {\n                range.end = dateEnv.add(range.start, defaultDuration);\n            }\n        }\n        return span;\n    }\n    /*\n    TODO: somehow combine with parseRange?\n    Will return null if the start/end props were present but parsed invalidly.\n    */\n    function parseOpenDateSpan(raw, dateEnv) {\n        var leftovers = {};\n        var standardProps = refineProps(raw, STANDARD_PROPS, {}, leftovers);\n        var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n        var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n        var allDay = standardProps.allDay;\n        if (allDay == null) {\n            allDay = (startMeta && startMeta.isTimeUnspecified) &&\n                (!endMeta || endMeta.isTimeUnspecified);\n        }\n        // use this leftover object as the selection object\n        leftovers.range = {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        };\n        leftovers.allDay = allDay;\n        return leftovers;\n    }\n    function isDateSpansEqual(span0, span1) {\n        return rangesEqual(span0.range, span1.range) &&\n            span0.allDay === span1.allDay &&\n            isSpanPropsEqual(span0, span1);\n    }\n    // the NON-DATE-RELATED props\n    function isSpanPropsEqual(span0, span1) {\n        for (var propName in span1) {\n            if (propName !== 'range' && propName !== 'allDay') {\n                if (span0[propName] !== span1[propName]) {\n                    return false;\n                }\n            }\n        }\n        // are there any props that span0 has that span1 DOESN'T have?\n        // both have range/allDay, so no need to special-case.\n        for (var propName in span0) {\n            if (!(propName in span1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function buildDateSpanApi(span, dateEnv) {\n        return {\n            start: dateEnv.toDate(span.range.start),\n            end: dateEnv.toDate(span.range.end),\n            startStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),\n            endStr: dateEnv.formatIso(span.range.end, { omitTime: span.allDay }),\n            allDay: span.allDay\n        };\n    }\n    function buildDatePointApi(span, dateEnv) {\n        return {\n            date: dateEnv.toDate(span.range.start),\n            dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),\n            allDay: span.allDay\n        };\n    }\n    function fabricateEventRange(dateSpan, eventUiBases, calendar) {\n        var def = parseEventDef({ editable: false }, '', // sourceId\n        dateSpan.allDay, true, // hasEnd\n        calendar);\n        return {\n            def: def,\n            ui: compileEventUi(def, eventUiBases),\n            instance: createEventInstance(def.defId, dateSpan.range),\n            range: dateSpan.range,\n            isStart: true,\n            isEnd: true\n        };\n    }\n\n    function compileViewDefs(defaultConfigs, overrideConfigs) {\n        var hash = {};\n        var viewType;\n        for (viewType in defaultConfigs) {\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        for (viewType in overrideConfigs) {\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        return hash;\n    }\n    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        if (hash[viewType]) {\n            return hash[viewType];\n        }\n        var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        if (viewDef) {\n            hash[viewType] = viewDef;\n        }\n        return viewDef;\n    }\n    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        var defaultConfig = defaultConfigs[viewType];\n        var overrideConfig = overrideConfigs[viewType];\n        var queryProp = function (name) {\n            return (defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :\n                ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null);\n        };\n        var theClass = queryProp('class');\n        var superType = queryProp('superType');\n        if (!superType && theClass) {\n            superType =\n                findViewNameBySubclass(theClass, overrideConfigs) ||\n                    findViewNameBySubclass(theClass, defaultConfigs);\n        }\n        var superDef = superType ? ensureViewDef(superType, hash, defaultConfigs, overrideConfigs) : null;\n        if (!theClass && superDef) {\n            theClass = superDef.class;\n        }\n        if (!theClass) {\n            return null; // don't throw a warning, might be settings for a single-unit view\n        }\n        return {\n            type: viewType,\n            class: theClass,\n            defaults: __assign({}, (superDef ? superDef.defaults : {}), (defaultConfig ? defaultConfig.options : {})),\n            overrides: __assign({}, (superDef ? superDef.overrides : {}), (overrideConfig ? overrideConfig.options : {}))\n        };\n    }\n    function findViewNameBySubclass(viewSubclass, configs) {\n        var superProto = Object.getPrototypeOf(viewSubclass.prototype);\n        for (var viewType in configs) {\n            var parsed = configs[viewType];\n            // need DIRECT subclass, so instanceof won't do it\n            if (parsed.class && parsed.class.prototype === superProto) {\n                return viewType;\n            }\n        }\n        return '';\n    }\n\n    function parseViewConfigs(inputs) {\n        return mapHash(inputs, parseViewConfig);\n    }\n    var VIEW_DEF_PROPS = {\n        type: String,\n        class: null\n    };\n    function parseViewConfig(input) {\n        if (typeof input === 'function') {\n            input = { class: input };\n        }\n        var options = {};\n        var props = refineProps(input, VIEW_DEF_PROPS, {}, options);\n        return {\n            superType: props.type,\n            class: props.class,\n            options: options\n        };\n    }\n\n    function buildViewSpecs(defaultInputs, optionsManager) {\n        var defaultConfigs = parseViewConfigs(defaultInputs);\n        var overrideConfigs = parseViewConfigs(optionsManager.overrides.views);\n        var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n        return mapHash(viewDefs, function (viewDef) {\n            return buildViewSpec(viewDef, overrideConfigs, optionsManager);\n        });\n    }\n    function buildViewSpec(viewDef, overrideConfigs, optionsManager) {\n        var durationInput = viewDef.overrides.duration ||\n            viewDef.defaults.duration ||\n            optionsManager.dynamicOverrides.duration ||\n            optionsManager.overrides.duration;\n        var duration = null;\n        var durationUnit = '';\n        var singleUnit = '';\n        var singleUnitOverrides = {};\n        if (durationInput) {\n            duration = createDuration(durationInput);\n            if (duration) { // valid?\n                var denom = greatestDurationDenominator(duration, !getWeeksFromInput(durationInput));\n                durationUnit = denom.unit;\n                if (denom.value === 1) {\n                    singleUnit = durationUnit;\n                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].options : {};\n                }\n            }\n        }\n        var queryButtonText = function (options) {\n            var buttonTextMap = options.buttonText || {};\n            var buttonTextKey = viewDef.defaults.buttonTextKey;\n            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n                return buttonTextMap[buttonTextKey];\n            }\n            if (buttonTextMap[viewDef.type] != null) {\n                return buttonTextMap[viewDef.type];\n            }\n            if (buttonTextMap[singleUnit] != null) {\n                return buttonTextMap[singleUnit];\n            }\n        };\n        return {\n            type: viewDef.type,\n            class: viewDef.class,\n            duration: duration,\n            durationUnit: durationUnit,\n            singleUnit: singleUnit,\n            options: __assign({}, globalDefaults, viewDef.defaults, optionsManager.dirDefaults, optionsManager.localeDefaults, optionsManager.overrides, singleUnitOverrides, viewDef.overrides, optionsManager.dynamicOverrides),\n            buttonTextOverride: queryButtonText(optionsManager.dynamicOverrides) ||\n                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence\n                viewDef.overrides.buttonText,\n            buttonTextDefault: queryButtonText(optionsManager.localeDefaults) ||\n                queryButtonText(optionsManager.dirDefaults) ||\n                viewDef.defaults.buttonText ||\n                queryButtonText(globalDefaults) ||\n                viewDef.type // fall back to given view name\n        };\n    }\n\n    var Toolbar = /** @class */ (function (_super) {\n        __extends(Toolbar, _super);\n        function Toolbar(context, extraClassName) {\n            var _this = _super.call(this, context) || this;\n            _this._renderLayout = memoizeRendering(_this.renderLayout, _this.unrenderLayout);\n            _this._updateTitle = memoizeRendering(_this.updateTitle, null, [_this._renderLayout]);\n            _this._updateActiveButton = memoizeRendering(_this.updateActiveButton, null, [_this._renderLayout]);\n            _this._updateToday = memoizeRendering(_this.updateToday, null, [_this._renderLayout]);\n            _this._updatePrev = memoizeRendering(_this.updatePrev, null, [_this._renderLayout]);\n            _this._updateNext = memoizeRendering(_this.updateNext, null, [_this._renderLayout]);\n            _this.el = createElement('div', { className: 'fc-toolbar ' + extraClassName });\n            return _this;\n        }\n        Toolbar.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this._renderLayout.unrender(); // should unrender everything else\n            removeElement(this.el);\n        };\n        Toolbar.prototype.render = function (props) {\n            this._renderLayout(props.layout);\n            this._updateTitle(props.title);\n            this._updateActiveButton(props.activeButton);\n            this._updateToday(props.isTodayEnabled);\n            this._updatePrev(props.isPrevEnabled);\n            this._updateNext(props.isNextEnabled);\n        };\n        Toolbar.prototype.renderLayout = function (layout) {\n            var el = this.el;\n            this.viewsWithButtons = [];\n            appendToElement(el, this.renderSection('left', layout.left));\n            appendToElement(el, this.renderSection('center', layout.center));\n            appendToElement(el, this.renderSection('right', layout.right));\n        };\n        Toolbar.prototype.unrenderLayout = function () {\n            this.el.innerHTML = '';\n        };\n        Toolbar.prototype.renderSection = function (position, buttonStr) {\n            var _this = this;\n            var _a = this, theme = _a.theme, calendar = _a.calendar;\n            var optionsManager = calendar.optionsManager;\n            var viewSpecs = calendar.viewSpecs;\n            var sectionEl = createElement('div', { className: 'fc-' + position });\n            var calendarCustomButtons = optionsManager.computed.customButtons || {};\n            var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};\n            var calendarButtonText = optionsManager.computed.buttonText || {};\n            if (buttonStr) {\n                buttonStr.split(' ').forEach(function (buttonGroupStr, i) {\n                    var groupChildren = [];\n                    var isOnlyButtons = true;\n                    var groupEl;\n                    buttonGroupStr.split(',').forEach(function (buttonName, j) {\n                        var customButtonProps;\n                        var viewSpec;\n                        var buttonClick;\n                        var buttonIcon; // only one of these will be set\n                        var buttonText; // \"\n                        var buttonInnerHtml;\n                        var buttonClasses;\n                        var buttonEl;\n                        var buttonAriaAttr;\n                        if (buttonName === 'title') {\n                            groupChildren.push(htmlToElement('<h2>&nbsp;</h2>')); // we always want it to take up height\n                            isOnlyButtons = false;\n                        }\n                        else {\n                            if ((customButtonProps = calendarCustomButtons[buttonName])) {\n                                buttonClick = function (ev) {\n                                    if (customButtonProps.click) {\n                                        customButtonProps.click.call(buttonEl, ev);\n                                    }\n                                };\n                                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\n                                    (buttonIcon = theme.getIconClass(buttonName)) ||\n                                    (buttonText = customButtonProps.text);\n                            }\n                            else if ((viewSpec = viewSpecs[buttonName])) {\n                                _this.viewsWithButtons.push(buttonName);\n                                buttonClick = function () {\n                                    calendar.changeView(buttonName);\n                                };\n                                (buttonText = viewSpec.buttonTextOverride) ||\n                                    (buttonIcon = theme.getIconClass(buttonName)) ||\n                                    (buttonText = viewSpec.buttonTextDefault);\n                            }\n                            else if (calendar[buttonName]) { // a calendar method\n                                buttonClick = function () {\n                                    calendar[buttonName]();\n                                };\n                                (buttonText = calendarButtonTextOverrides[buttonName]) ||\n                                    (buttonIcon = theme.getIconClass(buttonName)) ||\n                                    (buttonText = calendarButtonText[buttonName]);\n                                //            ^ everything else is considered default\n                            }\n                            if (buttonClick) {\n                                buttonClasses = [\n                                    'fc-' + buttonName + '-button',\n                                    theme.getClass('button')\n                                ];\n                                if (buttonText) {\n                                    buttonInnerHtml = htmlEscape(buttonText);\n                                    buttonAriaAttr = '';\n                                }\n                                else if (buttonIcon) {\n                                    buttonInnerHtml = \"<span class='\" + buttonIcon + \"'></span>\";\n                                    buttonAriaAttr = ' aria-label=\"' + buttonName + '\"';\n                                }\n                                buttonEl = htmlToElement(// type=\"button\" so that it doesn't submit a form\n                                '<button type=\"button\" class=\"' + buttonClasses.join(' ') + '\"' +\n                                    buttonAriaAttr +\n                                    '>' + buttonInnerHtml + '</button>');\n                                buttonEl.addEventListener('click', buttonClick);\n                                groupChildren.push(buttonEl);\n                            }\n                        }\n                    });\n                    if (groupChildren.length > 1) {\n                        groupEl = document.createElement('div');\n                        var buttonGroupClassName = theme.getClass('buttonGroup');\n                        if (isOnlyButtons && buttonGroupClassName) {\n                            groupEl.classList.add(buttonGroupClassName);\n                        }\n                        appendToElement(groupEl, groupChildren);\n                        sectionEl.appendChild(groupEl);\n                    }\n                    else {\n                        appendToElement(sectionEl, groupChildren); // 1 or 0 children\n                    }\n                });\n            }\n            return sectionEl;\n        };\n        Toolbar.prototype.updateToday = function (isTodayEnabled) {\n            this.toggleButtonEnabled('today', isTodayEnabled);\n        };\n        Toolbar.prototype.updatePrev = function (isPrevEnabled) {\n            this.toggleButtonEnabled('prev', isPrevEnabled);\n        };\n        Toolbar.prototype.updateNext = function (isNextEnabled) {\n            this.toggleButtonEnabled('next', isNextEnabled);\n        };\n        Toolbar.prototype.updateTitle = function (text) {\n            findElements(this.el, 'h2').forEach(function (titleEl) {\n                titleEl.innerText = text;\n            });\n        };\n        Toolbar.prototype.updateActiveButton = function (buttonName) {\n            var className = this.theme.getClass('buttonActive');\n            findElements(this.el, 'button').forEach(function (buttonEl) {\n                if (buttonName && buttonEl.classList.contains('fc-' + buttonName + '-button')) {\n                    buttonEl.classList.add(className);\n                }\n                else {\n                    buttonEl.classList.remove(className);\n                }\n            });\n        };\n        Toolbar.prototype.toggleButtonEnabled = function (buttonName, bool) {\n            findElements(this.el, '.fc-' + buttonName + '-button').forEach(function (buttonEl) {\n                buttonEl.disabled = !bool;\n            });\n        };\n        return Toolbar;\n    }(Component));\n\n    var CalendarComponent = /** @class */ (function (_super) {\n        __extends(CalendarComponent, _super);\n        function CalendarComponent(context, el) {\n            var _this = _super.call(this, context) || this;\n            _this._renderToolbars = memoizeRendering(_this.renderToolbars);\n            _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n            _this.el = el;\n            prependToElement(el, _this.contentEl = createElement('div', { className: 'fc-view-container' }));\n            var calendar = _this.calendar;\n            for (var _i = 0, _a = calendar.pluginSystem.hooks.viewContainerModifiers; _i < _a.length; _i++) {\n                var modifyViewContainer = _a[_i];\n                modifyViewContainer(_this.contentEl, calendar);\n            }\n            _this.toggleElClassNames(true);\n            _this.computeTitle = memoize(computeTitle);\n            _this.parseBusinessHours = memoize(function (input) {\n                return parseBusinessHours(input, _this.calendar);\n            });\n            return _this;\n        }\n        CalendarComponent.prototype.destroy = function () {\n            if (this.header) {\n                this.header.destroy();\n            }\n            if (this.footer) {\n                this.footer.destroy();\n            }\n            if (this.view) {\n                this.view.destroy();\n            }\n            removeElement(this.contentEl);\n            this.toggleElClassNames(false);\n            _super.prototype.destroy.call(this);\n        };\n        CalendarComponent.prototype.toggleElClassNames = function (bool) {\n            var classList = this.el.classList;\n            var dirClassName = 'fc-' + this.opt('dir');\n            var themeClassName = this.theme.getClass('widget');\n            if (bool) {\n                classList.add('fc');\n                classList.add(dirClassName);\n                classList.add(themeClassName);\n            }\n            else {\n                classList.remove('fc');\n                classList.remove(dirClassName);\n                classList.remove(themeClassName);\n            }\n        };\n        CalendarComponent.prototype.render = function (props) {\n            this.freezeHeight();\n            var title = this.computeTitle(props.dateProfile, props.viewSpec.options);\n            this._renderToolbars(props.viewSpec, props.dateProfile, props.currentDate, props.dateProfileGenerator, title);\n            this.renderView(props, title);\n            this.updateSize();\n            this.thawHeight();\n        };\n        CalendarComponent.prototype.renderToolbars = function (viewSpec, dateProfile, currentDate, dateProfileGenerator, title) {\n            var headerLayout = this.opt('header');\n            var footerLayout = this.opt('footer');\n            var now = this.calendar.getNow();\n            var todayInfo = dateProfileGenerator.build(now);\n            var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate);\n            var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate);\n            var toolbarProps = {\n                title: title,\n                activeButton: viewSpec.type,\n                isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n                isPrevEnabled: prevInfo.isValid,\n                isNextEnabled: nextInfo.isValid\n            };\n            if (headerLayout) {\n                if (!this.header) {\n                    this.header = new Toolbar(this.context, 'fc-header-toolbar');\n                    prependToElement(this.el, this.header.el);\n                }\n                this.header.receiveProps(__assign({ layout: headerLayout }, toolbarProps));\n            }\n            else if (this.header) {\n                this.header.destroy();\n                this.header = null;\n            }\n            if (footerLayout) {\n                if (!this.footer) {\n                    this.footer = new Toolbar(this.context, 'fc-footer-toolbar');\n                    appendToElement(this.el, this.footer.el);\n                }\n                this.footer.receiveProps(__assign({ layout: footerLayout }, toolbarProps));\n            }\n            else if (this.footer) {\n                this.footer.destroy();\n                this.footer = null;\n            }\n        };\n        CalendarComponent.prototype.renderView = function (props, title) {\n            var view = this.view;\n            var viewSpec = props.viewSpec, dateProfileGenerator = props.dateProfileGenerator;\n            if (!view || view.viewSpec !== viewSpec) {\n                if (view) {\n                    view.destroy();\n                }\n                view = this.view = new viewSpec['class']({\n                    calendar: this.calendar,\n                    view: null,\n                    dateEnv: this.dateEnv,\n                    theme: this.theme,\n                    options: viewSpec.options\n                }, viewSpec, dateProfileGenerator, this.contentEl);\n            }\n            else {\n                view.addScroll(view.queryScroll());\n            }\n            view.title = title; // for the API\n            var viewProps = {\n                dateProfile: props.dateProfile,\n                businessHours: this.parseBusinessHours(viewSpec.options.businessHours),\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                dateSelection: props.dateSelection,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize\n            };\n            var transformers = this.buildViewPropTransformers(this.calendar.pluginSystem.hooks.viewPropsTransformers);\n            for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n                var transformer = transformers_1[_i];\n                __assign(viewProps, transformer.transform(viewProps, viewSpec, props, view));\n            }\n            view.receiveProps(viewProps);\n        };\n        // Sizing\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarComponent.prototype.updateSize = function (isResize) {\n            if (isResize === void 0) { isResize = false; }\n            var view = this.view;\n            if (isResize) {\n                view.addScroll(view.queryScroll());\n            }\n            if (isResize || this.isHeightAuto == null) {\n                this.computeHeightVars();\n            }\n            view.updateSize(isResize, this.viewHeight, this.isHeightAuto);\n            view.updateNowIndicator(); // we need to guarantee this will run after updateSize\n            view.popScroll(isResize);\n        };\n        CalendarComponent.prototype.computeHeightVars = function () {\n            var calendar = this.calendar; // yuck. need to handle dynamic options\n            var heightInput = calendar.opt('height');\n            var contentHeightInput = calendar.opt('contentHeight');\n            this.isHeightAuto = heightInput === 'auto' || contentHeightInput === 'auto';\n            if (typeof contentHeightInput === 'number') { // exists and not 'auto'\n                this.viewHeight = contentHeightInput;\n            }\n            else if (typeof contentHeightInput === 'function') { // exists and is a function\n                this.viewHeight = contentHeightInput();\n            }\n            else if (typeof heightInput === 'number') { // exists and not 'auto'\n                this.viewHeight = heightInput - this.queryToolbarsHeight();\n            }\n            else if (typeof heightInput === 'function') { // exists and is a function\n                this.viewHeight = heightInput() - this.queryToolbarsHeight();\n            }\n            else if (heightInput === 'parent') { // set to height of parent element\n                this.viewHeight = this.el.parentNode.offsetHeight - this.queryToolbarsHeight();\n            }\n            else {\n                this.viewHeight = Math.round(this.contentEl.offsetWidth /\n                    Math.max(calendar.opt('aspectRatio'), .5));\n            }\n        };\n        CalendarComponent.prototype.queryToolbarsHeight = function () {\n            var height = 0;\n            if (this.header) {\n                height += computeHeightAndMargins(this.header.el);\n            }\n            if (this.footer) {\n                height += computeHeightAndMargins(this.footer.el);\n            }\n            return height;\n        };\n        // Height \"Freezing\"\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarComponent.prototype.freezeHeight = function () {\n            applyStyle(this.el, {\n                height: this.el.offsetHeight,\n                overflow: 'hidden'\n            });\n        };\n        CalendarComponent.prototype.thawHeight = function () {\n            applyStyle(this.el, {\n                height: '',\n                overflow: ''\n            });\n        };\n        return CalendarComponent;\n    }(Component));\n    // Title and Date Formatting\n    // -----------------------------------------------------------------------------------------------------------------\n    // Computes what the title at the top of the calendar should be for this view\n    function computeTitle(dateProfile, viewOptions) {\n        var range;\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n            range = dateProfile.currentRange;\n        }\n        else { // for day units or smaller, use the actual day range\n            range = dateProfile.activeRange;\n        }\n        return this.dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || computeTitleFormat(dateProfile), viewOptions.titleRangeSeparator), { isEndExclusive: dateProfile.isRangeAllDay });\n    }\n    // Generates the format string that should be used to generate the title for the current date range.\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n    function computeTitleFormat(dateProfile) {\n        var currentRangeUnit = dateProfile.currentRangeUnit;\n        if (currentRangeUnit === 'year') {\n            return { year: 'numeric' };\n        }\n        else if (currentRangeUnit === 'month') {\n            return { year: 'numeric', month: 'long' }; // like \"September 2014\"\n        }\n        else {\n            var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n            if (days !== null && days > 1) {\n                // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n                return { year: 'numeric', month: 'short', day: 'numeric' };\n            }\n            else {\n                // one day. longer, like \"September 9 2014\"\n                return { year: 'numeric', month: 'long', day: 'numeric' };\n            }\n        }\n    }\n    // Plugin\n    // -----------------------------------------------------------------------------------------------------------------\n    function buildViewPropTransformers(theClasses) {\n        return theClasses.map(function (theClass) {\n            return new theClass();\n        });\n    }\n\n    var Interaction = /** @class */ (function () {\n        function Interaction(settings) {\n            this.component = settings.component;\n        }\n        Interaction.prototype.destroy = function () {\n        };\n        return Interaction;\n    }());\n    function parseInteractionSettings(component, input) {\n        return {\n            component: component,\n            el: input.el,\n            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true\n        };\n    }\n    function interactionSettingsToStore(settings) {\n        var _a;\n        return _a = {},\n            _a[settings.component.uid] = settings,\n            _a;\n    }\n    // global state\n    var interactionSettingsStore = {};\n\n    /*\n    Detects when the user clicks on an event within a DateComponent\n    */\n    var EventClicking = /** @class */ (function (_super) {\n        __extends(EventClicking, _super);\n        function EventClicking(settings) {\n            var _this = _super.call(this, settings) || this;\n            _this.handleSegClick = function (ev, segEl) {\n                var component = _this.component;\n                var seg = getElSeg(segEl);\n                if (seg && // might be the <div> surrounding the more link\n                    component.isValidSegDownEl(ev.target)) {\n                    // our way to simulate a link click for elements that can't be <a> tags\n                    // grab before trigger fired in case trigger trashes DOM thru rerendering\n                    var hasUrlContainer = elementClosest(ev.target, '.fc-has-url');\n                    var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n                    component.publiclyTrigger('eventClick', [\n                        {\n                            el: segEl,\n                            event: new EventApi(component.calendar, seg.eventRange.def, seg.eventRange.instance),\n                            jsEvent: ev,\n                            view: component.view\n                        }\n                    ]);\n                    if (url && !ev.defaultPrevented) {\n                        window.location.href = url;\n                    }\n                }\n            };\n            var component = settings.component;\n            _this.destroy = listenBySelector(component.el, 'click', component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegClick);\n            return _this;\n        }\n        return EventClicking;\n    }(Interaction));\n\n    /*\n    Triggers events and adds/removes core classNames when the user's pointer\n    enters/leaves event-elements of a component.\n    */\n    var EventHovering = /** @class */ (function (_super) {\n        __extends(EventHovering, _super);\n        function EventHovering(settings) {\n            var _this = _super.call(this, settings) || this;\n            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n            _this.handleEventElRemove = function (el) {\n                if (el === _this.currentSegEl) {\n                    _this.handleSegLeave(null, _this.currentSegEl);\n                }\n            };\n            _this.handleSegEnter = function (ev, segEl) {\n                if (getElSeg(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper\n                    segEl.classList.add('fc-allow-mouse-resize');\n                    _this.currentSegEl = segEl;\n                    _this.triggerEvent('eventMouseEnter', ev, segEl);\n                }\n            };\n            _this.handleSegLeave = function (ev, segEl) {\n                if (_this.currentSegEl) {\n                    segEl.classList.remove('fc-allow-mouse-resize');\n                    _this.currentSegEl = null;\n                    _this.triggerEvent('eventMouseLeave', ev, segEl);\n                }\n            };\n            var component = settings.component;\n            _this.removeHoverListeners = listenToHoverBySelector(component.el, component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegEnter, _this.handleSegLeave);\n            component.calendar.on('eventElRemove', _this.handleEventElRemove);\n            return _this;\n        }\n        EventHovering.prototype.destroy = function () {\n            this.removeHoverListeners();\n            this.component.calendar.off('eventElRemove', this.handleEventElRemove);\n        };\n        EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n            var component = this.component;\n            var seg = getElSeg(segEl);\n            if (!ev || component.isValidSegDownEl(ev.target)) {\n                component.publiclyTrigger(publicEvName, [\n                    {\n                        el: segEl,\n                        event: new EventApi(this.component.calendar, seg.eventRange.def, seg.eventRange.instance),\n                        jsEvent: ev,\n                        view: component.view\n                    }\n                ]);\n            }\n        };\n        return EventHovering;\n    }(Interaction));\n\n    var StandardTheme = /** @class */ (function (_super) {\n        __extends(StandardTheme, _super);\n        function StandardTheme() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return StandardTheme;\n    }(Theme));\n    StandardTheme.prototype.classes = {\n        widget: 'fc-unthemed',\n        widgetHeader: 'fc-widget-header',\n        widgetContent: 'fc-widget-content',\n        buttonGroup: 'fc-button-group',\n        button: 'fc-button fc-button-primary',\n        buttonActive: 'fc-button-active',\n        popoverHeader: 'fc-widget-header',\n        popoverContent: 'fc-widget-content',\n        // day grid\n        headerRow: 'fc-widget-header',\n        dayRow: 'fc-widget-content',\n        // list view\n        listView: 'fc-widget-content'\n    };\n    StandardTheme.prototype.baseIconClass = 'fc-icon';\n    StandardTheme.prototype.iconClasses = {\n        close: 'fc-icon-x',\n        prev: 'fc-icon-chevron-left',\n        next: 'fc-icon-chevron-right',\n        prevYear: 'fc-icon-chevrons-left',\n        nextYear: 'fc-icon-chevrons-right'\n    };\n    StandardTheme.prototype.iconOverrideOption = 'buttonIcons';\n    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\n    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\n    var Calendar = /** @class */ (function () {\n        function Calendar(el, overrides) {\n            var _this = this;\n            this.parseRawLocales = memoize(parseRawLocales);\n            this.buildLocale = memoize(buildLocale);\n            this.buildDateEnv = memoize(buildDateEnv);\n            this.buildTheme = memoize(buildTheme);\n            this.buildEventUiSingleBase = memoize(this._buildEventUiSingleBase);\n            this.buildSelectionConfig = memoize(this._buildSelectionConfig);\n            this.buildEventUiBySource = memoizeOutput(buildEventUiBySource, isObjectsSimilar);\n            this.buildEventUiBases = memoize(buildEventUiBases);\n            this.interactionsStore = {};\n            this.actionQueue = [];\n            this.isReducing = false;\n            // isDisplaying: boolean = false // installed in DOM? accepting renders?\n            this.needsRerender = false; // needs a render?\n            this.needsFullRerender = false;\n            this.isRendering = false; // currently in the executeRender function?\n            this.renderingPauseDepth = 0;\n            this.buildDelayedRerender = memoize(buildDelayedRerender);\n            this.afterSizingTriggers = {};\n            this.isViewUpdated = false;\n            this.isDatesUpdated = false;\n            this.isEventsUpdated = false;\n            this.el = el;\n            this.optionsManager = new OptionsManager(overrides || {});\n            this.pluginSystem = new PluginSystem();\n            // only do once. don't do in handleOptions. because can't remove plugins\n            this.addPluginInputs(this.optionsManager.computed.plugins || []);\n            this.handleOptions(this.optionsManager.computed);\n            this.publiclyTrigger('_init'); // for tests\n            this.hydrate();\n            this.calendarInteractions = this.pluginSystem.hooks.calendarInteractions\n                .map(function (calendarInteractionClass) {\n                return new calendarInteractionClass(_this);\n            });\n        }\n        Calendar.prototype.addPluginInputs = function (pluginInputs) {\n            var pluginDefs = refinePluginDefs(pluginInputs);\n            for (var _i = 0, pluginDefs_1 = pluginDefs; _i < pluginDefs_1.length; _i++) {\n                var pluginDef = pluginDefs_1[_i];\n                this.pluginSystem.add(pluginDef);\n            }\n        };\n        Object.defineProperty(Calendar.prototype, \"view\", {\n            // public API\n            get: function () {\n                return this.component ? this.component.view : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Public API for rendering\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.render = function () {\n            if (!this.component) {\n                this.renderableEventStore = createEmptyEventStore();\n                this.bindHandlers();\n                this.executeRender();\n            }\n            else {\n                this.requestRerender(true);\n            }\n        };\n        Calendar.prototype.destroy = function () {\n            if (this.component) {\n                this.unbindHandlers();\n                this.component.destroy(); // don't null-out. in case API needs access\n                this.component = null; // umm ???\n                for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    interaction.destroy();\n                }\n                this.publiclyTrigger('_destroyed');\n            }\n        };\n        // Handlers\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.bindHandlers = function () {\n            var _this = this;\n            // event delegation for nav links\n            this.removeNavLinkListener = listenBySelector(this.el, 'click', 'a[data-goto]', function (ev, anchorEl) {\n                var gotoOptions = anchorEl.getAttribute('data-goto');\n                gotoOptions = gotoOptions ? JSON.parse(gotoOptions) : {};\n                var dateEnv = _this.dateEnv;\n                var dateMarker = dateEnv.createMarker(gotoOptions.date);\n                var viewType = gotoOptions.type;\n                // property like \"navLinkDayClick\". might be a string or a function\n                var customAction = _this.viewOpt('navLink' + capitaliseFirstLetter(viewType) + 'Click');\n                if (typeof customAction === 'function') {\n                    customAction(dateEnv.toDate(dateMarker), ev);\n                }\n                else {\n                    if (typeof customAction === 'string') {\n                        viewType = customAction;\n                    }\n                    _this.zoomTo(dateMarker, viewType);\n                }\n            });\n            if (this.opt('handleWindowResize')) {\n                window.addEventListener('resize', this.windowResizeProxy = debounce(// prevents rapid calls\n                this.windowResize.bind(this), this.opt('windowResizeDelay')));\n            }\n        };\n        Calendar.prototype.unbindHandlers = function () {\n            this.removeNavLinkListener();\n            if (this.windowResizeProxy) {\n                window.removeEventListener('resize', this.windowResizeProxy);\n                this.windowResizeProxy = null;\n            }\n        };\n        // Dispatcher\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.hydrate = function () {\n            var _this = this;\n            this.state = this.buildInitialState();\n            var rawSources = this.opt('eventSources') || [];\n            var singleRawSource = this.opt('events');\n            var sources = []; // parsed\n            if (singleRawSource) {\n                rawSources.unshift(singleRawSource);\n            }\n            for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n                var rawSource = rawSources_1[_i];\n                var source = parseEventSource(rawSource, this);\n                if (source) {\n                    sources.push(source);\n                }\n            }\n            this.batchRendering(function () {\n                _this.dispatch({ type: 'INIT' }); // pass in sources here?\n                _this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: sources });\n                _this.dispatch({\n                    type: 'SET_VIEW_TYPE',\n                    viewType: _this.opt('defaultView') || _this.pluginSystem.hooks.defaultView\n                });\n            });\n        };\n        Calendar.prototype.buildInitialState = function () {\n            return {\n                viewType: null,\n                loadingLevel: 0,\n                eventSourceLoadingLevel: 0,\n                currentDate: this.getInitialDate(),\n                dateProfile: null,\n                eventSources: {},\n                eventStore: createEmptyEventStore(),\n                dateSelection: null,\n                eventSelection: '',\n                eventDrag: null,\n                eventResize: null\n            };\n        };\n        Calendar.prototype.dispatch = function (action) {\n            this.actionQueue.push(action);\n            if (!this.isReducing) {\n                this.isReducing = true;\n                var oldState = this.state;\n                while (this.actionQueue.length) {\n                    this.state = this.reduce(this.state, this.actionQueue.shift(), this);\n                }\n                var newState = this.state;\n                this.isReducing = false;\n                if (!oldState.loadingLevel && newState.loadingLevel) {\n                    this.publiclyTrigger('loading', [true]);\n                }\n                else if (oldState.loadingLevel && !newState.loadingLevel) {\n                    this.publiclyTrigger('loading', [false]);\n                }\n                var view = this.component && this.component.view;\n                if (oldState.eventStore !== newState.eventStore || this.needsFullRerender) {\n                    if (oldState.eventStore) {\n                        this.isEventsUpdated = true;\n                    }\n                }\n                if (oldState.dateProfile !== newState.dateProfile || this.needsFullRerender) {\n                    if (oldState.dateProfile && view) { // why would view be null!?\n                        this.publiclyTrigger('datesDestroy', [\n                            {\n                                view: view,\n                                el: view.el\n                            }\n                        ]);\n                    }\n                    this.isDatesUpdated = true;\n                }\n                if (oldState.viewType !== newState.viewType || this.needsFullRerender) {\n                    if (oldState.viewType && view) { // why would view be null!?\n                        this.publiclyTrigger('viewSkeletonDestroy', [\n                            {\n                                view: view,\n                                el: view.el\n                            }\n                        ]);\n                    }\n                    this.isViewUpdated = true;\n                }\n                this.requestRerender();\n            }\n        };\n        Calendar.prototype.reduce = function (state, action, calendar) {\n            return reduce(state, action, calendar);\n        };\n        // Render Queue\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.requestRerender = function (needsFull) {\n            if (needsFull === void 0) { needsFull = false; }\n            this.needsRerender = true;\n            this.needsFullRerender = this.needsFullRerender || needsFull;\n            this.delayedRerender(); // will call a debounced-version of tryRerender\n        };\n        Calendar.prototype.tryRerender = function () {\n            if (this.component && // must be accepting renders\n                this.needsRerender && // indicates that a rerender was requested\n                !this.renderingPauseDepth && // not paused\n                !this.isRendering // not currently in the render loop\n            ) {\n                this.executeRender();\n            }\n        };\n        Calendar.prototype.batchRendering = function (func) {\n            this.renderingPauseDepth++;\n            func();\n            this.renderingPauseDepth--;\n            if (this.needsRerender) {\n                this.requestRerender();\n            }\n        };\n        // Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.executeRender = function () {\n            var needsFullRerender = this.needsFullRerender; // save before clearing\n            // clear these BEFORE the render so that new values will accumulate during render\n            this.needsRerender = false;\n            this.needsFullRerender = false;\n            this.isRendering = true;\n            this.renderComponent(needsFullRerender);\n            this.isRendering = false;\n            // received a rerender request while rendering\n            if (this.needsRerender) {\n                this.delayedRerender();\n            }\n        };\n        /*\n        don't call this directly. use executeRender instead\n        */\n        Calendar.prototype.renderComponent = function (needsFull) {\n            var _a = this, state = _a.state, component = _a.component;\n            var viewType = state.viewType;\n            var viewSpec = this.viewSpecs[viewType];\n            var savedScroll = (needsFull && component) ? component.view.queryScroll() : null;\n            if (!viewSpec) {\n                throw new Error(\"View type \\\"\" + viewType + \"\\\" is not valid\");\n            }\n            // if event sources are still loading and progressive rendering hasn't been enabled,\n            // keep rendering the last fully loaded set of events\n            var renderableEventStore = this.renderableEventStore =\n                (state.eventSourceLoadingLevel && !this.opt('progressiveEventRendering')) ?\n                    this.renderableEventStore :\n                    state.eventStore;\n            var eventUiSingleBase = this.buildEventUiSingleBase(viewSpec.options);\n            var eventUiBySource = this.buildEventUiBySource(state.eventSources);\n            var eventUiBases = this.eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n            if (needsFull || !component) {\n                if (component) {\n                    component.freezeHeight(); // next component will unfreeze it\n                    component.destroy();\n                }\n                component = this.component = new CalendarComponent({\n                    calendar: this,\n                    view: null,\n                    dateEnv: this.dateEnv,\n                    theme: this.theme,\n                    options: this.optionsManager.computed\n                }, this.el);\n            }\n            component.receiveProps(__assign({}, state, { viewSpec: viewSpec, dateProfile: state.dateProfile, dateProfileGenerator: this.dateProfileGenerators[viewType], eventStore: renderableEventStore, eventUiBases: eventUiBases, dateSelection: state.dateSelection, eventSelection: state.eventSelection, eventDrag: state.eventDrag, eventResize: state.eventResize }));\n            if (savedScroll) {\n                component.view.applyScroll(savedScroll, false);\n            }\n            if (this.isViewUpdated) {\n                this.isViewUpdated = false;\n                this.publiclyTrigger('viewSkeletonRender', [\n                    {\n                        view: component.view,\n                        el: component.view.el\n                    }\n                ]);\n            }\n            if (this.isDatesUpdated) {\n                this.isDatesUpdated = false;\n                this.publiclyTrigger('datesRender', [\n                    {\n                        view: component.view,\n                        el: component.view.el\n                    }\n                ]);\n            }\n            if (this.isEventsUpdated) {\n                this.isEventsUpdated = false;\n            }\n            this.releaseAfterSizingTriggers();\n        };\n        // Options\n        // -----------------------------------------------------------------------------------------------------------------\n        /*\n        Not meant for public API\n        */\n        Calendar.prototype.resetOptions = function (options) {\n            var _this = this;\n            var changeHandlers = this.pluginSystem.hooks.optionChangeHandlers;\n            var oldOptions = this.optionsManager.overrides;\n            var oldNormalOptions = {};\n            var normalOptions = {};\n            var specialOptions = {};\n            for (var name_1 in oldOptions) {\n                if (!changeHandlers[name_1]) {\n                    oldNormalOptions[name_1] = oldOptions[name_1];\n                }\n            }\n            for (var name_2 in options) {\n                if (changeHandlers[name_2]) {\n                    specialOptions[name_2] = options[name_2];\n                }\n                else {\n                    normalOptions[name_2] = options[name_2];\n                }\n            }\n            this.batchRendering(function () {\n                if (anyKeysRemoved(oldNormalOptions, normalOptions)) {\n                    _this.processOptions(options, 'reset');\n                }\n                else {\n                    _this.processOptions(computeChangedProps(oldNormalOptions, normalOptions));\n                }\n                // handle special options last\n                for (var name_3 in specialOptions) {\n                    changeHandlers[name_3](specialOptions[name_3], _this);\n                }\n            });\n        };\n        /*\n        Not meant for public API. Won't give the same precedence that setOption does\n        */\n        Calendar.prototype.setOptions = function (options) {\n            var _this = this;\n            var changeHandlers = this.pluginSystem.hooks.optionChangeHandlers;\n            var normalOptions = {};\n            var specialOptions = {};\n            for (var name_4 in options) {\n                if (changeHandlers[name_4]) {\n                    specialOptions[name_4] = options[name_4];\n                }\n                else {\n                    normalOptions[name_4] = options[name_4];\n                }\n            }\n            this.batchRendering(function () {\n                _this.processOptions(normalOptions);\n                // handle special options last\n                for (var name_5 in specialOptions) {\n                    changeHandlers[name_5](specialOptions[name_5], _this);\n                }\n            });\n        };\n        Calendar.prototype.processOptions = function (options, mode) {\n            var _this = this;\n            var oldDateEnv = this.dateEnv; // do this before handleOptions\n            var isTimeZoneDirty = false;\n            var isSizeDirty = false;\n            var anyDifficultOptions = false;\n            for (var name_6 in options) {\n                if (/^(height|contentHeight|aspectRatio)$/.test(name_6)) {\n                    isSizeDirty = true;\n                }\n                else if (/^(defaultDate|defaultView)$/.test(name_6)) ;\n                else {\n                    anyDifficultOptions = true;\n                    if (name_6 === 'timeZone') {\n                        isTimeZoneDirty = true;\n                    }\n                }\n            }\n            if (mode === 'reset') {\n                anyDifficultOptions = true;\n                this.optionsManager.reset(options);\n            }\n            else if (mode === 'dynamic') {\n                this.optionsManager.addDynamic(options); // takes higher precedence\n            }\n            else {\n                this.optionsManager.add(options);\n            }\n            if (anyDifficultOptions) {\n                this.handleOptions(this.optionsManager.computed); // only for \"difficult\" options\n                this.needsFullRerender = true;\n                this.batchRendering(function () {\n                    if (isTimeZoneDirty) {\n                        _this.dispatch({\n                            type: 'CHANGE_TIMEZONE',\n                            oldDateEnv: oldDateEnv\n                        });\n                    }\n                    /* HACK\n                    has the same effect as calling this.requestRerender(true)\n                    but recomputes the state's dateProfile\n                    */\n                    _this.dispatch({\n                        type: 'SET_VIEW_TYPE',\n                        viewType: _this.state.viewType\n                    });\n                });\n            }\n            if (isSizeDirty) {\n                this.updateSize();\n            }\n        };\n        Calendar.prototype.setOption = function (name, val) {\n            var _a;\n            this.processOptions((_a = {}, _a[name] = val, _a), 'dynamic');\n        };\n        Calendar.prototype.getOption = function (name) {\n            return this.optionsManager.computed[name];\n        };\n        Calendar.prototype.opt = function (name) {\n            return this.optionsManager.computed[name];\n        };\n        Calendar.prototype.viewOpt = function (name) {\n            return this.viewOpts()[name];\n        };\n        Calendar.prototype.viewOpts = function () {\n            return this.viewSpecs[this.state.viewType].options;\n        };\n        /*\n        rebuilds things based off of a complete set of refined options\n        */\n        Calendar.prototype.handleOptions = function (options) {\n            var _this = this;\n            var pluginHooks = this.pluginSystem.hooks;\n            this.defaultAllDayEventDuration = createDuration(options.defaultAllDayEventDuration);\n            this.defaultTimedEventDuration = createDuration(options.defaultTimedEventDuration);\n            this.delayedRerender = this.buildDelayedRerender(options.rerenderDelay);\n            this.theme = this.buildTheme(options);\n            var available = this.parseRawLocales(options.locales);\n            this.availableRawLocales = available.map;\n            var locale = this.buildLocale(options.locale || available.defaultCode, available.map);\n            this.dateEnv = this.buildDateEnv(locale, options.timeZone, pluginHooks.namedTimeZonedImpl, options.firstDay, options.weekNumberCalculation, options.weekLabel, pluginHooks.cmdFormatter);\n            this.selectionConfig = this.buildSelectionConfig(options); // needs dateEnv. do after :(\n            // ineffecient to do every time?\n            this.viewSpecs = buildViewSpecs(pluginHooks.views, this.optionsManager);\n            // ineffecient to do every time?\n            this.dateProfileGenerators = mapHash(this.viewSpecs, function (viewSpec) {\n                return new viewSpec.class.prototype.dateProfileGeneratorClass(viewSpec, _this);\n            });\n        };\n        Calendar.prototype.getAvailableLocaleCodes = function () {\n            return Object.keys(this.availableRawLocales);\n        };\n        Calendar.prototype._buildSelectionConfig = function (rawOpts) {\n            return processScopedUiProps('select', rawOpts, this);\n        };\n        Calendar.prototype._buildEventUiSingleBase = function (rawOpts) {\n            if (rawOpts.editable) { // so 'editable' affected events\n                rawOpts = __assign({}, rawOpts, { eventEditable: true });\n            }\n            return processScopedUiProps('event', rawOpts, this);\n        };\n        // Trigger\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.hasPublicHandlers = function (name) {\n            return this.hasHandlers(name) ||\n                this.opt(name); // handler specified in options\n        };\n        Calendar.prototype.publiclyTrigger = function (name, args) {\n            var optHandler = this.opt(name);\n            this.triggerWith(name, this, args);\n            if (optHandler) {\n                return optHandler.apply(this, args);\n            }\n        };\n        Calendar.prototype.publiclyTriggerAfterSizing = function (name, args) {\n            var afterSizingTriggers = this.afterSizingTriggers;\n            (afterSizingTriggers[name] || (afterSizingTriggers[name] = [])).push(args);\n        };\n        Calendar.prototype.releaseAfterSizingTriggers = function () {\n            var afterSizingTriggers = this.afterSizingTriggers;\n            for (var name_7 in afterSizingTriggers) {\n                for (var _i = 0, _a = afterSizingTriggers[name_7]; _i < _a.length; _i++) {\n                    var args = _a[_i];\n                    this.publiclyTrigger(name_7, args);\n                }\n            }\n            this.afterSizingTriggers = {};\n        };\n        // View\n        // -----------------------------------------------------------------------------------------------------------------\n        // Returns a boolean about whether the view is okay to instantiate at some point\n        Calendar.prototype.isValidViewType = function (viewType) {\n            return Boolean(this.viewSpecs[viewType]);\n        };\n        Calendar.prototype.changeView = function (viewType, dateOrRange) {\n            var dateMarker = null;\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) { // a range\n                    this.optionsManager.addDynamic({ visibleRange: dateOrRange }); // will not rerender\n                    this.handleOptions(this.optionsManager.computed); // ...but yuck\n                }\n                else { // a date\n                    dateMarker = this.dateEnv.createMarker(dateOrRange); // just like gotoDate\n                }\n            }\n            this.unselect();\n            this.dispatch({\n                type: 'SET_VIEW_TYPE',\n                viewType: viewType,\n                dateMarker: dateMarker\n            });\n        };\n        // Forces navigation to a view for the given date.\n        // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n        // needs to change\n        Calendar.prototype.zoomTo = function (dateMarker, viewType) {\n            var spec;\n            viewType = viewType || 'day'; // day is default zoom\n            spec = this.viewSpecs[viewType] ||\n                this.getUnitViewSpec(viewType);\n            this.unselect();\n            if (spec) {\n                this.dispatch({\n                    type: 'SET_VIEW_TYPE',\n                    viewType: spec.type,\n                    dateMarker: dateMarker\n                });\n            }\n            else {\n                this.dispatch({\n                    type: 'SET_DATE',\n                    dateMarker: dateMarker\n                });\n            }\n        };\n        // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n        // Preference is given to views that have corresponding buttons.\n        Calendar.prototype.getUnitViewSpec = function (unit) {\n            var component = this.component;\n            var viewTypes = [];\n            var i;\n            var spec;\n            // put views that have buttons first. there will be duplicates, but oh\n            if (component.header) {\n                viewTypes.push.apply(viewTypes, component.header.viewsWithButtons);\n            }\n            if (component.footer) {\n                viewTypes.push.apply(viewTypes, component.footer.viewsWithButtons);\n            }\n            for (var viewType in this.viewSpecs) {\n                viewTypes.push(viewType);\n            }\n            for (i = 0; i < viewTypes.length; i++) {\n                spec = this.viewSpecs[viewTypes[i]];\n                if (spec) {\n                    if (spec.singleUnit === unit) {\n                        return spec;\n                    }\n                }\n            }\n        };\n        // Current Date\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.getInitialDate = function () {\n            var defaultDateInput = this.opt('defaultDate');\n            // compute the initial ambig-timezone date\n            if (defaultDateInput != null) {\n                return this.dateEnv.createMarker(defaultDateInput);\n            }\n            else {\n                return this.getNow(); // getNow already returns unzoned\n            }\n        };\n        Calendar.prototype.prev = function () {\n            this.unselect();\n            this.dispatch({ type: 'PREV' });\n        };\n        Calendar.prototype.next = function () {\n            this.unselect();\n            this.dispatch({ type: 'NEXT' });\n        };\n        Calendar.prototype.prevYear = function () {\n            this.unselect();\n            this.dispatch({\n                type: 'SET_DATE',\n                dateMarker: this.dateEnv.addYears(this.state.currentDate, -1)\n            });\n        };\n        Calendar.prototype.nextYear = function () {\n            this.unselect();\n            this.dispatch({\n                type: 'SET_DATE',\n                dateMarker: this.dateEnv.addYears(this.state.currentDate, 1)\n            });\n        };\n        Calendar.prototype.today = function () {\n            this.unselect();\n            this.dispatch({\n                type: 'SET_DATE',\n                dateMarker: this.getNow()\n            });\n        };\n        Calendar.prototype.gotoDate = function (zonedDateInput) {\n            this.unselect();\n            this.dispatch({\n                type: 'SET_DATE',\n                dateMarker: this.dateEnv.createMarker(zonedDateInput)\n            });\n        };\n        Calendar.prototype.incrementDate = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // else, warn about invalid input?\n                this.unselect();\n                this.dispatch({\n                    type: 'SET_DATE',\n                    dateMarker: this.dateEnv.add(this.state.currentDate, delta)\n                });\n            }\n        };\n        // for external API\n        Calendar.prototype.getDate = function () {\n            return this.dateEnv.toDate(this.state.currentDate);\n        };\n        // Date Formatting Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.formatDate = function (d, formatter) {\n            var dateEnv = this.dateEnv;\n            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n        };\n        // `settings` is for formatter AND isEndExclusive\n        Calendar.prototype.formatRange = function (d0, d1, settings) {\n            var dateEnv = this.dateEnv;\n            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings, this.opt('defaultRangeSeparator')), settings);\n        };\n        Calendar.prototype.formatIso = function (d, omitTime) {\n            var dateEnv = this.dateEnv;\n            return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime: omitTime });\n        };\n        // Sizing\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.windowResize = function (ev) {\n            if (!this.isHandlingWindowResize &&\n                this.component && // why?\n                ev.target === window // not a jqui resize event\n            ) {\n                this.isHandlingWindowResize = true;\n                this.updateSize();\n                this.publiclyTrigger('windowResize', [this.view]);\n                this.isHandlingWindowResize = false;\n            }\n        };\n        Calendar.prototype.updateSize = function () {\n            if (this.component) { // when?\n                this.component.updateSize(true);\n            }\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.registerInteractiveComponent = function (component, settingsInput) {\n            var settings = parseInteractionSettings(component, settingsInput);\n            var DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            var interactionClasses = DEFAULT_INTERACTIONS.concat(this.pluginSystem.hooks.componentInteractions);\n            var interactions = interactionClasses.map(function (interactionClass) {\n                return new interactionClass(settings);\n            });\n            this.interactionsStore[component.uid] = interactions;\n            interactionSettingsStore[component.uid] = settings;\n        };\n        Calendar.prototype.unregisterInteractiveComponent = function (component) {\n            for (var _i = 0, _a = this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.destroy();\n            }\n            delete this.interactionsStore[component.uid];\n            delete interactionSettingsStore[component.uid];\n        };\n        // Date Selection / Event Selection / DayClick\n        // -----------------------------------------------------------------------------------------------------------------\n        // this public method receives start/end dates in any format, with any timezone\n        // NOTE: args were changed from v3\n        Calendar.prototype.select = function (dateOrObj, endDate) {\n            var selectionInput;\n            if (endDate == null) {\n                if (dateOrObj.start != null) {\n                    selectionInput = dateOrObj;\n                }\n                else {\n                    selectionInput = {\n                        start: dateOrObj,\n                        end: null\n                    };\n                }\n            }\n            else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: endDate\n                };\n            }\n            var selection = parseDateSpan(selectionInput, this.dateEnv, createDuration({ days: 1 }) // TODO: cache this?\n            );\n            if (selection) { // throw parse error otherwise?\n                this.dispatch({ type: 'SELECT_DATES', selection: selection });\n                this.triggerDateSelect(selection);\n            }\n        };\n        // public method\n        Calendar.prototype.unselect = function (pev) {\n            if (this.state.dateSelection) {\n                this.dispatch({ type: 'UNSELECT_DATES' });\n                this.triggerDateUnselect(pev);\n            }\n        };\n        Calendar.prototype.triggerDateSelect = function (selection, pev) {\n            var arg = this.buildDateSpanApi(selection);\n            arg.jsEvent = pev ? pev.origEvent : null;\n            arg.view = this.view;\n            this.publiclyTrigger('select', [arg]);\n        };\n        Calendar.prototype.triggerDateUnselect = function (pev) {\n            this.publiclyTrigger('unselect', [\n                {\n                    jsEvent: pev ? pev.origEvent : null,\n                    view: this.view\n                }\n            ]);\n        };\n        // TODO: receive pev?\n        Calendar.prototype.triggerDateClick = function (dateSpan, dayEl, view, ev) {\n            var arg = this.buildDatePointApi(dateSpan);\n            arg.dayEl = dayEl;\n            arg.jsEvent = ev;\n            arg.view = view;\n            this.publiclyTrigger('dateClick', [arg]);\n        };\n        Calendar.prototype.buildDatePointApi = function (dateSpan) {\n            var props = {};\n            for (var _i = 0, _a = this.pluginSystem.hooks.datePointTransforms; _i < _a.length; _i++) {\n                var transform = _a[_i];\n                __assign(props, transform(dateSpan, this));\n            }\n            __assign(props, buildDatePointApi(dateSpan, this.dateEnv));\n            return props;\n        };\n        Calendar.prototype.buildDateSpanApi = function (dateSpan) {\n            var props = {};\n            for (var _i = 0, _a = this.pluginSystem.hooks.dateSpanTransforms; _i < _a.length; _i++) {\n                var transform = _a[_i];\n                __assign(props, transform(dateSpan, this));\n            }\n            __assign(props, buildDateSpanApi(dateSpan, this.dateEnv));\n            return props;\n        };\n        // Date Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        // Returns a DateMarker for the current date, as defined by the client's computer or from the `now` option\n        Calendar.prototype.getNow = function () {\n            var now = this.opt('now');\n            if (typeof now === 'function') {\n                now = now();\n            }\n            if (now == null) {\n                return this.dateEnv.createNowMarker();\n            }\n            return this.dateEnv.createMarker(now);\n        };\n        // Event-Date Utilities\n        // -----------------------------------------------------------------------------------------------------------------\n        // Given an event's allDay status and start date, return what its fallback end date should be.\n        // TODO: rename to computeDefaultEventEnd\n        Calendar.prototype.getDefaultEventEnd = function (allDay, marker) {\n            var end = marker;\n            if (allDay) {\n                end = startOfDay(end);\n                end = this.dateEnv.add(end, this.defaultAllDayEventDuration);\n            }\n            else {\n                end = this.dateEnv.add(end, this.defaultTimedEventDuration);\n            }\n            return end;\n        };\n        // Public Events API\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.addEvent = function (eventInput, sourceInput) {\n            if (eventInput instanceof EventApi) {\n                var def = eventInput._def;\n                var instance = eventInput._instance;\n                // not already present? don't want to add an old snapshot\n                if (!this.state.eventStore.defs[def.defId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENTS',\n                        eventStore: eventTupleToStore({ def: def, instance: instance }) // TODO: better util for two args?\n                    });\n                }\n                return eventInput;\n            }\n            var sourceId;\n            if (sourceInput instanceof EventSourceApi) {\n                sourceId = sourceInput.internalEventSource.sourceId;\n            }\n            else if (sourceInput != null) {\n                var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n                if (!sourceApi) {\n                    console.warn('Could not find an event source with ID \"' + sourceInput + '\"'); // TODO: test\n                    return null;\n                }\n                else {\n                    sourceId = sourceApi.internalEventSource.sourceId;\n                }\n            }\n            var tuple = parseEvent(eventInput, sourceId, this);\n            if (tuple) {\n                this.dispatch({\n                    type: 'ADD_EVENTS',\n                    eventStore: eventTupleToStore(tuple)\n                });\n                return new EventApi(this, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            }\n            return null;\n        };\n        // TODO: optimize\n        Calendar.prototype.getEventById = function (id) {\n            var _a = this.state.eventStore, defs = _a.defs, instances = _a.instances;\n            id = String(id);\n            for (var defId in defs) {\n                var def = defs[defId];\n                if (def.publicId === id) {\n                    if (def.recurringDef) {\n                        return new EventApi(this, def, null);\n                    }\n                    else {\n                        for (var instanceId in instances) {\n                            var instance = instances[instanceId];\n                            if (instance.defId === def.defId) {\n                                return new EventApi(this, def, instance);\n                            }\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n        Calendar.prototype.getEvents = function () {\n            var _a = this.state.eventStore, defs = _a.defs, instances = _a.instances;\n            var eventApis = [];\n            for (var id in instances) {\n                var instance = instances[id];\n                var def = defs[instance.defId];\n                eventApis.push(new EventApi(this, def, instance));\n            }\n            return eventApis;\n        };\n        Calendar.prototype.removeAllEvents = function () {\n            this.dispatch({ type: 'REMOVE_ALL_EVENTS' });\n        };\n        Calendar.prototype.rerenderEvents = function () {\n            this.dispatch({ type: 'RESET_EVENTS' });\n        };\n        // Public Event Sources API\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.getEventSources = function () {\n            var sourceHash = this.state.eventSources;\n            var sourceApis = [];\n            for (var internalId in sourceHash) {\n                sourceApis.push(new EventSourceApi(this, sourceHash[internalId]));\n            }\n            return sourceApis;\n        };\n        Calendar.prototype.getEventSourceById = function (id) {\n            var sourceHash = this.state.eventSources;\n            id = String(id);\n            for (var sourceId in sourceHash) {\n                if (sourceHash[sourceId].publicId === id) {\n                    return new EventSourceApi(this, sourceHash[sourceId]);\n                }\n            }\n            return null;\n        };\n        Calendar.prototype.addEventSource = function (sourceInput) {\n            if (sourceInput instanceof EventSourceApi) {\n                // not already present? don't want to add an old snapshot\n                if (!this.state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENT_SOURCES',\n                        sources: [sourceInput.internalEventSource]\n                    });\n                }\n                return sourceInput;\n            }\n            var eventSource = parseEventSource(sourceInput, this);\n            if (eventSource) { // TODO: error otherwise?\n                this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });\n                return new EventSourceApi(this, eventSource);\n            }\n            return null;\n        };\n        Calendar.prototype.removeAllEventSources = function () {\n            this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });\n        };\n        Calendar.prototype.refetchEvents = function () {\n            this.dispatch({ type: 'FETCH_EVENT_SOURCES' });\n        };\n        // Scroll\n        // -----------------------------------------------------------------------------------------------------------------\n        Calendar.prototype.scrollToTime = function (timeInput) {\n            var time = createDuration(timeInput);\n            if (time) {\n                this.component.view.scrollToTime(time);\n            }\n        };\n        return Calendar;\n    }());\n    EmitterMixin.mixInto(Calendar);\n    // for memoizers\n    // -----------------------------------------------------------------------------------------------------------------\n    function buildDateEnv(locale, timeZone, namedTimeZoneImpl, firstDay, weekNumberCalculation, weekLabel, cmdFormatter) {\n        return new DateEnv({\n            calendarSystem: 'gregory',\n            timeZone: timeZone,\n            namedTimeZoneImpl: namedTimeZoneImpl,\n            locale: locale,\n            weekNumberCalculation: weekNumberCalculation,\n            firstDay: firstDay,\n            weekLabel: weekLabel,\n            cmdFormatter: cmdFormatter\n        });\n    }\n    function buildTheme(calendarOptions) {\n        var themeClass = this.pluginSystem.hooks.themeClasses[calendarOptions.themeSystem] || StandardTheme;\n        return new themeClass(calendarOptions);\n    }\n    function buildDelayedRerender(wait) {\n        var func = this.tryRerender.bind(this);\n        if (wait != null) {\n            func = debounce(func, wait);\n        }\n        return func;\n    }\n    function buildEventUiBySource(eventSources) {\n        return mapHash(eventSources, function (eventSource) {\n            return eventSource.ui;\n        });\n    }\n    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n        var eventUiBases = { '': eventUiSingleBase };\n        for (var defId in eventDefs) {\n            var def = eventDefs[defId];\n            if (def.sourceId && eventUiBySource[def.sourceId]) {\n                eventUiBases[defId] = eventUiBySource[def.sourceId];\n            }\n        }\n        return eventUiBases;\n    }\n\n    var View = /** @class */ (function (_super) {\n        __extends(View, _super);\n        function View(context, viewSpec, dateProfileGenerator, parentEl) {\n            var _this = _super.call(this, context, createElement('div', { className: 'fc-view fc-' + viewSpec.type + '-view' }), true // isView (HACK)\n            ) || this;\n            _this.renderDatesMem = memoizeRendering(_this.renderDatesWrap, _this.unrenderDatesWrap);\n            _this.renderBusinessHoursMem = memoizeRendering(_this.renderBusinessHours, _this.unrenderBusinessHours, [_this.renderDatesMem]);\n            _this.renderDateSelectionMem = memoizeRendering(_this.renderDateSelectionWrap, _this.unrenderDateSelectionWrap, [_this.renderDatesMem]);\n            _this.renderEventsMem = memoizeRendering(_this.renderEvents, _this.unrenderEvents, [_this.renderDatesMem]);\n            _this.renderEventSelectionMem = memoizeRendering(_this.renderEventSelectionWrap, _this.unrenderEventSelectionWrap, [_this.renderEventsMem]);\n            _this.renderEventDragMem = memoizeRendering(_this.renderEventDragWrap, _this.unrenderEventDragWrap, [_this.renderDatesMem]);\n            _this.renderEventResizeMem = memoizeRendering(_this.renderEventResizeWrap, _this.unrenderEventResizeWrap, [_this.renderDatesMem]);\n            _this.viewSpec = viewSpec;\n            _this.dateProfileGenerator = dateProfileGenerator;\n            _this.type = viewSpec.type;\n            _this.eventOrderSpecs = parseFieldSpecs(_this.opt('eventOrder'));\n            _this.nextDayThreshold = createDuration(_this.opt('nextDayThreshold'));\n            parentEl.appendChild(_this.el);\n            _this.initialize();\n            return _this;\n        }\n        View.prototype.initialize = function () {\n        };\n        Object.defineProperty(View.prototype, \"activeStart\", {\n            // Date Setting/Unsetting\n            // -----------------------------------------------------------------------------------------------------------------\n            get: function () {\n                return this.dateEnv.toDate(this.props.dateProfile.activeRange.start);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(View.prototype, \"activeEnd\", {\n            get: function () {\n                return this.dateEnv.toDate(this.props.dateProfile.activeRange.end);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(View.prototype, \"currentStart\", {\n            get: function () {\n                return this.dateEnv.toDate(this.props.dateProfile.currentRange.start);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(View.prototype, \"currentEnd\", {\n            get: function () {\n                return this.dateEnv.toDate(this.props.dateProfile.currentRange.end);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // General Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.render = function (props) {\n            this.renderDatesMem(props.dateProfile);\n            this.renderBusinessHoursMem(props.businessHours);\n            this.renderDateSelectionMem(props.dateSelection);\n            this.renderEventsMem(props.eventStore);\n            this.renderEventSelectionMem(props.eventSelection);\n            this.renderEventDragMem(props.eventDrag);\n            this.renderEventResizeMem(props.eventResize);\n        };\n        View.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this.renderDatesMem.unrender(); // should unrender everything else\n        };\n        // Sizing\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n            var calendar = this.calendar;\n            if (isResize || calendar.isViewUpdated || calendar.isDatesUpdated || calendar.isEventsUpdated) {\n                // sort of the catch-all sizing\n                // anything that might cause dimension changes\n                this.updateBaseSize(isResize, viewHeight, isAuto);\n            }\n        };\n        View.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n        };\n        // Date Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderDatesWrap = function (dateProfile) {\n            this.renderDates(dateProfile);\n            this.addScroll({\n                timeMs: createDuration(this.opt('scrollTime')).milliseconds\n            });\n            this.startNowIndicator(dateProfile); // shouldn't render yet because updateSize will be called soon\n        };\n        View.prototype.unrenderDatesWrap = function () {\n            this.stopNowIndicator();\n            this.unrenderDates();\n        };\n        View.prototype.renderDates = function (dateProfile) { };\n        View.prototype.unrenderDates = function () { };\n        // Business Hours\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderBusinessHours = function (businessHours) { };\n        View.prototype.unrenderBusinessHours = function () { };\n        // Date Selection\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderDateSelectionWrap = function (selection) {\n            if (selection) {\n                this.renderDateSelection(selection);\n            }\n        };\n        View.prototype.unrenderDateSelectionWrap = function (selection) {\n            if (selection) {\n                this.unrenderDateSelection(selection);\n            }\n        };\n        View.prototype.renderDateSelection = function (selection) { };\n        View.prototype.unrenderDateSelection = function (selection) { };\n        // Event Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderEvents = function (eventStore) { };\n        View.prototype.unrenderEvents = function () { };\n        // util for subclasses\n        View.prototype.sliceEvents = function (eventStore, allDay) {\n            var props = this.props;\n            return sliceEventStore(eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? this.nextDayThreshold : null).fg;\n        };\n        // Event Selection\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderEventSelectionWrap = function (instanceId) {\n            if (instanceId) {\n                this.renderEventSelection(instanceId);\n            }\n        };\n        View.prototype.unrenderEventSelectionWrap = function (instanceId) {\n            if (instanceId) {\n                this.unrenderEventSelection(instanceId);\n            }\n        };\n        View.prototype.renderEventSelection = function (instanceId) { };\n        View.prototype.unrenderEventSelection = function (instanceId) { };\n        // Event Drag\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderEventDragWrap = function (state) {\n            if (state) {\n                this.renderEventDrag(state);\n            }\n        };\n        View.prototype.unrenderEventDragWrap = function (state) {\n            if (state) {\n                this.unrenderEventDrag(state);\n            }\n        };\n        View.prototype.renderEventDrag = function (state) { };\n        View.prototype.unrenderEventDrag = function (state) { };\n        // Event Resize\n        // -----------------------------------------------------------------------------------------------------------------\n        View.prototype.renderEventResizeWrap = function (state) {\n            if (state) {\n                this.renderEventResize(state);\n            }\n        };\n        View.prototype.unrenderEventResizeWrap = function (state) {\n            if (state) {\n                this.unrenderEventResize(state);\n            }\n        };\n        View.prototype.renderEventResize = function (state) { };\n        View.prototype.unrenderEventResize = function (state) { };\n        /* Now Indicator\n        ------------------------------------------------------------------------------------------------------------------*/\n        // Immediately render the current time indicator and begins re-rendering it at an interval,\n        // which is defined by this.getNowIndicatorUnit().\n        // TODO: somehow do this for the current whole day's background too\n        View.prototype.startNowIndicator = function (dateProfile) {\n            var _this = this;\n            var dateEnv = this.dateEnv;\n            var unit;\n            var update;\n            var delay; // ms wait value\n            if (this.opt('nowIndicator')) {\n                unit = this.getNowIndicatorUnit(dateProfile);\n                if (unit) {\n                    update = this.updateNowIndicator.bind(this);\n                    this.initialNowDate = this.calendar.getNow();\n                    this.initialNowQueriedMs = new Date().valueOf();\n                    // wait until the beginning of the next interval\n                    delay = dateEnv.add(dateEnv.startOf(this.initialNowDate, unit), createDuration(1, unit)).valueOf() - this.initialNowDate.valueOf();\n                    // TODO: maybe always use setTimeout, waiting until start of next unit\n                    this.nowIndicatorTimeoutID = setTimeout(function () {\n                        _this.nowIndicatorTimeoutID = null;\n                        update();\n                        if (unit === 'second') {\n                            delay = 1000; // every second\n                        }\n                        else {\n                            delay = 1000 * 60; // otherwise, every minute\n                        }\n                        _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\n                    }, delay);\n                }\n                // rendering will be initiated in updateSize\n            }\n        };\n        // rerenders the now indicator, computing the new current time from the amount of time that has passed\n        // since the initial getNow call.\n        View.prototype.updateNowIndicator = function () {\n            if (this.props.dateProfile && // a way to determine if dates were rendered yet\n                this.initialNowDate // activated before?\n            ) {\n                this.unrenderNowIndicator(); // won't unrender if unnecessary\n                this.renderNowIndicator(addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs));\n                this.isNowIndicatorRendered = true;\n            }\n        };\n        // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\n        // Won't cause side effects if indicator isn't rendered.\n        View.prototype.stopNowIndicator = function () {\n            if (this.isNowIndicatorRendered) {\n                if (this.nowIndicatorTimeoutID) {\n                    clearTimeout(this.nowIndicatorTimeoutID);\n                    this.nowIndicatorTimeoutID = null;\n                }\n                if (this.nowIndicatorIntervalID) {\n                    clearInterval(this.nowIndicatorIntervalID);\n                    this.nowIndicatorIntervalID = null;\n                }\n                this.unrenderNowIndicator();\n                this.isNowIndicatorRendered = false;\n            }\n        };\n        View.prototype.getNowIndicatorUnit = function (dateProfile) {\n            // subclasses should implement\n        };\n        // Renders a current time indicator at the given datetime\n        View.prototype.renderNowIndicator = function (date) {\n            // SUBCLASSES MUST PASS TO CHILDREN!\n        };\n        // Undoes the rendering actions from renderNowIndicator\n        View.prototype.unrenderNowIndicator = function () {\n            // SUBCLASSES MUST PASS TO CHILDREN!\n        };\n        /* Scroller\n        ------------------------------------------------------------------------------------------------------------------*/\n        View.prototype.addScroll = function (scroll) {\n            var queuedScroll = this.queuedScroll || (this.queuedScroll = {});\n            __assign(queuedScroll, scroll);\n        };\n        View.prototype.popScroll = function (isResize) {\n            this.applyQueuedScroll(isResize);\n            this.queuedScroll = null;\n        };\n        View.prototype.applyQueuedScroll = function (isResize) {\n            this.applyScroll(this.queuedScroll || {}, isResize);\n        };\n        View.prototype.queryScroll = function () {\n            var scroll = {};\n            if (this.props.dateProfile) { // dates rendered yet?\n                __assign(scroll, this.queryDateScroll());\n            }\n            return scroll;\n        };\n        View.prototype.applyScroll = function (scroll, isResize) {\n            var timeMs = scroll.timeMs;\n            if (timeMs != null) {\n                delete scroll.timeMs;\n                if (this.props.dateProfile) { // dates rendered yet?\n                    __assign(scroll, this.computeDateScroll(timeMs));\n                }\n            }\n            if (this.props.dateProfile) { // dates rendered yet?\n                this.applyDateScroll(scroll);\n            }\n        };\n        View.prototype.computeDateScroll = function (timeMs) {\n            return {}; // subclasses must implement\n        };\n        View.prototype.queryDateScroll = function () {\n            return {}; // subclasses must implement\n        };\n        View.prototype.applyDateScroll = function (scroll) {\n            // subclasses must implement\n        };\n        // for API\n        View.prototype.scrollToTime = function (time) {\n            this.applyScroll({\n                timeMs: time.milliseconds\n            }, false);\n        };\n        return View;\n    }(DateComponent));\n    EmitterMixin.mixInto(View);\n    View.prototype.usesMinMaxTime = false;\n    View.prototype.dateProfileGeneratorClass = DateProfileGenerator;\n\n    var FgEventRenderer = /** @class */ (function () {\n        function FgEventRenderer(context) {\n            this.segs = [];\n            this.isSizeDirty = false;\n            this.context = context;\n        }\n        FgEventRenderer.prototype.renderSegs = function (segs, mirrorInfo) {\n            this.rangeUpdated(); // called too frequently :(\n            // render an `.el` on each seg\n            // returns a subset of the segs. segs that were actually rendered\n            segs = this.renderSegEls(segs, mirrorInfo);\n            this.segs = segs;\n            this.attachSegs(segs, mirrorInfo);\n            this.isSizeDirty = true;\n            this.context.view.triggerRenderedSegs(this.segs, Boolean(mirrorInfo));\n        };\n        FgEventRenderer.prototype.unrender = function (_segs, mirrorInfo) {\n            this.context.view.triggerWillRemoveSegs(this.segs, Boolean(mirrorInfo));\n            this.detachSegs(this.segs);\n            this.segs = [];\n        };\n        // Updates values that rely on options and also relate to range\n        FgEventRenderer.prototype.rangeUpdated = function () {\n            var options = this.context.options;\n            var displayEventTime;\n            var displayEventEnd;\n            this.eventTimeFormat = createFormatter(options.eventTimeFormat || this.computeEventTimeFormat(), options.defaultRangeSeparator);\n            displayEventTime = options.displayEventTime;\n            if (displayEventTime == null) {\n                displayEventTime = this.computeDisplayEventTime(); // might be based off of range\n            }\n            displayEventEnd = options.displayEventEnd;\n            if (displayEventEnd == null) {\n                displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\n            }\n            this.displayEventTime = displayEventTime;\n            this.displayEventEnd = displayEventEnd;\n        };\n        // Renders and assigns an `el` property for each foreground event segment.\n        // Only returns segments that successfully rendered.\n        FgEventRenderer.prototype.renderSegEls = function (segs, mirrorInfo) {\n            var html = '';\n            var i;\n            if (segs.length) { // don't build an empty html string\n                // build a large concatenation of event segment HTML\n                for (i = 0; i < segs.length; i++) {\n                    html += this.renderSegHtml(segs[i], mirrorInfo);\n                }\n                // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\n                htmlToElements(html).forEach(function (el, i) {\n                    var seg = segs[i];\n                    if (el) {\n                        seg.el = el;\n                    }\n                });\n                segs = filterSegsViaEls(this.context.view, segs, Boolean(mirrorInfo));\n            }\n            return segs;\n        };\n        // Generic utility for generating the HTML classNames for an event segment's element\n        FgEventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable, mirrorInfo) {\n            var classes = [\n                'fc-event',\n                seg.isStart ? 'fc-start' : 'fc-not-start',\n                seg.isEnd ? 'fc-end' : 'fc-not-end'\n            ].concat(seg.eventRange.ui.classNames);\n            if (isDraggable) {\n                classes.push('fc-draggable');\n            }\n            if (isResizable) {\n                classes.push('fc-resizable');\n            }\n            if (mirrorInfo) {\n                classes.push('fc-mirror');\n                if (mirrorInfo.isDragging) {\n                    classes.push('fc-dragging');\n                }\n                if (mirrorInfo.isResizing) {\n                    classes.push('fc-resizing');\n                }\n            }\n            return classes;\n        };\n        // Compute the text that should be displayed on an event's element.\n        // `range` can be the Event object itself, or something range-like, with at least a `start`.\n        // If event times are disabled, or the event has no time, will return a blank string.\n        // If not specified, formatter will default to the eventTimeFormat setting,\n        // and displayEnd will default to the displayEventEnd setting.\n        FgEventRenderer.prototype.getTimeText = function (eventRange, formatter, displayEnd) {\n            var def = eventRange.def, instance = eventRange.instance;\n            return this._getTimeText(instance.range.start, def.hasEnd ? instance.range.end : null, def.allDay, formatter, displayEnd, instance.forcedStartTzo, instance.forcedEndTzo);\n        };\n        FgEventRenderer.prototype._getTimeText = function (start, end, allDay, formatter, displayEnd, forcedStartTzo, forcedEndTzo) {\n            var dateEnv = this.context.dateEnv;\n            if (formatter == null) {\n                formatter = this.eventTimeFormat;\n            }\n            if (displayEnd == null) {\n                displayEnd = this.displayEventEnd;\n            }\n            if (this.displayEventTime && !allDay) {\n                if (displayEnd && end) {\n                    return dateEnv.formatRange(start, end, formatter, {\n                        forcedStartTzo: forcedStartTzo,\n                        forcedEndTzo: forcedEndTzo\n                    });\n                }\n                else {\n                    return dateEnv.format(start, formatter, {\n                        forcedTzo: forcedStartTzo\n                    });\n                }\n            }\n            return '';\n        };\n        FgEventRenderer.prototype.computeEventTimeFormat = function () {\n            return {\n                hour: 'numeric',\n                minute: '2-digit',\n                omitZeroMinute: true\n            };\n        };\n        FgEventRenderer.prototype.computeDisplayEventTime = function () {\n            return true;\n        };\n        FgEventRenderer.prototype.computeDisplayEventEnd = function () {\n            return true;\n        };\n        // Utility for generating event skin-related CSS properties\n        FgEventRenderer.prototype.getSkinCss = function (ui) {\n            return {\n                'background-color': ui.backgroundColor,\n                'border-color': ui.borderColor,\n                color: ui.textColor\n            };\n        };\n        FgEventRenderer.prototype.sortEventSegs = function (segs) {\n            var specs = this.context.view.eventOrderSpecs;\n            var objs = segs.map(buildSegCompareObj);\n            objs.sort(function (obj0, obj1) {\n                return compareByFieldSpecs(obj0, obj1, specs);\n            });\n            return objs.map(function (c) {\n                return c._seg;\n            });\n        };\n        FgEventRenderer.prototype.computeSizes = function (force) {\n            if (force || this.isSizeDirty) {\n                this.computeSegSizes(this.segs);\n            }\n        };\n        FgEventRenderer.prototype.assignSizes = function (force) {\n            if (force || this.isSizeDirty) {\n                this.assignSegSizes(this.segs);\n                this.isSizeDirty = false;\n            }\n        };\n        FgEventRenderer.prototype.computeSegSizes = function (segs) {\n        };\n        FgEventRenderer.prototype.assignSegSizes = function (segs) {\n        };\n        // Manipulation on rendered segs\n        FgEventRenderer.prototype.hideByHash = function (hash) {\n            if (hash) {\n                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {\n                    var seg = _a[_i];\n                    if (hash[seg.eventRange.instance.instanceId]) {\n                        seg.el.style.visibility = 'hidden';\n                    }\n                }\n            }\n        };\n        FgEventRenderer.prototype.showByHash = function (hash) {\n            if (hash) {\n                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {\n                    var seg = _a[_i];\n                    if (hash[seg.eventRange.instance.instanceId]) {\n                        seg.el.style.visibility = '';\n                    }\n                }\n            }\n        };\n        FgEventRenderer.prototype.selectByInstanceId = function (instanceId) {\n            if (instanceId) {\n                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {\n                    var seg = _a[_i];\n                    var eventInstance = seg.eventRange.instance;\n                    if (eventInstance && eventInstance.instanceId === instanceId &&\n                        seg.el // necessary?\n                    ) {\n                        seg.el.classList.add('fc-selected');\n                    }\n                }\n            }\n        };\n        FgEventRenderer.prototype.unselectByInstanceId = function (instanceId) {\n            if (instanceId) {\n                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {\n                    var seg = _a[_i];\n                    if (seg.el) { // necessary?\n                        seg.el.classList.remove('fc-selected');\n                    }\n                }\n            }\n        };\n        return FgEventRenderer;\n    }());\n    // returns a object with all primitive props that can be compared\n    function buildSegCompareObj(seg) {\n        var eventDef = seg.eventRange.def;\n        var range = seg.eventRange.instance.range;\n        var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n        var end = range.end ? range.end.valueOf() : 0; // \"\n        return __assign({}, eventDef.extendedProps, eventDef, { id: eventDef.publicId, start: start,\n            end: end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg // for later retrieval\n         });\n    }\n\n    var FillRenderer = /** @class */ (function () {\n        function FillRenderer(context) {\n            this.fillSegTag = 'div';\n            this.dirtySizeFlags = {};\n            this.context = context;\n            this.containerElsByType = {};\n            this.segsByType = {};\n        }\n        FillRenderer.prototype.getSegsByType = function (type) {\n            return this.segsByType[type] || [];\n        };\n        FillRenderer.prototype.renderSegs = function (type, segs) {\n            var _a;\n            var renderedSegs = this.renderSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs\n            var containerEls = this.attachSegs(type, renderedSegs);\n            if (containerEls) {\n                (_a = (this.containerElsByType[type] || (this.containerElsByType[type] = []))).push.apply(_a, containerEls);\n            }\n            this.segsByType[type] = renderedSegs;\n            if (type === 'bgEvent') {\n                this.context.view.triggerRenderedSegs(renderedSegs, false); // isMirror=false\n            }\n            this.dirtySizeFlags[type] = true;\n        };\n        // Unrenders a specific type of fill that is currently rendered on the grid\n        FillRenderer.prototype.unrender = function (type) {\n            var segs = this.segsByType[type];\n            if (segs) {\n                if (type === 'bgEvent') {\n                    this.context.view.triggerWillRemoveSegs(segs, false); // isMirror=false\n                }\n                this.detachSegs(type, segs);\n            }\n        };\n        // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\n        // Only returns segments that successfully rendered.\n        FillRenderer.prototype.renderSegEls = function (type, segs) {\n            var _this = this;\n            var html = '';\n            var i;\n            if (segs.length) {\n                // build a large concatenation of segment HTML\n                for (i = 0; i < segs.length; i++) {\n                    html += this.renderSegHtml(type, segs[i]);\n                }\n                // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                // Then, compute the 'el' for each segment.\n                htmlToElements(html).forEach(function (el, i) {\n                    var seg = segs[i];\n                    if (el) {\n                        seg.el = el;\n                    }\n                });\n                if (type === 'bgEvent') {\n                    segs = filterSegsViaEls(this.context.view, segs, false // isMirror. background events can never be mirror elements\n                    );\n                }\n                // correct element type? (would be bad if a non-TD were inserted into a table for example)\n                segs = segs.filter(function (seg) {\n                    return elementMatches(seg.el, _this.fillSegTag);\n                });\n            }\n            return segs;\n        };\n        // Builds the HTML needed for one fill segment. Generic enough to work with different types.\n        FillRenderer.prototype.renderSegHtml = function (type, seg) {\n            var css = null;\n            var classNames = [];\n            if (type !== 'highlight' && type !== 'businessHours') {\n                css = {\n                    'background-color': seg.eventRange.ui.backgroundColor\n                };\n            }\n            if (type !== 'highlight') {\n                classNames = classNames.concat(seg.eventRange.ui.classNames);\n            }\n            if (type === 'businessHours') {\n                classNames.push('fc-bgevent');\n            }\n            else {\n                classNames.push('fc-' + type.toLowerCase());\n            }\n            return '<' + this.fillSegTag +\n                (classNames.length ? ' class=\"' + classNames.join(' ') + '\"' : '') +\n                (css ? ' style=\"' + cssToStr(css) + '\"' : '') +\n                '></' + this.fillSegTag + '>';\n        };\n        FillRenderer.prototype.detachSegs = function (type, segs) {\n            var containerEls = this.containerElsByType[type];\n            if (containerEls) {\n                containerEls.forEach(removeElement);\n                delete this.containerElsByType[type];\n            }\n        };\n        FillRenderer.prototype.computeSizes = function (force) {\n            for (var type in this.segsByType) {\n                if (force || this.dirtySizeFlags[type]) {\n                    this.computeSegSizes(this.segsByType[type]);\n                }\n            }\n        };\n        FillRenderer.prototype.assignSizes = function (force) {\n            for (var type in this.segsByType) {\n                if (force || this.dirtySizeFlags[type]) {\n                    this.assignSegSizes(this.segsByType[type]);\n                }\n            }\n            this.dirtySizeFlags = {};\n        };\n        FillRenderer.prototype.computeSegSizes = function (segs) {\n        };\n        FillRenderer.prototype.assignSegSizes = function (segs) {\n        };\n        return FillRenderer;\n    }());\n\n    var NamedTimeZoneImpl = /** @class */ (function () {\n        function NamedTimeZoneImpl(timeZoneName) {\n            this.timeZoneName = timeZoneName;\n        }\n        return NamedTimeZoneImpl;\n    }());\n\n    /*\n    An abstraction for a dragging interaction originating on an event.\n    Does higher-level things than PointerDragger, such as possibly:\n    - a \"mirror\" that moves with the pointer\n    - a minimum number of pixels or other criteria for a true drag to begin\n\n    subclasses must emit:\n    - pointerdown\n    - dragstart\n    - dragmove\n    - pointerup\n    - dragend\n    */\n    var ElementDragging = /** @class */ (function () {\n        function ElementDragging(el) {\n            this.emitter = new EmitterMixin();\n        }\n        ElementDragging.prototype.destroy = function () {\n        };\n        ElementDragging.prototype.setMirrorIsVisible = function (bool) {\n            // optional if subclass doesn't want to support a mirror\n        };\n        ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n            // optional if subclass doesn't want to support a mirror\n        };\n        ElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n            // optional\n        };\n        return ElementDragging;\n    }());\n\n    function formatDate(dateInput, settings) {\n        if (settings === void 0) { settings = {}; }\n        var dateEnv = buildDateEnv$1(settings);\n        var formatter = createFormatter(settings);\n        var dateMeta = dateEnv.createMarkerMeta(dateInput);\n        if (!dateMeta) { // TODO: warning?\n            return '';\n        }\n        return dateEnv.format(dateMeta.marker, formatter, {\n            forcedTzo: dateMeta.forcedTzo\n        });\n    }\n    function formatRange(startInput, endInput, settings // mixture of env and formatter settings\n    ) {\n        var dateEnv = buildDateEnv$1(typeof settings === 'object' && settings ? settings : {}); // pass in if non-null object\n        var formatter = createFormatter(settings, globalDefaults.defaultRangeSeparator);\n        var startMeta = dateEnv.createMarkerMeta(startInput);\n        var endMeta = dateEnv.createMarkerMeta(endInput);\n        if (!startMeta || !endMeta) { // TODO: warning?\n            return '';\n        }\n        return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n            forcedStartTzo: startMeta.forcedTzo,\n            forcedEndTzo: endMeta.forcedTzo,\n            isEndExclusive: settings.isEndExclusive\n        });\n    }\n    // TODO: more DRY and optimized\n    function buildDateEnv$1(settings) {\n        var locale = buildLocale(settings.locale || 'en', parseRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n        // ensure required settings\n        settings = __assign({ timeZone: globalDefaults.timeZone, calendarSystem: 'gregory' }, settings, { locale: locale });\n        return new DateEnv(settings);\n    }\n\n    var DRAG_META_PROPS = {\n        startTime: createDuration,\n        duration: createDuration,\n        create: Boolean,\n        sourceId: String\n    };\n    var DRAG_META_DEFAULTS = {\n        create: true\n    };\n    function parseDragMeta(raw) {\n        var leftoverProps = {};\n        var refined = refineProps(raw, DRAG_META_PROPS, DRAG_META_DEFAULTS, leftoverProps);\n        refined.leftoverProps = leftoverProps;\n        return refined;\n    }\n\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\n    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n        // if more than one week row, or if there are a lot of columns with not much space,\n        // put just the day numbers will be in each cell\n        if (!datesRepDistinctDays || dayCnt > 10) {\n            return { weekday: 'short' }; // \"Sat\"\n        }\n        else if (dayCnt > 1) {\n            return { weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }; // \"Sat 11/12\"\n        }\n        else {\n            return { weekday: 'long' }; // \"Saturday\"\n        }\n    }\n    function renderDateCell(dateMarker, dateProfile, datesRepDistinctDays, colCnt, colHeadFormat, context, colspan, otherAttrs) {\n        var view = context.view, dateEnv = context.dateEnv, theme = context.theme, options = context.options;\n        var isDateValid = rangeContainsMarker(dateProfile.activeRange, dateMarker); // TODO: called too frequently. cache somehow.\n        var classNames = [\n            'fc-day-header',\n            theme.getClass('widgetHeader')\n        ];\n        var innerHtml;\n        if (typeof options.columnHeaderHtml === 'function') {\n            innerHtml = options.columnHeaderHtml(dateEnv.toDate(dateMarker));\n        }\n        else if (typeof options.columnHeaderText === 'function') {\n            innerHtml = htmlEscape(options.columnHeaderText(dateEnv.toDate(dateMarker)));\n        }\n        else {\n            innerHtml = htmlEscape(dateEnv.format(dateMarker, colHeadFormat));\n        }\n        // if only one row of days, the classNames on the header can represent the specific days beneath\n        if (datesRepDistinctDays) {\n            classNames = classNames.concat(\n            // includes the day-of-week class\n            // noThemeHighlight=true (don't highlight the header)\n            getDayClasses(dateMarker, dateProfile, context, true));\n        }\n        else {\n            classNames.push('fc-' + DAY_IDS[dateMarker.getUTCDay()]); // only add the day-of-week class\n        }\n        return '' +\n            '<th class=\"' + classNames.join(' ') + '\"' +\n            ((isDateValid && datesRepDistinctDays) ?\n                ' data-date=\"' + dateEnv.formatIso(dateMarker, { omitTime: true }) + '\"' :\n                '') +\n            (colspan > 1 ?\n                ' colspan=\"' + colspan + '\"' :\n                '') +\n            (otherAttrs ?\n                ' ' + otherAttrs :\n                '') +\n            '>' +\n            (isDateValid ?\n                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\n                buildGotoAnchorHtml(view, { date: dateMarker, forceOff: !datesRepDistinctDays || colCnt === 1 }, innerHtml) :\n                // if not valid, display text, but no link\n                innerHtml) +\n            '</th>';\n    }\n\n    var DayHeader = /** @class */ (function (_super) {\n        __extends(DayHeader, _super);\n        function DayHeader(context, parentEl) {\n            var _this = _super.call(this, context) || this;\n            parentEl.innerHTML = ''; // because might be nbsp\n            parentEl.appendChild(_this.el = htmlToElement('<div class=\"fc-row ' + _this.theme.getClass('headerRow') + '\">' +\n                '<table class=\"' + _this.theme.getClass('tableGrid') + '\">' +\n                '<thead></thead>' +\n                '</table>' +\n                '</div>'));\n            _this.thead = _this.el.querySelector('thead');\n            return _this;\n        }\n        DayHeader.prototype.destroy = function () {\n            removeElement(this.el);\n        };\n        DayHeader.prototype.render = function (props) {\n            var dates = props.dates, datesRepDistinctDays = props.datesRepDistinctDays;\n            var parts = [];\n            if (props.renderIntroHtml) {\n                parts.push(props.renderIntroHtml());\n            }\n            var colHeadFormat = createFormatter(this.opt('columnHeaderFormat') ||\n                computeFallbackHeaderFormat(datesRepDistinctDays, dates.length));\n            for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {\n                var date = dates_1[_i];\n                parts.push(renderDateCell(date, props.dateProfile, datesRepDistinctDays, dates.length, colHeadFormat, this.context));\n            }\n            if (this.isRtl) {\n                parts.reverse();\n            }\n            this.thead.innerHTML = '<tr>' + parts.join('') + '</tr>';\n        };\n        return DayHeader;\n    }(Component));\n\n    var DaySeries = /** @class */ (function () {\n        function DaySeries(range, dateProfileGenerator) {\n            var date = range.start;\n            var end = range.end;\n            var indices = [];\n            var dates = [];\n            var dayIndex = -1;\n            while (date < end) { // loop each day from start to end\n                if (dateProfileGenerator.isHiddenDay(date)) {\n                    indices.push(dayIndex + 0.5); // mark that it's between indices\n                }\n                else {\n                    dayIndex++;\n                    indices.push(dayIndex);\n                    dates.push(date);\n                }\n                date = addDays(date, 1);\n            }\n            this.dates = dates;\n            this.indices = indices;\n            this.cnt = dates.length;\n        }\n        DaySeries.prototype.sliceRange = function (range) {\n            var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n            var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n            var clippedFirstIndex = Math.max(0, firstIndex);\n            var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n            // deal with in-between indices\n            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n            if (clippedFirstIndex <= clippedLastIndex) {\n                return {\n                    firstIndex: clippedFirstIndex,\n                    lastIndex: clippedLastIndex,\n                    isStart: firstIndex === clippedFirstIndex,\n                    isEnd: lastIndex === clippedLastIndex\n                };\n            }\n            else {\n                return null;\n            }\n        };\n        // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n        // If before the first offset, returns a negative number.\n        // If after the last offset, returns an offset past the last cell offset.\n        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n        DaySeries.prototype.getDateDayIndex = function (date) {\n            var indices = this.indices;\n            var dayOffset = Math.floor(diffDays(this.dates[0], date));\n            if (dayOffset < 0) {\n                return indices[0] - 1;\n            }\n            else if (dayOffset >= indices.length) {\n                return indices[indices.length - 1] + 1;\n            }\n            else {\n                return indices[dayOffset];\n            }\n        };\n        return DaySeries;\n    }());\n\n    var DayTable = /** @class */ (function () {\n        function DayTable(daySeries, breakOnWeeks) {\n            var dates = daySeries.dates;\n            var daysPerRow;\n            var firstDay;\n            var rowCnt;\n            if (breakOnWeeks) {\n                // count columns until the day-of-week repeats\n                firstDay = dates[0].getUTCDay();\n                for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow++) {\n                    if (dates[daysPerRow].getUTCDay() === firstDay) {\n                        break;\n                    }\n                }\n                rowCnt = Math.ceil(dates.length / daysPerRow);\n            }\n            else {\n                rowCnt = 1;\n                daysPerRow = dates.length;\n            }\n            this.rowCnt = rowCnt;\n            this.colCnt = daysPerRow;\n            this.daySeries = daySeries;\n            this.cells = this.buildCells();\n            this.headerDates = this.buildHeaderDates();\n        }\n        DayTable.prototype.buildCells = function () {\n            var rows = [];\n            for (var row = 0; row < this.rowCnt; row++) {\n                var cells = [];\n                for (var col = 0; col < this.colCnt; col++) {\n                    cells.push(this.buildCell(row, col));\n                }\n                rows.push(cells);\n            }\n            return rows;\n        };\n        DayTable.prototype.buildCell = function (row, col) {\n            return {\n                date: this.daySeries.dates[row * this.colCnt + col]\n            };\n        };\n        DayTable.prototype.buildHeaderDates = function () {\n            var dates = [];\n            for (var col = 0; col < this.colCnt; col++) {\n                dates.push(this.cells[0][col].date);\n            }\n            return dates;\n        };\n        DayTable.prototype.sliceRange = function (range) {\n            var colCnt = this.colCnt;\n            var seriesSeg = this.daySeries.sliceRange(range);\n            var segs = [];\n            if (seriesSeg) {\n                var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;\n                var index = firstIndex;\n                while (index <= lastIndex) {\n                    var row = Math.floor(index / colCnt);\n                    var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                    segs.push({\n                        row: row,\n                        firstCol: index % colCnt,\n                        lastCol: (nextIndex - 1) % colCnt,\n                        isStart: seriesSeg.isStart && index === firstIndex,\n                        isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex\n                    });\n                    index = nextIndex;\n                }\n            }\n            return segs;\n        };\n        return DayTable;\n    }());\n\n    var Slicer = /** @class */ (function () {\n        function Slicer() {\n            this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n            this.sliceDateSelection = memoize(this._sliceDateSpan);\n            this.sliceEventStore = memoize(this._sliceEventStore);\n            this.sliceEventDrag = memoize(this._sliceInteraction);\n            this.sliceEventResize = memoize(this._sliceInteraction);\n        }\n        Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, component) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            var eventUiBases = props.eventUiBases;\n            var eventSegs = this.sliceEventStore.apply(this, [props.eventStore, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs));\n            return {\n                dateSelectionSegs: this.sliceDateSelection.apply(this, [props.dateSelection, eventUiBases, component].concat(extraArgs)),\n                businessHourSegs: this.sliceBusinessHours.apply(this, [props.businessHours, dateProfile, nextDayThreshold, component].concat(extraArgs)),\n                fgEventSegs: eventSegs.fg,\n                bgEventSegs: eventSegs.bg,\n                eventDrag: this.sliceEventDrag.apply(this, [props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),\n                eventResize: this.sliceEventResize.apply(this, [props.eventResize, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),\n                eventSelection: props.eventSelection\n            }; // TODO: give interactionSegs?\n        };\n        Slicer.prototype.sliceNowDate = function (// does not memoize\n        date, component) {\n            var extraArgs = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                extraArgs[_i - 2] = arguments[_i];\n            }\n            return this._sliceDateSpan.apply(this, [{ range: { start: date, end: addMs(date, 1) }, allDay: false },\n                {},\n                component].concat(extraArgs));\n        };\n        Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, component) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            if (!businessHours) {\n                return [];\n            }\n            return this._sliceEventStore.apply(this, [expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), component.calendar),\n                {},\n                dateProfile,\n                nextDayThreshold,\n                component].concat(extraArgs)).bg;\n        };\n        Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold, component) {\n            var extraArgs = [];\n            for (var _i = 5; _i < arguments.length; _i++) {\n                extraArgs[_i - 5] = arguments[_i];\n            }\n            if (eventStore) {\n                var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n                return {\n                    bg: this.sliceEventRanges(rangeRes.bg, component, extraArgs),\n                    fg: this.sliceEventRanges(rangeRes.fg, component, extraArgs)\n                };\n            }\n            else {\n                return { bg: [], fg: [] };\n            }\n        };\n        Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold, component) {\n            var extraArgs = [];\n            for (var _i = 5; _i < arguments.length; _i++) {\n                extraArgs[_i - 5] = arguments[_i];\n            }\n            if (!interaction) {\n                return null;\n            }\n            var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                segs: this.sliceEventRanges(rangeRes.fg, component, extraArgs),\n                affectedInstances: interaction.affectedEvents.instances,\n                isEvent: interaction.isEvent,\n                sourceSeg: interaction.origSeg\n            };\n        };\n        Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, component) {\n            var extraArgs = [];\n            for (var _i = 3; _i < arguments.length; _i++) {\n                extraArgs[_i - 3] = arguments[_i];\n            }\n            if (!dateSpan) {\n                return [];\n            }\n            var eventRange = fabricateEventRange(dateSpan, eventUiBases, component.calendar);\n            var segs = this.sliceRange.apply(this, [dateSpan.range].concat(extraArgs));\n            for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n                var seg = segs_1[_a];\n                seg.component = component;\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        };\n        /*\n        \"complete\" seg means it has component and eventRange\n        */\n        Slicer.prototype.sliceEventRanges = function (eventRanges, component, // TODO: kill\n        extraArgs) {\n            var segs = [];\n            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n                var eventRange = eventRanges_1[_i];\n                segs.push.apply(segs, this.sliceEventRange(eventRange, component, extraArgs));\n            }\n            return segs;\n        };\n        /*\n        \"complete\" seg means it has component and eventRange\n        */\n        Slicer.prototype.sliceEventRange = function (eventRange, component, // TODO: kill\n        extraArgs) {\n            var segs = this.sliceRange.apply(this, [eventRange.range].concat(extraArgs));\n            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n                var seg = segs_2[_i];\n                seg.component = component;\n                seg.eventRange = eventRange;\n                seg.isStart = eventRange.isStart && seg.isStart;\n                seg.isEnd = eventRange.isEnd && seg.isEnd;\n            }\n            return segs;\n        };\n        return Slicer;\n    }());\n    /*\n    for incorporating minTime/maxTime if appropriate\n    TODO: should be part of DateProfile!\n    TimelineDateProfile already does this btw\n    */\n    function computeActiveRange(dateProfile, isComponentAllDay) {\n        var range = dateProfile.activeRange;\n        if (isComponentAllDay) {\n            return range;\n        }\n        return {\n            start: addMs(range.start, dateProfile.minTime.milliseconds),\n            end: addMs(range.end, dateProfile.maxTime.milliseconds - 864e5) // 864e5 = ms in a day\n        };\n    }\n\n    // exports\n    // --------------------------------------------------------------------------------------------------\n    var version = '4.1.0';\n\n    exports.Calendar = Calendar;\n    exports.Component = Component;\n    exports.DateComponent = DateComponent;\n    exports.DateEnv = DateEnv;\n    exports.DateProfileGenerator = DateProfileGenerator;\n    exports.DayHeader = DayHeader;\n    exports.DaySeries = DaySeries;\n    exports.DayTable = DayTable;\n    exports.ElementDragging = ElementDragging;\n    exports.ElementScrollController = ElementScrollController;\n    exports.EmitterMixin = EmitterMixin;\n    exports.EventApi = EventApi;\n    exports.FgEventRenderer = FgEventRenderer;\n    exports.FillRenderer = FillRenderer;\n    exports.Interaction = Interaction;\n    exports.Mixin = Mixin;\n    exports.NamedTimeZoneImpl = NamedTimeZoneImpl;\n    exports.PositionCache = PositionCache;\n    exports.ScrollComponent = ScrollComponent;\n    exports.ScrollController = ScrollController;\n    exports.Slicer = Slicer;\n    exports.Splitter = Splitter;\n    exports.Theme = Theme;\n    exports.View = View;\n    exports.WindowScrollController = WindowScrollController;\n    exports.addDays = addDays;\n    exports.addDurations = addDurations;\n    exports.addMs = addMs;\n    exports.addWeeks = addWeeks;\n    exports.allowContextMenu = allowContextMenu;\n    exports.allowSelection = allowSelection;\n    exports.appendToElement = appendToElement;\n    exports.applyAll = applyAll;\n    exports.applyMutationToEventStore = applyMutationToEventStore;\n    exports.applyStyle = applyStyle;\n    exports.applyStyleProp = applyStyleProp;\n    exports.asRoughMinutes = asRoughMinutes;\n    exports.asRoughMs = asRoughMs;\n    exports.asRoughSeconds = asRoughSeconds;\n    exports.buildGotoAnchorHtml = buildGotoAnchorHtml;\n    exports.buildSegCompareObj = buildSegCompareObj;\n    exports.capitaliseFirstLetter = capitaliseFirstLetter;\n    exports.combineEventUis = combineEventUis;\n    exports.compareByFieldSpec = compareByFieldSpec;\n    exports.compareByFieldSpecs = compareByFieldSpecs;\n    exports.compareNumbers = compareNumbers;\n    exports.compensateScroll = compensateScroll;\n    exports.computeClippingRect = computeClippingRect;\n    exports.computeEdges = computeEdges;\n    exports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;\n    exports.computeHeightAndMargins = computeHeightAndMargins;\n    exports.computeInnerRect = computeInnerRect;\n    exports.computeRect = computeRect;\n    exports.computeVisibleDayRange = computeVisibleDayRange;\n    exports.config = config;\n    exports.constrainPoint = constrainPoint;\n    exports.createDuration = createDuration;\n    exports.createElement = createElement;\n    exports.createEmptyEventStore = createEmptyEventStore;\n    exports.createEventInstance = createEventInstance;\n    exports.createFormatter = createFormatter;\n    exports.createPlugin = createPlugin;\n    exports.cssToStr = cssToStr;\n    exports.debounce = debounce;\n    exports.diffDates = diffDates;\n    exports.diffDayAndTime = diffDayAndTime;\n    exports.diffDays = diffDays;\n    exports.diffPoints = diffPoints;\n    exports.diffWeeks = diffWeeks;\n    exports.diffWholeDays = diffWholeDays;\n    exports.diffWholeWeeks = diffWholeWeeks;\n    exports.disableCursor = disableCursor;\n    exports.distributeHeight = distributeHeight;\n    exports.elementClosest = elementClosest;\n    exports.elementMatches = elementMatches;\n    exports.enableCursor = enableCursor;\n    exports.eventTupleToStore = eventTupleToStore;\n    exports.filterEventStoreDefs = filterEventStoreDefs;\n    exports.filterHash = filterHash;\n    exports.findChildren = findChildren;\n    exports.findElements = findElements;\n    exports.flexibleCompare = flexibleCompare;\n    exports.forceClassName = forceClassName;\n    exports.formatDate = formatDate;\n    exports.formatIsoTimeString = formatIsoTimeString;\n    exports.formatRange = formatRange;\n    exports.freezeRaw = freezeRaw;\n    exports.getAllDayHtml = getAllDayHtml;\n    exports.getClippingParents = getClippingParents;\n    exports.getDayClasses = getDayClasses;\n    exports.getElSeg = getElSeg;\n    exports.getRectCenter = getRectCenter;\n    exports.getRelevantEvents = getRelevantEvents;\n    exports.globalDefaults = globalDefaults;\n    exports.greatestDurationDenominator = greatestDurationDenominator;\n    exports.hasBgRendering = hasBgRendering;\n    exports.htmlEscape = htmlEscape;\n    exports.htmlToElement = htmlToElement;\n    exports.insertAfterElement = insertAfterElement;\n    exports.interactionSettingsStore = interactionSettingsStore;\n    exports.interactionSettingsToStore = interactionSettingsToStore;\n    exports.intersectRanges = intersectRanges;\n    exports.intersectRects = intersectRects;\n    exports.isArraysEqual = isArraysEqual;\n    exports.isDateSpansEqual = isDateSpansEqual;\n    exports.isInt = isInt;\n    exports.isInteractionValid = isInteractionValid;\n    exports.isMultiDayRange = isMultiDayRange;\n    exports.isObjectsSimilar = isObjectsSimilar;\n    exports.isPropsValid = isPropsValid;\n    exports.isSingleDay = isSingleDay;\n    exports.isValidDate = isValidDate;\n    exports.isValuesSimilar = isValuesSimilar;\n    exports.listenBySelector = listenBySelector;\n    exports.mapHash = mapHash;\n    exports.matchCellWidths = matchCellWidths;\n    exports.memoize = memoize;\n    exports.memoizeOutput = memoizeOutput;\n    exports.memoizeRendering = memoizeRendering;\n    exports.mergeEventStores = mergeEventStores;\n    exports.multiplyDuration = multiplyDuration;\n    exports.padStart = padStart;\n    exports.parseBusinessHours = parseBusinessHours;\n    exports.parseDragMeta = parseDragMeta;\n    exports.parseEventDef = parseEventDef;\n    exports.parseFieldSpecs = parseFieldSpecs;\n    exports.parseMarker = parse;\n    exports.pointInsideRect = pointInsideRect;\n    exports.prependToElement = prependToElement;\n    exports.preventContextMenu = preventContextMenu;\n    exports.preventDefault = preventDefault;\n    exports.preventSelection = preventSelection;\n    exports.processScopedUiProps = processScopedUiProps;\n    exports.rangeContainsMarker = rangeContainsMarker;\n    exports.rangeContainsRange = rangeContainsRange;\n    exports.rangesEqual = rangesEqual;\n    exports.rangesIntersect = rangesIntersect;\n    exports.refineProps = refineProps;\n    exports.removeElement = removeElement;\n    exports.removeExact = removeExact;\n    exports.renderDateCell = renderDateCell;\n    exports.requestJson = requestJson;\n    exports.sliceEventStore = sliceEventStore;\n    exports.startOfDay = startOfDay;\n    exports.subtractInnerElHeight = subtractInnerElHeight;\n    exports.translateRect = translateRect;\n    exports.uncompensateScroll = uncompensateScroll;\n    exports.undistributeHeight = undistributeHeight;\n    exports.unpromisify = unpromisify;\n    exports.version = version;\n    exports.whenTransitionDone = whenTransitionDone;\n    exports.wholeDivideDurations = wholeDivideDurations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL21haW4uanM/NTczZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksU0FDNEQ7QUFDaEUsQ0FBQywyQkFBMkI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDLGlEQUFpRDtBQUNqRCwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUscUZBQXFGO0FBQ3JGLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVELHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0NBQXNDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx5QkFBeUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFNBQVM7QUFDVCxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3QkFBd0I7QUFDeEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUJBQXFCO0FBQzVELHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSwwQkFBMEIsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLDJCQUEyQixFQUFFLFFBQVEsRUFBRTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULDBCQUEwQixnQkFBZ0IsMkNBQTJDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0IsNEJBQTRCLGdCQUFnQiw0Q0FBNEM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx3QkFBd0I7QUFDbkYsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsY0FBYzs7QUFFaEUsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIENvcmUgUGFja2FnZSB2NC4xLjBcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDE5IEFkYW0gU2hhd1xuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5GdWxsQ2FsZW5kYXIgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBDcmVhdGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgZWxlbWVudFByb3BIYXNoID0ge1xuICAgICAgICBjbGFzc05hbWU6IHRydWUsXG4gICAgICAgIGNvbFNwYW46IHRydWUsXG4gICAgICAgIHJvd1NwYW46IHRydWVcbiAgICB9O1xuICAgIHZhciBjb250YWluZXJUYWdIYXNoID0ge1xuICAgICAgICAnPHRyJzogJ3Rib2R5JyxcbiAgICAgICAgJzx0ZCc6ICd0cidcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgYXR0cnMsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN0eWxlKGVsLCBhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50UHJvcEhhc2hbYXR0ck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY29udGVudDsgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gcHJvY2VzcyBIVE1MIGluIGFueSB3YXlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGVuZFRvRWxlbWVudChlbCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodG1sVG9FbGVtZW50KGh0bWwpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwudHJpbSgpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wdXRlQ29udGFpbmVyVGFnKGh0bWwpKTtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHRtbFRvRWxlbWVudHMoaHRtbCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaHRtbFRvTm9kZUxpc3QoaHRtbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodG1sVG9Ob2RlTGlzdChodG1sKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnRyaW0oKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29tcHV0ZUNvbnRhaW5lclRhZyhodG1sKSk7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIC8vIGFzc3VtZXMgaHRtbCBhbHJlYWR5IHRyaW1tZWQgYW5kIHRhZyBuYW1lcyBhcmUgbG93ZXJjYXNlXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNvbnRhaW5lclRhZyhodG1sKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJUYWdIYXNoW2h0bWwuc3Vic3RyKDAsIDMpIC8vIGZhc3RlciB0aGFuIHVzaW5nIHJlZ2V4XG4gICAgICAgIF0gfHwgJ2Rpdic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZFRvRWxlbWVudChlbCwgY29udGVudCkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGVuZFRvRWxlbWVudChwYXJlbnQsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG5ld0VscyA9IG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHZhciBhZnRlckVsID0gcGFyZW50LmZpcnN0Q2hpbGQgfHwgbnVsbDsgLy8gaWYgbm8gZmlyc3RDaGlsZCwgd2lsbCBhcHBlbmQgdG8gZW5kLCBidXQgdGhhdCdzIG9rYXksIGIvYyB0aGVyZSB3ZXJlIG5vIGNoaWxkcmVuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0Vsc1tpXSwgYWZ0ZXJFbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXJFbGVtZW50KHJlZkVsLCBjb250ZW50KSB7XG4gICAgICAgIHZhciBuZXdFbHMgPSBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICB2YXIgYWZ0ZXJFbCA9IHJlZkVsLm5leHRTaWJsaW5nIHx8IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWZFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdFbHNbaV0sIGFmdGVyRWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICB2YXIgZWxzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbHMgPSBodG1sVG9FbGVtZW50cyhjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgZWxzID0gW2NvbnRlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBOb2RlW10gb3IgTm9kZUxpc3RcbiAgICAgICAgICAgIGVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFF1ZXJ5aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdFxuICAgIHZhciBtYXRjaGVzTWV0aG9kID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgdmFyIGNsb3Nlc3RNZXRob2QgPSBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0IHx8IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAvLyBwb2x5ZmlsbFxuICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlbGVtZW50Q2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RNZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNNZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICAvLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4gICAgLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4gICAgZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lciwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgICAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsTWF0Y2hlcztcbiAgICB9XG4gICAgLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuICAgIC8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHNcbiAgICBmdW5jdGlvbiBmaW5kQ2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnQ7XG4gICAgICAgIHZhciBhbGxNYXRjaGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuOyAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVzO1xuICAgIH1cbiAgICAvLyBBdHRyaWJ1dGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGZvcmNlQ2xhc3NOYW1lKGVsLCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHlsZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICAgICAgcG9pbnQubGVmdCA8IHJlY3QucmlnaHQgJiZcbiAgICAgICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXG4gICAgICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbiAgICBmdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludCwgcmVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG4gICAgZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICAgICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuICAgIGZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTG9naWMgZm9yIGRldGVybWluaW5nIGlmLCB3aGVuIHRoZSBlbGVtZW50IGlzIHJpZ2h0LXRvLWxlZnQsIHRoZSBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCBzaWRlXG4gICAgdmFyIGlzUnRsU2Nyb2xsYmFyT25MZWZ0ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICAgICAgaWYgKGlzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1J0bFNjcm9sbGJhck9uTGVmdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgICAgICB2YXIgb3V0ZXJFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdydGwnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICc8ZGl2PjwvZGl2PicpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyRWwpO1xuICAgICAgICB2YXIgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgcmVtb3ZlRWxlbWVudChvdXRlckVsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gY29tcHV0ZUVkZ2VzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cbiAgICAvLyByZXRpbmEgZGlzcGxheXMsIHJvdW5kaW5nLCBhbmQgSUUxMS4gTWFzc2FnZSB0aGVtIGludG8gYSB1c2FibGUgdmFsdWUuXG4gICAgZnVuY3Rpb24gc2FuaXRpemVTY3JvbGxiYXJXaWR0aCh3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXG4gICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcpIHtcbiAgICAgICAgaWYgKGdldFBhZGRpbmcgPT09IHZvaWQgMCkgeyBnZXRQYWRkaW5nID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIHZhciBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgICAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKSB8fCAwO1xuICAgICAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgICAgIHZhciBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICAgICAgdmFyIHNjcm9sbGJhckxlZnRSaWdodCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgoZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodCk7XG4gICAgICAgIHZhciBzY3JvbGxiYXJCb3R0b20gPSBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbSk7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJMZWZ0LFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGJvcmRlclJpZ2h0LFxuICAgICAgICAgICAgYm9yZGVyVG9wOiBib3JkZXJUb3AsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IGJvcmRlckJvdHRvbSxcbiAgICAgICAgICAgIHNjcm9sbGJhckJvdHRvbTogc2Nyb2xsYmFyQm90dG9tLFxuICAgICAgICAgICAgc2Nyb2xsYmFyTGVmdDogMCxcbiAgICAgICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpICYmIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XG4gICAgICAgICAgICByZXMuc2Nyb2xsYmFyTGVmdCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5zY3JvbGxiYXJSaWdodCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFkZGluZykge1xuICAgICAgICAgICAgcmVzLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApIHx8IDA7XG4gICAgICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVzLnBhZGRpbmdUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVzLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZykge1xuICAgICAgICBpZiAoZ29XaXRoaW5QYWRkaW5nID09PSB2b2lkIDApIHsgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG91dGVyUmVjdCA9IGNvbXB1dGVSZWN0KGVsKTtcbiAgICAgICAgdmFyIGVkZ2VzID0gY29tcHV0ZUVkZ2VzKGVsLCBnb1dpdGhpblBhZGRpbmcpO1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgbGVmdDogb3V0ZXJSZWN0LmxlZnQgKyBlZGdlcy5ib3JkZXJMZWZ0ICsgZWRnZXMuc2Nyb2xsYmFyTGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgICAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICAgICAgYm90dG9tOiBvdXRlclJlY3QuYm90dG9tIC0gZWRnZXMuYm9yZGVyQm90dG9tIC0gZWRnZXMuc2Nyb2xsYmFyQm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICAgICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgcmVzLnJpZ2h0IC09IGVkZ2VzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlUmVjdChlbCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlVmlld3BvcnRSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgcmlnaHQ6IHdpbmRvdy5wYWdlWE9mZnNldCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cucGFnZVlPZmZzZXQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKGVsKSB7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArXG4gICAgICAgICAgICBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Ub3AsIDEwKSArXG4gICAgICAgICAgICBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Cb3R0b20sIDEwKTtcbiAgICB9XG4gICAgLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuICAgIGZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyB3aWxsIHN0b3Agd2hlbiBnZXRzIHRvIGRvY3VtZW50IG9yIG51bGxcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVDbGlwcGluZ1JlY3QoZWwpIHtcbiAgICAgICAgcmV0dXJuIGdldENsaXBwaW5nUGFyZW50cyhlbClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUlubmVyUmVjdChlbCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY29uY2F0KGNvbXB1dGVWaWV3cG9ydFJlY3QoKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHJlY3QwLCByZWN0MSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdFJlY3RzKHJlY3QwLCByZWN0MSkgfHwgcmVjdDE7IC8vIHNob3VsZCBhbHdheXMgaW50ZXJzZWN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8vIEV2ZW50IERlbGVnYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVhbEhhbmRsZXIoZXYpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlYWxIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgcmVhbEhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb250YWluZXIsIHNlbGVjdG9yLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSkge1xuICAgICAgICB2YXIgY3VycmVudE1hdGNoZWRDaGlsZDtcbiAgICAgICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChldiwgbWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZENoaWxkICE9PSBjdXJyZW50TWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXIoZXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWxPbk1vdXNlTGVhdmVfMSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmVfMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBbmltYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICAgICAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICdtc1RyYW5zaXRpb25FbmQnLFxuICAgICAgICAndHJhbnNpdGlvbmVuZCdcbiAgICBdO1xuICAgIC8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRG9uZShlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIERBWV9JRFMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xuICAgIC8vIEFkZGluZ1xuICAgIGZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICAgICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICAgICAgYVsyXSArPSBuICogNztcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcbiAgICAgICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICAgICAgYVsyXSArPSBuO1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1zKG0sIG4pIHtcbiAgICAgICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICAgICAgYVs2XSArPSBuO1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG4gICAgfVxuICAgIC8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuICAgIGZ1bmN0aW9uIGRpZmZXZWVrcyhtMCwgbTEpIHtcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmRGF5cyhtMCwgbTEpIHtcbiAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmSG91cnMobTAsIG0xKSB7XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmZNaW51dGVzKG0wLCBtMSkge1xuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZlNlY29uZHMobTAsIG0xKSB7XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmZEYXlBbmRUaW1lKG0wLCBtMSkge1xuICAgICAgICB2YXIgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcbiAgICAgICAgdmFyIG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IE1hdGgucm91bmQoZGlmZkRheXMobTBkYXksIG0xZGF5KSksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xuICAgICAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKGQgIT09IG51bGwgJiYgZCAlIDcgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkIC8gNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU3RhcnQtT2ZcbiAgICBmdW5jdGlvbiBzdGFydE9mRGF5KG0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydE9mSG91cihtKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDSG91cnMoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydE9mU2Vjb25kKG0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICAgICAgbS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgICAgICBtLmdldFVUQ1NlY29uZHMoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBDb21wdXRhdGlvblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICB2YXIgdyA9IHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHksIGRvdywgZG95KTtcbiAgICAgICAgaWYgKHcgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xuICAgICAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHcsIG5leHRXKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgICAgIHZhciBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkobWFya2VyKTtcbiAgICAgICAgdmFyIGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbiAgICB9XG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIHZhciBmd2QgPSA3ICsgZG93IC0gZG95O1xuICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgIHZhciBmd2RsdyA9ICg3ICsgYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIGZ3ZF0pLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cbiAgICAvLyBBcnJheSBDb252ZXJzaW9uXG4gICAgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgICBkYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoYVswXSwgYVsxXSB8fCAwLCBhWzJdID09IG51bGwgPyAxIDogYVsyXSwgLy8gZGF5IG9mIG1vbnRoXG4gICAgICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYXRlVG9VdGNBcnJheShkYXRlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgICAgICAvLyBtYXNzYWdlIGlmIG9ubHkgZ2l2ZW4gYSB5ZWFyLlxuICAgICAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShEYXRlLCBhKSk7XG4gICAgfVxuICAgIC8vIE90aGVyIFV0aWxzXG4gICAgZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGltZUFzTXMobSkge1xuICAgICAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICAgICAgbS5nZXRVVENNaW51dGVzKCkgKiAxMDAwICogNjAgK1xuICAgICAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICAgICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgfVxuXG4gICAgdmFyIElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbiAgICB2YXIgUEFSU0VfUkUgPSAvXigtPykoPzooXFxkKylcXC4pPyhcXGQrKTooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlxcLihcXGRcXGRcXGQpKT8pPy87XG4gICAgLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdW5pdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT2JqZWN0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT2JqZWN0KChfYSA9IHt9LCBfYVt1bml0IHx8ICdtaWxsaXNlY29uZHMnXSA9IGlucHV0LCBfYSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgICAgICB2YXIgbSA9IFBBUlNFX1JFLmV4ZWMocyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgICAgICBkYXlzOiBzaWduICogKG1bMl0gPyBwYXJzZUludChtWzJdLCAxMCkgOiAwKSxcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgKG1bNV0gPyBwYXJzZUludChtWzVdLCAxMCkgOiAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgICAgICBkYXlzOiAob2JqLmRheXMgfHwgb2JqLmRheSB8fCAwKSArXG4gICAgICAgICAgICAgICAgZ2V0V2Vla3NGcm9tSW5wdXQob2JqKSAqIDcsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IChvYmouaG91cnMgfHwgb2JqLmhvdXIgfHwgMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAgICAgKG9iai5zZWNvbmRzIHx8IG9iai5zZWNvbmQgfHwgMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIChvYmoubWlsbGlzZWNvbmRzIHx8IG9iai5taWxsaXNlY29uZCB8fCBvYmoubXMgfHwgMCkgLy8gbXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NGcm9tSW5wdXQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmoud2Vla3MgfHwgb2JqLndlZWsgfHwgMDtcbiAgICB9XG4gICAgLy8gRXF1YWxpdHlcbiAgICBmdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcbiAgICAgICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICAgICAgZDAubW9udGhzID09PSBkMS5tb250aHMgJiZcbiAgICAgICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICAgICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NpbmdsZURheShkdXIpIHtcbiAgICAgICAgcmV0dXJuIGR1ci55ZWFycyA9PT0gMCAmJiBkdXIubW9udGhzID09PSAwICYmIGR1ci5kYXlzID09PSAxICYmIGR1ci5taWxsaXNlY29uZHMgPT09IDA7XG4gICAgfVxuICAgIC8vIFNpbXBsZSBNYXRoXG4gICAgZnVuY3Rpb24gYWRkRHVyYXRpb25zKGQwLCBkMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgICAgICBtb250aHM6IGQwLm1vbnRocyArIGQxLm1vbnRocyxcbiAgICAgICAgICAgIGRheXM6IGQwLmRheXMgKyBkMS5kYXlzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogZDEueWVhcnMgLSBkMC55ZWFycyxcbiAgICAgICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgICAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IGQxLm1pbGxpc2Vjb25kcyAtIGQwLm1pbGxpc2Vjb25kc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICAgICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICAgICAgZGF5czogZC5kYXlzICogbixcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENvbnZlcnNpb25zXG4gICAgLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcbiAgICBmdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzY1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgICAgICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDMwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gODY0ZTU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgICAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAoMTAwMCAqIDYwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDEwMDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICAgICAgcmV0dXJuIGR1ci55ZWFycyAqICgzNjUgKiA4NjRlNSkgK1xuICAgICAgICAgICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgIGR1ci5taWxsaXNlY29uZHM7XG4gICAgfVxuICAgIC8vIEFkdmFuY2VkIE1hdGhcbiAgICBmdW5jdGlvbiB3aG9sZURpdmlkZUR1cmF0aW9ucyhudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICAgIHZhciByZXMgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IElOVEVSTkFMX1VOSVRTW2ldO1xuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludChsb2NhbFJlcykgfHwgKHJlcyAhPT0gbnVsbCAmJiByZXMgIT09IGxvY2FsUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gbG9jYWxSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBkaXZpZGUgYnkgc29tZXRoaW5nIGJ1dCBjYW4ndCFcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyLCBkb250UmV0dXJuV2Vla3MpIHtcbiAgICAgICAgdmFyIG1zID0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgaWYgKG1zKSB7XG4gICAgICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbXMgLyAxMDAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBtcyAvICgxMDAwICogNjApIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBtcyAvICgxMDAwICogNjAgKiA2MCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVyLmRheXMpIHtcbiAgICAgICAgICAgIGlmICghZG9udFJldHVybldlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IGR1ci5kYXlzIC8gNyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdXIubW9udGhzKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdXIueWVhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiAwIH07XG4gICAgfVxuXG4gICAgLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBHaXZlbiB0aGUgc2Nyb2xsYmFyIHdpZHRocyBvZiBzb21lIG90aGVyIGNvbnRhaW5lciwgY3JlYXRlIGJvcmRlcnMvbWFyZ2lucyBvbiByb3dFbHMgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIGxlZnRcbiAgICAvLyBhbmQgcmlnaHQgc3BhY2UgdGhhdCB3YXMgb2Zmc2V0IGJ5IHRoZSBzY3JvbGxiYXJzLiBBIDEtcGl4ZWwgYm9yZGVyIGZpcnN0LCB0aGVuIG1hcmdpbiBiZXlvbmQgdGhhdC5cbiAgICBmdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpIHtcbiAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0KSB7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHJvd0VsLCB7XG4gICAgICAgICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb3dFbCwge1xuICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHNjcm9sbGJhcldpZHRocy5yaWdodCAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVuZG9lcyBjb21wZW5zYXRlU2Nyb2xsIGFuZCByZXN0b3JlcyBhbGwgYm9yZGVycy9tYXJnaW5zXG4gICAgZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0VsKSB7XG4gICAgICAgIGFwcGx5U3R5bGUocm93RWwsIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICcnLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcnLFxuICAgICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAnJyxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbiAgICBmdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xuICAgIGZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIHRvdGFsIGF2YWlsYWJsZSBoZWlnaHQgdG8gZmlsbCwgaGF2ZSBgZWxzYCAoZXNzZW50aWFsbHkgY2hpbGQgcm93cykgZXhwYW5kIHRvIGFjY29tb2RhdGUuXG4gICAgLy8gQnkgZGVmYXVsdCwgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHNob3J0ZXIgdGhhbiB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IGFyZSBleHBhbmRlZCB1bmlmb3JtbHksIG5vdCBjb25zaWRlcmluZ1xuICAgIC8vIGFueSBvdGhlciBlbHMgdGhhdCBhcmUgYWxyZWFkeSB0b28gdGFsbC4gaWYgYHNob3VsZFJlZGlzdHJpYnV0ZWAgaXMgb24sIGl0IGNvbnNpZGVycyB0aGVzZSB0YWxsIHJvd3MgYW5kXG4gICAgLy8gcmVkdWNlcyB0aGUgYXZhaWxhYmxlIGhlaWdodC5cbiAgICBmdW5jdGlvbiBkaXN0cmlidXRlSGVpZ2h0KGVscywgYXZhaWxhYmxlSGVpZ2h0LCBzaG91bGRSZWRpc3RyaWJ1dGUpIHtcbiAgICAgICAgLy8gKkZMT09SSU5HIE5PVEUqOiB3ZSBmbG9vciBpbiBjZXJ0YWluIHBsYWNlcyBiZWNhdXNlIHpvb20gY2FuIGdpdmUgaW5hY2N1cmF0ZSBmbG9hdGluZy1wb2ludCBkaW1lbnNpb25zLFxuICAgICAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXG4gICAgICAgIHZhciBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBlbHMubGVuZ3RoKTsgLy8gZm9yIG5vbi1sYXN0IGVsZW1lbnRcbiAgICAgICAgdmFyIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZWxzLmxlbmd0aCAtIDEpKTsgLy8gZm9yIGxhc3QgZWxlbWVudCAqRkxPT1JJTkcgTk9URSpcbiAgICAgICAgdmFyIGZsZXhFbHMgPSBbXTsgLy8gZWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBleHBhbmQuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgICAgICB2YXIgZmxleE9mZnNldHMgPSBbXTsgLy8gYW1vdW50IG9mIHZlcnRpY2FsIHNwYWNlIGl0IHRha2VzIHVwXG4gICAgICAgIHZhciBmbGV4SGVpZ2h0cyA9IFtdOyAvLyBhY3R1YWwgY3NzIGhlaWdodFxuICAgICAgICB2YXIgdXNlZEhlaWdodCA9IDA7XG4gICAgICAgIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpOyAvLyBnaXZlIGFsbCBlbGVtZW50cyB0aGVpciBuYXR1cmFsIGhlaWdodFxuICAgICAgICAvLyBmaW5kIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgKGV4cGFuZGFibGUpLlxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cbiAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgICB2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcbiAgICAgICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMoZWwpO1xuICAgICAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBmbGV4RWxzLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIGZsZXhPZmZzZXRzLnB1c2gobmF0dXJhbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgZmxleEhlaWdodHMucHVzaChlbC5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHN0cmV0Y2hlcyBwYXN0IHJlY29tbWVuZGVkIGhlaWdodCAobm9uLWV4cGFuZGFibGUpLiBtYXJrIHRoZSBzcGFjZSBhcyBvY2N1cGllZC5cbiAgICAgICAgICAgICAgICB1c2VkSGVpZ2h0ICs9IG5hdHVyYWxPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWFkanVzdCB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IHRvIG9ubHkgY29uc2lkZXIgdGhlIGhlaWdodCBhdmFpbGFibGUgdG8gbm9uLW1heGVkLW91dCByb3dzLlxuICAgICAgICBpZiAoc2hvdWxkUmVkaXN0cmlidXRlKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgLT0gdXNlZEhlaWdodDtcbiAgICAgICAgICAgIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGZsZXhFbHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZmxleEVscy5sZW5ndGggLSAxKSk7IC8vICpGTE9PUklORyBOT1RFKlxuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2lnbiBoZWlnaHRzIHRvIGFsbCBleHBhbmRhYmxlIGVsZW1lbnRzXG4gICAgICAgIGZsZXhFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgICAgIHZhciBtaW5PZmZzZXQgPSBpID09PSBmbGV4RWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcbiAgICAgICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gZmxleE9mZnNldHNbaV07XG4gICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IG1pbk9mZnNldCAtIChuYXR1cmFsT2Zmc2V0IC0gbmF0dXJhbEhlaWdodCk7IC8vIHN1YnRyYWN0IHRoZSBtYXJnaW4vcGFkZGluZ1xuICAgICAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHsgLy8gd2UgY2hlY2sgdGhpcyBhZ2FpbiBiZWNhdXNlIHJlZGlzdHJpYnV0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0aGluZ3NcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVW5kb2VzIGRpc3RydWJ1dGVIZWlnaHQsIHJlc3RvcmluZyBhbGwgZWxzIHRvIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XG4gICAgZnVuY3Rpb24gdW5kaXN0cmlidXRlSGVpZ2h0KGVscykge1xuICAgICAgICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYGVsc2AsIGEgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXG4gICAgLy8gY2VsbHMgdG8gYmUgdGhhdCB3aWR0aC5cbiAgICAvLyBQUkVSRVFVSVNJVEU6IGlmIHlvdSB3YW50IGEgY2VsbCB0byB0YWtlIHVwIHdpZHRoLCBpdCBuZWVkcyB0byBoYXZlIGEgc2luZ2xlIGlubmVyIGVsZW1lbnQgdy8gZGlzcGxheTppbmxpbmVcbiAgICBmdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XG4gICAgICAgIHZhciBtYXhJbm5lcldpZHRoID0gMDtcbiAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJFbCA9IGVsLmZpcnN0Q2hpbGQ7IC8vIGhvcGVmdWxseSBhbiBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaW5uZXJFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyV2lkdGhfMSA9IGlubmVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyV2lkdGhfMSA+IG1heElubmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5uZXJXaWR0aCA9IGlubmVyV2lkdGhfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtYXhJbm5lcldpZHRoKys7IC8vIHNvbWV0aW1lcyBub3QgYWNjdXJhdGUgb2Ygd2lkdGggdGhlIHRleHQgbmVlZHMgdG8gc3RheSBvbiBvbmUgbGluZS4gaW5zdXJhbmNlXG4gICAgICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBtYXhJbm5lcldpZHRoICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXhJbm5lcldpZHRoO1xuICAgIH1cbiAgICAvLyBHaXZlbiBvbmUgZWxlbWVudCB0aGF0IHJlc2lkZXMgaW5zaWRlIGFub3RoZXIsXG4gICAgLy8gU3VidHJhY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGVsZW1lbnQgZnJvbSB0aGUgb3V0ZXIgZWxlbWVudC5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdElubmVyRWxIZWlnaHQob3V0ZXJFbCwgaW5uZXJFbCkge1xuICAgICAgICAvLyBlZmZpbicgSUU4LzkvMTAvMTEgc29tZXRpbWVzIHJldHVybnMgMCBmb3IgZGltZW5zaW9ucy4gdGhpcyB3ZWlyZCBoYWNrIHdhcyB0aGUgb25seSB0aGluZyB0aGF0IHdvcmtlZFxuICAgICAgICB2YXIgcmVmbG93U3R5bGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgbGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxuICAgICAgICB9O1xuICAgICAgICBhcHBseVN0eWxlKG91dGVyRWwsIHJlZmxvd1N0eWxlUHJvcHMpO1xuICAgICAgICBhcHBseVN0eWxlKGlubmVyRWwsIHJlZmxvd1N0eWxlUHJvcHMpO1xuICAgICAgICB2YXIgZGlmZiA9IG91dGVyRWwub2Zmc2V0SGVpZ2h0IC0gaW5uZXJFbC5vZmZzZXRIZWlnaHQ7IC8vIGdyYWIgdGhlIGRpbWVuc2lvbnNcbiAgICAgICAgLy8gdW5kbyBoYWNrXG4gICAgICAgIHZhciByZXNldFN0eWxlUHJvcHMgPSB7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfTtcbiAgICAgICAgYXBwbHlTdHlsZShvdXRlckVsLCByZXNldFN0eWxlUHJvcHMpO1xuICAgICAgICBhcHBseVN0eWxlKGlubmVyRWwsIHJlc2V0U3R5bGVQcm9wcyk7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICAvKiBTZWxlY3Rpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBmdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmMtdW5zZWxlY3RhYmxlJyk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgIH1cbiAgICAvKiBDb250ZXh0IE1lbnVcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBmdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgfVxuICAgIC8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIGZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgICAgICB2YXIgc3BlY3MgPSBbXTtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xuICAgICAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGVjcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgY21wO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWMpIHtcbiAgICAgICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9XG4gICAgLyogU3RyaW5nIFV0aWxpdGllc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICAgICAgdmFyIHMgPSBTdHJpbmcodmFsKTtcbiAgICAgICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xuICAgIH1cbiAgICAvKiBOdW1iZXIgVXRpbGl0aWVzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gJSAxID09PSAwO1xuICAgIH1cbiAgICAvKiBXZWlyZCBVdGlsaXRpZXNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBmdW5jdGlvbiBhcHBseUFsbChmdW5jdGlvbnMsIHRoaXNPYmosIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbnMgPT09ICdmdW5jdGlvbicpIHsgLy8gc3VwcGxpZWQgYSBzaW5nbGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGZ1bmN0aW9ucyA9IFtmdW5jdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHJldCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQgPSBmdW5jdGlvbnNbaV0uYXBwbHkodGhpc09iaiwgYXJncykgfHwgcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAgIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHZhciBhcmdzO1xuICAgICAgICB2YXIgY29udGV4dDtcbiAgICAgICAgdmFyIHRpbWVzdGFtcDtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTnVtYmVyIGFuZCBCb29sZWFuIGFyZSBvbmx5IHR5cGVzIHRoYXQgZGVmYXVsdHMgb3Igbm90IGNvbXB1dGVkIGZvclxuICAgIC8vIFRPRE86IHdyaXRlIG1vcmUgY29tbWVudHNcbiAgICBmdW5jdGlvbiByZWZpbmVQcm9wcyhyYXdQcm9wcywgcHJvY2Vzc29ycywgZGVmYXVsdHMsIGxlZnRvdmVyUHJvcHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzID09PSB2b2lkIDApIHsgZGVmYXVsdHMgPSB7fTsgfVxuICAgICAgICB2YXIgcmVmaW5lZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvY2Vzc29ycykge1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IHByb2Nlc3NvcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChyYXdQcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRba2V5XSA9IHR5cGVvZiByYXdQcm9wc1trZXldID09PSAnZnVuY3Rpb24nID8gcmF3UHJvcHNba2V5XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3NvcikgeyAvLyBhIHJlZmluaW5nIGZ1bmN0aW9uP1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW2tleV0gPSBwcm9jZXNzb3IocmF3UHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZmF1bHRzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHJlZmluZWRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGNvbXB1dGUgYSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRba2V5XSA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgaXMgZGVmYXVsdCBmb3IgU3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwcm9jZXNzb3IgfHwgcHJvY2Vzc29yID09PSBOdW1iZXIgfHwgcHJvY2Vzc29yID09PSBCb29sZWFuIHx8IHByb2Nlc3NvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtrZXldID0gbnVsbDsgLy8gYXNzaWduIG51bGwgZm9yIG90aGVyIG5vbi1jdXN0b20gcHJvY2Vzc29yIGZ1bmNzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW2tleV0gPSBwcm9jZXNzb3IobnVsbCk7IC8vIHJ1biB0aGUgY3VzdG9tIHByb2Nlc3NvciBmdW5jXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0b3ZlclByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdG92ZXJQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmluZWQ7XG4gICAgfVxuICAgIC8qXG4gICAgR2V0IGEgc25hcHNob3Qgb2YgYW4gb2JqZWN0LCBzbyB3ZSBjYW4gY29tcGFyZSBpdCB0byBsYXRlciByZXZpc2lvbnMuXG4gICAgSW50ZW50aW9uYWxseSBvbmx5IHdvcmtzIHdpdGggYXJyYXlzLCBqYWphXG4gICAgKi9cbiAgICBmdW5jdGlvbiBmcmVlemVSYXcocmF3KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyYXcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIC8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIGV4YWN0IGR1cmF0aW9uLFxuICAgIC8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbiAgICBmdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICAgICAgdmFyIGRheUNudCA9IE1hdGguZmxvb3IoZGlmZkRheXModGltZWRSYW5nZS5zdGFydCwgdGltZWRSYW5nZS5lbmQpKSB8fCAxO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgICAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH1cbiAgICAvLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuICAgIC8vIFRPRE86IGdpdmUgbmV4dERheVRocmVzaG9sZCBhIGRlZmF1bHQgYXJnXG4gICAgZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgICAgIGlmIChuZXh0RGF5VGhyZXNob2xkID09PSB2b2lkIDApIHsgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApOyB9XG4gICAgICAgIHZhciBzdGFydERheSA9IG51bGw7XG4gICAgICAgIHZhciBlbmREYXkgPSBudWxsO1xuICAgICAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIGVuZERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5lbmQpO1xuICAgICAgICAgICAgdmFyIGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgICAgIC8vIGJleW9uZCB0aGUgbmV4dCBkYXkgdGhyZXNob2xkLCBhZGp1c3QgdGhlIGVuZCB0byBiZSB0aGUgZXhjbHVzaXZlIGVuZCBvZiBgZW5kRGF5YC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhlbmREYXksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lZFJhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICAgICAgaWYgKGVuZERheSAmJiBlbmREYXkgPD0gc3RhcnREYXkpIHtcbiAgICAgICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG4gICAgfVxuICAgIC8vIHNwYW5zIGZyb20gb25lIGRheSBpbnRvIGFub3RoZXI/XG4gICAgZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhciB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzKHZpc2libGVSYW5nZS5zdGFydCwgdmlzaWJsZVJhbmdlLmVuZCkgPiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICAgICAgaWYgKGxhcmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlTW9udGhzKGRhdGUwLCBkYXRlMSksICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUmVjdXJyaW5nKGV2ZW50SW5wdXQsIGFsbERheURlZmF1bHQsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzLCBsZWZ0b3ZlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN1cnJpbmdUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvY2FsTGVmdG92ZXJzID0ge307XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcmVjdXJyaW5nVHlwZXNbaV0ucGFyc2UoZXZlbnRJbnB1dCwgbG9jYWxMZWZ0b3ZlcnMsIGRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxEYXkgPSBsb2NhbExlZnRvdmVycy5hbGxEYXk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsTGVmdG92ZXJzLmFsbERheTsgLy8gcmVtb3ZlIGZyb20gbGVmdG92ZXJzXG4gICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGFsbERheURlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX19hc3NpZ24obGVmdG92ZXJzLCBsb2NhbExlZnRvdmVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVEYXRhOiBwYXJzZWQudHlwZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgRXZlbnQgTVVTVCBoYXZlIGEgcmVjdXJyaW5nRGVmXG4gICAgKi9cbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICAgICAgdmFyIHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSB0eXBlRGVmLmV4cGFuZChldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgICAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4gICAgLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG4gICAgZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzKSB7XG4gICAgICAgIHZhciBkZXN0ID0ge307XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIGNvbXBsZXhPYmpzO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgdmFyIHByb3BzO1xuICAgICAgICBpZiAoY29tcGxleFByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGxleFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGNvbXBsZXhQcm9wc1tpXTtcbiAgICAgICAgICAgICAgICBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3RcbiAgICAgICAgZm9yIChpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcE9ianNbaV07XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7IC8vIGlmIGFscmVhZHkgYXNzaWduZWQgYnkgcHJldmlvdXMgcHJvcHMgb3IgY29tcGxleCBwcm9wcywgZG9uJ3QgcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgICAgICB2YXIgbmV3SGFzaCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hhc2g7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGEpIHtcbiAgICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhXzEgPSBhOyBfaSA8IGFfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYV8xW19pXTtcbiAgICAgICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIHNvdXJjZUlkLCBjYWxlbmRhciwgYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgICAgIHZhciB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIHNvdXJjZUlkLCBjYWxlbmRhciwgYWxsb3dPcGVuUmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSkge1xuICAgICAgICBpZiAoZXZlbnRTdG9yZSA9PT0gdm9pZCAwKSB7IGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgfVxuICAgICAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICAgICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBldmVudFN0b3JlLmluc3RhbmNlc1t0dXBsZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHR1cGxlLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjYWxlbmRhcikge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGNhbGVuZGFyLmRhdGVFbnY7XG4gICAgICAgIHZhciBkZWZzID0gZXZlbnRTdG9yZS5kZWZzLCBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nIHJlY3VycmluZyBpbnN0YW5jZXNcbiAgICAgICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuICFkZWZzW2luc3RhbmNlLmRlZklkXS5yZWN1cnJpbmdEZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydHMgPSBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZGVmLCBmcmFtaW5nUmFuZ2UsIGNhbGVuZGFyLmRhdGVFbnYsIGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gZGVmLnJlY3VycmluZ0RlZi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0YXJ0c18xID0gc3RhcnRzOyBfaSA8IHN0YXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydHNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG4gICAgfVxuICAgIC8vIHJldHJpZXZlcyBldmVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIGdyb3VwSWQgYXMgdGhlIGluc3RhbmNlIHNwZWNpZmllZCBieSBgaW5zdGFuY2VJZGBcbiAgICAvLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4gICAgLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuICAgIGZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlSWQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGRlZl8xID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICAgICAgdmFyIG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGxvb2tEZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZl8xLCBsb29rRGVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICAgICAgICAgIG5ld1N0b3JlLmRlZnNbZGVmXzEuZGVmSWRdID0gZGVmXzE7XG4gICAgICAgICAgICBuZXdTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlZjAuZ3JvdXBJZCAmJiBkZWYwLmdyb3VwSWQgPT09IGRlZjEuZ3JvdXBJZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjYWxlbmRhcikge1xuICAgICAgICB2YXIgY2FsRWFjaFRyYW5zZm9ybSA9IGNhbGVuZGFyLm9wdCgnZXZlbnREYXRhVHJhbnNmb3JtJyk7XG4gICAgICAgIHZhciBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgICAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgc291cmNlRWFjaFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGNhbEVhY2hUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdFdmVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICAgICAgdmFyIHJlZmluZWRFdmVudHM7XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcmF3RXZlbnRzXzIgPSByYXdFdmVudHM7IF9pIDwgcmF3RXZlbnRzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhd0V2ZW50ID0gcmF3RXZlbnRzXzJbX2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgICAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZzOiBfX2Fzc2lnbih7fSwgc3RvcmUwLmRlZnMsIHN0b3JlMS5kZWZzKSxcbiAgICAgICAgICAgIGluc3RhbmNlczogX19hc3NpZ24oe30sIHN0b3JlMC5pbnN0YW5jZXMsIHN0b3JlMS5pbnN0YW5jZXMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZzW2luc3RhbmNlLmRlZklkXTsgLy8gc3RpbGwgZXhpc3RzP1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZGVmczogZGVmcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xuICAgICAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfVxuICAgIC8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXG4gICAgLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuICAgIGZ1bmN0aW9uIGludmVydFJhbmdlcyhyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xuICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBkYXRlUmFuZ2U7XG4gICAgICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICAgICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgICAgIGlmIChkYXRlUmFuZ2Uuc3RhcnQgPiBzdGFydCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuICAgICAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoc3RhcnQgPCBjb25zdHJhaW50UmFuZ2UuZW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3RcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlMC5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlMC5lbmQ7XG4gICAgICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UxLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShNYXRoLm1heChzdGFydC52YWx1ZU9mKCksIHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UxLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgbmV3UmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgICAgICAocmFuZ2UwLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuZW5kLnZhbHVlT2YoKSkgPT09IChyYW5nZTEuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5lbmQudmFsdWVPZigpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgICAgIHJldHVybiAocmFuZ2UwLmVuZCA9PT0gbnVsbCB8fCByYW5nZTEuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UwLmVuZCA+IHJhbmdlMS5zdGFydCkgJiZcbiAgICAgICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXG4gICAgICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAgICAgKHJhbmdlLmVuZCA9PT0gbnVsbCB8fCBkYXRlIDwgcmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuICAgIC8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuICAgIGZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUocmFuZ2UuZW5kLnZhbHVlT2YoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgICAgICB2YXIgcmVtb3ZlQ250ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBleGFjdFZhbCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZW1vdmVDbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlQ250O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSkge1xuICAgICAgICB2YXIgbGVuID0gYTAubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGEwW2ldICE9PSBhMVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3MgfHwgIWlzQXJyYXlzRXF1YWwoYXJncywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICBhbHdheXMgZXhlY3V0ZXMgdGhlIHdvcmtlckZ1bmMsIGJ1dCBpZiB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHRoZSBwcmV2aW91cyByZXN1bHQsXG4gICAgcmV0dXJuIHRoZSBwcmV2aW91cyByZXN1bHQgaW5zdGVhZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVPdXRwdXQod29ya2VyRnVuYywgZXF1YWxpdHlGdW5jKSB7XG4gICAgICAgIHZhciBjYWNoZWRSZXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1JlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXMgPT09IG51bGwgfHwgIShjYWNoZWRSZXMgPT09IG5ld1JlcyB8fCBlcXVhbGl0eUZ1bmMoY2FjaGVkUmVzLCBuZXdSZXMpKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJlcyA9IG5ld1JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgICAgICB3ZWVrOiAzLFxuICAgICAgICBzZXBhcmF0b3I6IDAsXG4gICAgICAgIG9taXRaZXJvTWludXRlOiAwLFxuICAgICAgICBtZXJpZGllbTogMCxcbiAgICAgICAgb21pdENvbW1hczogMFxuICAgIH07XG4gICAgdmFyIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgICAgICB0aW1lWm9uZU5hbWU6IDcsXG4gICAgICAgIGVyYTogNixcbiAgICAgICAgeWVhcjogNSxcbiAgICAgICAgbW9udGg6IDQsXG4gICAgICAgIGRheTogMixcbiAgICAgICAgd2Vla2RheTogMixcbiAgICAgICAgaG91cjogMSxcbiAgICAgICAgbWludXRlOiAxLFxuICAgICAgICBzZWNvbmQ6IDFcbiAgICB9O1xuICAgIHZhciBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG4gICAgdmFyIENPTU1BX1JFID0gLywvZzsgLy8gd2UgbmVlZCByZSBmb3IgZ2xvYmFsbmVzc1xuICAgIHZhciBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG4gICAgdmFyIExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG4gICAgdmFyIFVUQ19SRSA9IC9VVEN8R01ULztcbiAgICB2YXIgTmF0aXZlRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOYXRpdmVGb3JtYXR0ZXIoZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIHZhciBzZXZlcml0eSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xIGluIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lXzEgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFuZGFyZERhdGVQcm9wcyA9IHN0YW5kYXJkRGF0ZVByb3BzO1xuICAgICAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyA9IG1lbW9pemUoYnVpbGRGb3JtYXR0aW5nRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YW5kYXJkRGF0ZVByb3BzID0gX2Euc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgPSBfYS5leHRlbmRlZFNldHRpbmdzO1xuICAgICAgICAgICAgdmFyIGRpZmZTZXZlcml0eSA9IGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoc3RhcnQubWFya2VyLCBlbmQubWFya2VyLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKTtcbiAgICAgICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XG4gICAgICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgICAgICBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSAxOyAvLyBtYWtlIGl0IGxvb2sgbGlrZSB0aGUgZGF0ZXMgYXJlIG9ubHkgZGlmZmVyZW50IGluIHRlcm1zIG9mIHRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBmdWxsMSA9IHRoaXMuZm9ybWF0KGVuZCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFydGlhbDAgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoc3RhcnQpO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gZXh0ZW5kZWRTZXR0aW5ncy5zZXBhcmF0b3IgfHwgJyc7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XG4gICAgICAgIH07XG4gICAgICAgIE5hdGl2ZUZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TGFyZ2VzdFVuaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd3ZWVrJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYXRpdmVGb3JtYXR0ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDEgJiYgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFdlZWtOdW1iZXIoY29udGV4dC5jb21wdXRlV2Vla051bWJlcihkYXRlLm1hcmtlciksIGNvbnRleHQud2Vla0xhYmVsLCBjb250ZXh0LmxvY2FsZSwgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTsgLy8gY29weVxuICAgICAgICBleHRlbmRlZFNldHRpbmdzID0gX19hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgICAgIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpO1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcbiAgICAgICAgdmFyIG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgICAgIHZhciB6ZXJvRm9ybWF0OyAvLyBuZWVkZWQ/XG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgICAgICB2YXIgemVyb1Byb3BzID0gX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXG4gICAgICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gZGF0ZS5tYXJrZXI7XG4gICAgICAgICAgICB2YXIgZm9ybWF0O1xuICAgICAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XG4gICAgICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBhIGJyb3dzZXIgaW5jb25zaXN0ZW5jeSB3aGVyZSBmb3JtYXR0aW5nIHRoZSB0aW1lem9uZVxuICAgICAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICAgICAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLmhvdXIpIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5taW51dGUpIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID0gJ3Nob3J0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICAgICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUgJiYgKHN0YW5kYXJkRGF0ZVByb3BzLnNlY29uZCB8fCBzdGFuZGFyZERhdGVQcm9wcy5taWxsaXNlY29uZCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgICAgIGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKENPTU1BX1JFLCAnJykudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCc6MDAnLCAnJyk7IC8vIHplcm9Gb3JtYXQgZG9lc24ndCBhbHdheXMgYWNoaWV2ZSB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgTUVSSURJRU1fUkUgbGlrZXMgdG8gZWF0IHVwIGxvYWRpbmcgc3BhY2VzXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSArICdtJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcbiAgICAgICAgcyA9IHMudHJpbSgpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgcyA9IHMucmVwbGFjZShVVENfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0em9TdHI7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICAgICAgaWYgKCFyZXBsYWNlZCkge1xuICAgICAgICAgICAgcyArPSAnICcgKyB0em9TdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrTGFiZWwsIGxvY2FsZSwgZGlzcGxheSkge1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgaWYgKGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHdlZWtMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICAgICAgcGFydHMucHVzaCh3ZWVrTGFiZWwsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb25zaWRlcmVkICdudW1lcmljJ1xuICAgICAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xuICAgICAgICBpZiAobG9jYWxlLm9wdGlvbnMuaXNSdGwpIHsgLy8gVE9ETzogdXNlIGNvbnRyb2wgY2hhcmFjdGVycyBpbnN0ZWFkP1xuICAgICAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9XG4gICAgLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIDAgPSBleGFjdGx5IHRoZSBzYW1lXG4gICAgLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4gICAgLy8gYW5kIGJpZ2dlclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoZDAsIGQxLCBjYSkge1xuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMsIGJpZ2dlc3RVbml0KSB7XG4gICAgICAgIHZhciBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEobmFtZV8yIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXzJdIDw9IGJpZ2dlc3RVbml0KSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV8yXSA9IG9wdGlvbnNbbmFtZV8yXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGlhbE9wdGlvbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICAgICAgdmFyIGkwID0gMDtcbiAgICAgICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICAgICAgaWYgKGZvdW5kMCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiZWZvcmUwID0gZnVsbDAuc3Vic3RyKDAsIGZvdW5kMCk7XG4gICAgICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICAgICAgdmFyIGkxID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kMSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUxID0gZnVsbDEuc3Vic3RyKDAsIGZvdW5kMSk7XG4gICAgICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZTAgPT09IGJlZm9yZTEgJiYgYWZ0ZXIwID09PSBhZnRlcjEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiBhZnRlcjBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLypcbiAgICBUT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuICAgICovXG4gICAgLypcbiAgICBBdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbiAgICBJdCByZWNlaXZlcyB0aGlzIGF0IHRoZSB0aW1lIG9mIGZvcm1hdHRpbmcsIGFzIGEgc2V0dGluZy5cbiAgICAqL1xuICAgIHZhciBDbWRGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENtZEZvcm1hdHRlcihjbWRTdHIsIHNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XG4gICAgICAgICAgICB0aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBDbWRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIHRoaXMuc2VwYXJhdG9yKSk7XG4gICAgICAgIH07XG4gICAgICAgIENtZEZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCB0aGlzLnNlcGFyYXRvcikpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ21kRm9ybWF0dGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRnVuY0Zvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRnVuY0Zvcm1hdHRlcihmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIEZ1bmNGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgRnVuY0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGdW5jRm9ybWF0dGVyO1xuICAgIH0oKSk7XG5cbiAgICAvLyBGb3JtYXR0ZXIgT2JqZWN0IENyZWF0aW9uXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKGlucHV0LCBkZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0U2VwYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX19hc3NpZ24oeyBzZXBhcmF0b3I6IGRlZmF1bHRTZXBhcmF0b3IgfSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0LCBkZWZhdWx0U2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY0Zvcm1hdHRlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RyaW5nIFV0aWxzXG4gICAgLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuICAgIGZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHMgPSBtYXJrZXIudG9JU09TdHJpbmcoKTtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1QwMDowMDowMFonLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgICAgICAgICBpZiAodGltZVpvbmVPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lWm9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBpdHMgVVRDLTAgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgWlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcbiAgICAgICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICAgICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzLCBkb0lzbykge1xuICAgICAgICBpZiAoZG9Jc28gPT09IHZvaWQgMCkgeyBkb0lzbyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhtaW51dGVzKTtcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MCk7XG4gICAgICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgICAgIGlmIChkb0lzbykge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyBwYWRTdGFydChob3VycywgMikgKyAnOicgKyBwYWRTdGFydChtaW5zLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnR01UJyArIHNpZ24gKyBob3VycyArIChtaW5zID8gJzonICsgcGFkU3RhcnQobWlucywgMikgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXJnIFV0aWxzXG4gICAgZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIHZhciBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLFxuICAgICAgICAgICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgICAgICBzZXBhcmF0b3I6IHNlcGFyYXRvclxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICAgICAgdmFyIGEgPSBjYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KGRhdGVJbmZvLm1hcmtlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlSW5mby50aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIGFycmF5OiBhLFxuICAgICAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgICAgIG1vbnRoOiBhWzFdLFxuICAgICAgICAgICAgZGF5OiBhWzJdLFxuICAgICAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgICAgIG1pbnV0ZTogYVs0XSxcbiAgICAgICAgICAgIHNlY29uZDogYVs1XSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIEV2ZW50U291cmNlQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudFNvdXJjZUFwaShjYWxlbmRhciwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVmZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlQXBpLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnB1YmxpY0lkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVsZXZhbnQgdG8ganNvbi1mZWVkIGV2ZW50IHNvdXJjZXNcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlQXBpO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRXZlbnRBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50QXBpKGNhbGVuZGFyLCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IG1ha2UgZXZlbnQgc3RydWN0IG1vcmUgcmVzcG9uc2libGUgZm9yIHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gREFURV9QUk9QUykgO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBOT05fREFURV9QUk9QUykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgTk9OX0RBVEVfUFJPUFNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gTk9OX0RBVEVfUFJPUFNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiAoX2EgPSB7fSwgX2FbbmFtZV0gPSB2YWwsIF9hKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBVTlNDT1BFRF9FVkVOVF9VSV9QUk9QUykge1xuICAgICAgICAgICAgICAgIHZhciB1aSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFVOU0NPUEVEX0VWRU5UX1VJX1BST1BTW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IFVOU0NPUEVEX0VWRU5UX1VJX1BST1BTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpID0geyBiYWNrZ3JvdW5kQ29sb3I6IHZhbCwgYm9yZGVyQ29sb3I6IHZhbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpID0geyBzdGFydEVkaXRhYmxlOiB2YWwsIGR1cmF0aW9uRWRpdGFibGU6IHZhbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdWkgPSAoX2IgPSB7fSwgX2JbbmFtZV0gPSB2YWwsIF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpOiB1aSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFeHRlbmRlZFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0U3RhcnQgPSBmdW5jdGlvbiAoc3RhcnRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY2FsZW5kYXIuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICYmIHRoaXMuX2luc3RhbmNlKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgICAgIHZhciBlbmREZWx0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ0R1cmF0aW9uID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIGluc3RhbmNlUmFuZ2UuZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0R1cmF0aW9uID0gZGlmZkRhdGVzKHN0YXJ0LCBpbnN0YW5jZVJhbmdlLmVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZERlbHRhID0gc3VidHJhY3REdXJhdGlvbnMob3JpZ0R1cmF0aW9uLCBuZXdEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSwgZW5kRGVsdGE6IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0RW5kID0gZnVuY3Rpb24gKGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jYWxlbmRhci5kYXRlRW52O1xuICAgICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0RGF0ZXMgPSBmdW5jdGlvbiAoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NhbGVuZGFyLmRhdGVFbnY7XG4gICAgICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVuZCkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VSYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoaW5zdGFuY2VSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBzdGFydERlbHRhLCBlbmREZWx0YTogZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlRW5kID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZURhdGVzID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEsIGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEFsbERheSA9IGZ1bmN0aW9uIChhbGxEYXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBhbGxEYXkgfTtcbiAgICAgICAgICAgIHZhciBtYWludGFpbkR1cmF0aW9uID0gb3B0aW9ucy5tYWludGFpbkR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKG1haW50YWluRHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jYWxlbmRhci5vcHQoJ2FsbERheU1haW50YWluRHVyYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChmb3JtYXRJbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jYWxlbmRhci5kYXRlRW52O1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0LCB0aGlzLl9jYWxlbmRhci5vcHQoJ2RlZmF1bHRSYW5nZVNlcGFyYXRvcicpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTVVUQVRFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlLmluc3RhbmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiBtdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZnJvbUFwaTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBldmVudFN0b3JlID0gdGhpcy5fY2FsZW5kYXIuc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfREVGJyxcbiAgICAgICAgICAgICAgICBkZWZJZDogdGhpcy5fZGVmLmRlZklkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdGhpcy5fZGVmLnNvdXJjZUlkO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHRoaXMuX2NhbGVuZGFyLCB0aGlzLl9jYWxlbmRhci5zdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZW5kXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGFibGUgcHJvcHMgdGhhdCBhbGwgYWNjZXNzIHRoZSBkZWZcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJncm91cElkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImFsbERheVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJyZW5kZXJpbmdcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYucmVuZGVyaW5nOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydEVkaXRhYmxlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnN0YXJ0RWRpdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImR1cmF0aW9uRWRpdGFibGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY29uc3RyYWludFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJvdmVybGFwXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLm92ZXJsYXA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImFsbG93XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJib3JkZXJDb2xvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5ib3JkZXJDb2xvcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwidGV4dENvbG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XG4gICAgICAgICAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY2xhc3NOYW1lczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZXh0ZW5kZWRQcm9wc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50QXBpO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgIFNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGZyYW1pbmdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgICAgIHZhciBpbnZlcnNlQmdCeURlZklkID0ge307XG4gICAgICAgIHZhciBkZWZCeUdyb3VwSWQgPSB7fTtcbiAgICAgICAgdmFyIGJnUmFuZ2VzID0gW107XG4gICAgICAgIHZhciBmZ1JhbmdlcyA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpO1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgaWYgKGRlZi5yZW5kZXJpbmcgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2RlZklkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAgICAgdmFyIHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIHZhciBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIHZhciBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpc2libGVEYXlSYW5nZShvcmlnUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIDpcbiAgICAgICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgICAgICB2YXIgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLnJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtpbnN0YW5jZS5kZWZJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChkZWYucmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWk6IHVpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMSA9IGludmVydGVkUmFuZ2VzOyBfaSA8IGludmVydGVkUmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludmVydGVkUmFuZ2UgPSBpbnZlcnRlZFJhbmdlc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aTogdWksXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGludmVydGVkUmFuZ2VzXzIgPSBpbnZlcnRlZFJhbmdlczsgX2EgPCBpbnZlcnRlZFJhbmdlc18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMltfYV07XG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlZjogZXZlbnRTdG9yZS5kZWZzW2RlZklkXSxcbiAgICAgICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgICAgIHJldHVybiBkZWYucmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlclNlZ3NWaWFFbHModmlldywgc2VncywgaXNNaXJyb3IpIHtcbiAgICAgICAgaWYgKHZpZXcuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50UmVuZGVyJykpIHtcbiAgICAgICAgICAgIHNlZ3MgPSBzZWdzLmZpbHRlcihmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbSA9IHZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaSh2aWV3LmNhbGVuZGFyLCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTWlycm9yOiBpc01pcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc2VnLnJhbmdlIG9uY2UgYWxsIGNvbXBvbmVudHMgY29uc2lzdGVudGx5IGdlbmVyYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogc2VnLmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbSA9PT0gZmFsc2UpIHsgLy8gbWVhbnMgZG9uJ3QgcmVuZGVyIGF0IGFsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1c3RvbSAmJiBjdXN0b20gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gY3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgIHNldEVsU2VnKHNlZy5lbCwgc2VnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgICAgICBlbC5mY1NlZyA9IHNlZztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmZjU2VnIHx8IG51bGw7XG4gICAgfVxuICAgIC8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG4gICAgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50RGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlRXZlbnRVaShldmVudERlZiwgZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgIHZhciB1aXMgPSBbXTtcbiAgICAgICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1snJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKTtcbiAgICAgICAgfVxuICAgICAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgICAgIHJldHVybiBjb21iaW5lRXZlbnRVaXModWlzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuICAgIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgICAgIHZhciBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycywgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBhcHBsaWVycywgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgICAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAgICAgLy8gaWYgZHVyYXRpb24gd2lsbCBjaGFuZ2UsIHRoZXJlJ3Mgbm8gd2F5IHRoZSBkZWZhdWx0IGR1cmF0aW9uIHdpbGwgcGVyc2lzdCxcbiAgICAgICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICAgICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgICAgIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUgJiZcbiAgICAgICAgICAgIHdpbGxEZWx0YXNBZmZlY3REdXJhdGlvbihldmVudENvbmZpZy5zdGFydEVkaXRhYmxlID8gbXV0YXRpb24uc3RhcnREZWx0YSA6IG51bGwsIG11dGF0aW9uLmVuZERlbHRhIHx8IG51bGwpKSB7XG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29weSA9IF9fYXNzaWduKHt9LCBldmVudERlZiwgc3RhbmRhcmRQcm9wcywgeyB1aTogX19hc3NpZ24oe30sIGV2ZW50RGVmLnVpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICAgICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IF9fYXNzaWduKHt9LCBjb3B5LmV4dGVuZGVkUHJvcHMsIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXBwbGllcnNfMSA9IGFwcGxpZXJzOyBfaSA8IGFwcGxpZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXBwbGllciA9IGFwcGxpZXJzXzFbX2ldO1xuICAgICAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29weS5oYXNFbmQgJiYgY2FsZW5kYXIub3B0KCdmb3JjZUV2ZW50RHVyYXRpb24nKSkge1xuICAgICAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aWxsRGVsdGFzQWZmZWN0RHVyYXRpb24oc3RhcnREZWx0YSwgZW5kRGVsdGEpIHtcbiAgICAgICAgaWYgKHN0YXJ0RGVsdGEgJiYgIWFzUm91Z2hNcyhzdGFydERlbHRhKSkge1xuICAgICAgICAgICAgc3RhcnREZWx0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZERlbHRhICYmICFhc1JvdWdoTXMoZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICBlbmREZWx0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFydERlbHRhICYmICFlbmREZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCb29sZWFuKHN0YXJ0RGVsdGEpICE9PSBCb29sZWFuKGVuZERlbHRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbiAgICBldmVudENvbmZpZywgbXV0YXRpb24sIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gY2FsZW5kYXIuZGF0ZUVudjtcbiAgICAgICAgdmFyIGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmhhc0VuZCA9PT0gZmFsc2U7XG4gICAgICAgIHZhciBjb3B5ID0gX19hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICBpZiAoZm9yY2VBbGxEYXkpIHtcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLnN0YXJ0RWRpdGFibGUpIHtcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxuICAgICAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0YXRpb24uZW5kRGVsdGEgJiZcbiAgICAgICAgICAgIChldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlIHx8XG4gICAgICAgICAgICAgICAgIXdpbGxEZWx0YXNBZmZlY3REdXJhdGlvbigvLyBUT0RPOiBub25EUlkgbG9naWMgYWJvdmVcbiAgICAgICAgICAgICAgICBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlID8gbXV0YXRpb24uc3RhcnREZWx0YSA6IG51bGwsIG11dGF0aW9uLmVuZERlbHRhKSkpIHtcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZW5kRGVsdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAgICAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgICAgICAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgY29weS5yYW5nZS5lbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlIChldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSwgYWN0aW9uLnJhd0V2ZW50cywgY2FsZW5kYXIpO1xuICAgICAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEV2ZW50KGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlLCAvLyBuZXcgb25lc1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBjYXNlICdNRVJHRV9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCBhbmQgZXhwYW5kZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9EQVRFJzpcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjYWxlbmRhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfVElNRVpPTkUnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXpvbmVEYXRlcyhldmVudFN0b3JlLCBhY3Rpb24ub2xkRGF0ZUVudiwgY2FsZW5kYXIuZGF0ZUVudik7XG4gICAgICAgICAgICBjYXNlICdNVVRBVEVfRVZFTlRTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlNdXRhdGlvblRvUmVsYXRlZChldmVudFN0b3JlLCBhY3Rpb24uaW5zdGFuY2VJZCwgYWN0aW9uLm11dGF0aW9uLCBhY3Rpb24uZnJvbUFwaSwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX0lOU1RBTkNFUyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmluc3RhbmNlcyk7XG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfREVGJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudERlZi5kZWZJZCAhPT0gYWN0aW9uLmRlZklkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFldmVudERlZi5zb3VyY2VJZDsgLy8gb25seSBrZWVwIGV2ZW50cyB3aXRoIG5vIHNvdXJjZSBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmczogZXZlbnRTdG9yZS5kZWZzLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IGV2ZW50U3RvcmUuaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjYWxlbmRhcikge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjYWxlbmRhciksIGV2ZW50U291cmNlLnNvdXJjZUlkLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY2FsZW5kYXIpIHtcbiAgICAgICAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlem9uZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnM7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYuYWxsRGF5IHx8IGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBpbnN0YW5jZSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpXG4gICAgICAgICAgICAgICAgICAgIH0sIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub1JlbGF0ZWQoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCwgbXV0YXRpb24sIGZyb21BcGksIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciByZWxldmFudCA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlSWQpO1xuICAgICAgICB2YXIgZXZlbnRDb25maWdCYXNlID0gZnJvbUFwaSA/XG4gICAgICAgICAgICB7ICcnOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXVxuICAgICAgICAgICAgICAgIH0gfSA6XG4gICAgICAgICAgICBjYWxlbmRhci5ldmVudFVpQmFzZXM7XG4gICAgICAgIHJlbGV2YW50ID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudCwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY2FsZW5kYXIpO1xuICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCByZWxldmFudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZi5zb3VyY2VJZCAhPT0gc291cmNlSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbiAgICBmdW5jdGlvbiBleGNsdWRlSW5zdGFuY2VzKGV2ZW50U3RvcmUsIHJlbW92YWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgICAgICBpbnN0YW5jZXM6IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBjYWxlbmRhcikge1xuICAgICAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjYWxlbmRhcik7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBjYWxlbmRhcikge1xuICAgICAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbiB9LCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBjYWxlbmRhci52aWV3O1xuICAgICAgICB2YXIgcHJvcHMgPSBfX2Fzc2lnbih7IGJ1c2luZXNzSG91cnM6IHZpZXcgPyB2aWV3LnByb3BzLmJ1c2luZXNzSG91cnMgOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSwgZGF0ZVNlbGVjdGlvbjogJycsIGV2ZW50U3RvcmU6IGNhbGVuZGFyLnN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXIuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgICAgICByZXR1cm4gKGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNhbGVuZGFyLCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgICAgICBpZiAoZGF0ZVNwYW5NZXRhID09PSB2b2lkIDApIHsgZGF0ZVNwYW5NZXRhID0ge307IH1cbiAgICAgICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNhbGVuZGFyLCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAhaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY2FsZW5kYXIsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBNb3ZpbmcgRXZlbnQgVmFsaWRhdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjYWxlbmRhciwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbiAgICAgICAgdmFyIHN1YmplY3RFdmVudFN0b3JlID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcbiAgICAgICAgdmFyIHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICAgICAgdmFyIHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgICAgIHZhciBzdWJqZWN0Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhzdWJqZWN0RGVmcywgaW50ZXJhY3Rpb24uaXNFdmVudCA/XG4gICAgICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICAgICAgeyAnJzogY2FsZW5kYXIuc2VsZWN0aW9uQ29uZmlnIH0gLy8gaWYgbm90IGEgcmVhbCBldmVudCwgdmFsaWRhdGUgYXMgYSBzZWxlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlckV2ZW50U3RvcmUgPSBleGNsdWRlSW5zdGFuY2VzKHN0YXRlLmV2ZW50U3RvcmUsIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyk7IC8vIGV4Y2x1ZGUgdGhlIHN1YmplY3QgZXZlbnRzLiBUT0RPOiBleGNsdWRlIGRlZnMgdG9vP1xuICAgICAgICB2YXIgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XG4gICAgICAgIHZhciBvdGhlckluc3RhbmNlcyA9IG90aGVyRXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgICAgIHZhciBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgICAgICBmb3IgKHZhciBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgc3ViamVjdEluc3RhbmNlID0gc3ViamVjdEluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICB2YXIgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgdmFyIHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAgICAgdmFyIHN1YmplY3REZWYgPSBzdWJqZWN0RGVmc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG92ZXJsYXBcbiAgICAgICAgICAgIHZhciBvdmVybGFwRnVuYyA9IGNhbGVuZGFyLm9wdCgnZXZlbnRPdmVybGFwJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJsYXBGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcEZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlc1tvdGhlckluc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyT3ZlcmxhcCA9IG90aGVyQ29uZmlnc1tvdGhlckluc3RhbmNlLmRlZklkXS5vdmVybGFwO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcEZ1bmMgJiYgIW92ZXJsYXBGdW5jKG5ldyBFdmVudEFwaShjYWxlbmRhciwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpIC8vIG1vdmluZyBldmVudFxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJqZWN0Q29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViamVjdEFsbG93ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdWJqZWN0RGF0ZVNwYW4gPSBfX2Fzc2lnbih7fSwgZGF0ZVNwYW5NZXRhLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdEZWYgPSBzdGF0ZS5ldmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdJbnN0YW5jZSA9IHN0YXRlLmV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGNhbGVuZGFyLmJ1aWxkRGF0ZVNwYW5BcGkoc3ViamVjdERhdGVTcGFuKSwgZXZlbnRBcGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIFZhbGlkYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjYWxlbmRhciwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgICAgIHZhciByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcbiAgICAgICAgdmFyIHJlbGV2YW50SW5zdGFuY2VzID0gcmVsZXZhbnRFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkNvbmZpZyA9IGNhbGVuZGFyLnNlbGVjdGlvbkNvbmZpZztcbiAgICAgICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG92ZXJsYXBcbiAgICAgICAgdmFyIG92ZXJsYXBGdW5jID0gY2FsZW5kYXIub3B0KCdzZWxlY3RPdmVybGFwJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3ZlcmxhcEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJsYXBGdW5jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciByZWxldmFudEluc3RhbmNlID0gcmVsZXZhbnRJbnN0YW5jZXNbcmVsZXZhbnRJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwRnVuYyAmJiAhb3ZlcmxhcEZ1bmMobmV3IEV2ZW50QXBpKGNhbGVuZGFyLCByZWxldmFudERlZnNbcmVsZXZhbnRJbnN0YW5jZS5kZWZJZF0sIHJlbGV2YW50SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2VsZWN0aW9uQ29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25BbGxvdyA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBmdWxsRGF0ZVNwYW4gPSBfX2Fzc2lnbih7fSwgZGF0ZVNwYW5NZXRhLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhjYWxlbmRhci5idWlsZERhdGVTcGFuQXBpKGZ1bGxEYXRlU3BhbiksIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDb25zdHJhaW50IFV0aWxzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNhbGVuZGFyKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgY29uc3RyYWludHNfMSA9IGNvbnN0cmFpbnRzOyBfaSA8IGNvbnN0cmFpbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY2FsZW5kYXIpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xuICAgIG90aGVyRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuICAgIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyAnYnVzaW5lc3NIb3VycydcbiAgICBjYWxlbmRhciAvLyBmb3IgZXhwYW5kaW5nIGJ1c2luZXNzaG91cnNcbiAgICApIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY2FsZW5kYXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY2FsZW5kYXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2VcbiAgICB9XG4gICAgLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xuICAgIGZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbiAgICBmdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvdXRlclJhbmdlc18xID0gb3V0ZXJSYW5nZXM7IF9pIDwgb3V0ZXJSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBvdXRlclJhbmdlID0gb3V0ZXJSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBQYXJzaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY2FsZW5kYXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsICcnLCBjYWxlbmRhciwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sICcnLCBjYWxlbmRhciwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiAocyArICcnKS5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGhhc2ggb2YgQ1NTIHByb3BlcnRpZXMsIHJldHVybnMgYSBzdHJpbmcgb2YgQ1NTLlxuICAgIC8vIFVzZXMgcHJvcGVydHkgbmFtZXMgYXMtaXMgKG5vIGNhbWVsLWNhc2UgY29udmVyc2lvbikuIFdpbGwgbm90IG1ha2Ugc3RhdGVtZW50cyBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIGNzc1RvU3RyKGNzc1Byb3BzKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjc3NQcm9wcykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGNzc1Byb3BzW25hbWVfMV07XG4gICAgICAgICAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuYW1lXzEgKyAnOicgKyB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLmpvaW4oJzsnKTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYW4gb2JqZWN0IGhhc2ggb2YgSFRNTCBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLFxuICAgIC8vIGdlbmVyYXRlcyBhIHN0cmluZyB0aGF0IGNhbiBiZSBpbmplY3RlZCBiZXR3ZWVuIDwgPiBpbiBIVE1MXG4gICAgZnVuY3Rpb24gYXR0cnNUb1N0cihhdHRycykge1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXR0cnNbbmFtZV8yXTtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobmFtZV8yICsgJz1cIicgKyBodG1sRXNjYXBlKHZhbCkgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignICcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzTmFtZShyYXcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFVOU0NPUEVEX0VWRU5UX1VJX1BST1BTID0ge1xuICAgICAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogQm9vbGVhbixcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICAgICAgY29uc3RyYWludDogbnVsbCxcbiAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgYWxsb3c6IG51bGwsXG4gICAgICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWUsXG4gICAgICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICAgICAgdGV4dENvbG9yOiBTdHJpbmdcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NVbnNjb3BlZFVpUHJvcHMocmF3UHJvcHMsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMocmF3UHJvcHMsIFVOU0NPUEVEX0VWRU5UX1VJX1BST1BTLCB7fSwgbGVmdG92ZXJzKTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHByb3BzLmNvbnN0cmFpbnQsIGNhbGVuZGFyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHByb3BzLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHByb3BzLnN0YXJ0RWRpdGFibGUgOiBwcm9wcy5lZGl0YWJsZSxcbiAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHByb3BzLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHByb3BzLmR1cmF0aW9uRWRpdGFibGUgOiBwcm9wcy5lZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcbiAgICAgICAgICAgIG92ZXJsYXA6IHByb3BzLm92ZXJsYXAsXG4gICAgICAgICAgICBhbGxvd3M6IHByb3BzLmFsbG93ICE9IG51bGwgPyBbcHJvcHMuYWxsb3ddIDogW10sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHByb3BzLmJhY2tncm91bmRDb2xvciB8fCBwcm9wcy5jb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBwcm9wcy5ib3JkZXJDb2xvciB8fCBwcm9wcy5jb2xvcixcbiAgICAgICAgICAgIHRleHRDb2xvcjogcHJvcHMudGV4dENvbG9yLFxuICAgICAgICAgICAgY2xhc3NOYW1lczogcHJvcHMuY2xhc3NOYW1lcy5jb25jYXQocHJvcHMuY2xhc3NOYW1lKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2NvcGVkVWlQcm9wcyhwcmVmaXgsIHJhd1Njb3BlZCwgY2FsZW5kYXIsIGxlZnRvdmVycykge1xuICAgICAgICB2YXIgcmF3VW5zY29wZWQgPSB7fTtcbiAgICAgICAgdmFyIHdhc0ZvdW5kID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBVTlNDT1BFRF9FVkVOVF9VSV9QUk9QUykge1xuICAgICAgICAgICAgdmFyIHNjb3BlZEtleSA9IHByZWZpeCArIGNhcGl0YWxpc2VGaXJzdExldHRlcihrZXkpO1xuICAgICAgICAgICAgcmF3VW5zY29wZWRba2V5XSA9IHJhd1Njb3BlZFtzY29wZWRLZXldO1xuICAgICAgICAgICAgd2FzRm91bmRbc2NvcGVkS2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgcmF3VW5zY29wZWQuZWRpdGFibGUgPSByYXdTY29wZWQuZWRpdGFibGU7IC8vIHNwZWNpYWwgY2FzZS4gdGhlcmUgaXMgbm8gJ2V2ZW50RWRpdGFibGUnLCBqdXN0ICdlZGl0YWJsZSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdG92ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmF3U2NvcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXNGb3VuZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVyc1trZXldID0gcmF3U2NvcGVkW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzVW5zY29wZWRVaVByb3BzKHJhd1Vuc2NvcGVkLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIHZhciBFTVBUWV9FVkVOVF9VSSA9IHtcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogbnVsbCxcbiAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgIGNsYXNzTmFtZXM6IFtdXG4gICAgfTtcbiAgICAvLyBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuICAgIGZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXMpIHtcbiAgICAgICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbWJpbmVUd29FdmVudFVpcyhpdGVtMCwgaXRlbTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBjb25zdHJhaW50czogaXRlbTAuY29uc3RyYWludHMuY29uY2F0KGl0ZW0xLmNvbnN0cmFpbnRzKSxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpdGVtMS5iYWNrZ3JvdW5kQ29sb3IgfHwgaXRlbTAuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxuICAgICAgICAgICAgY2xhc3NOYW1lczogaXRlbTAuY2xhc3NOYW1lcy5jb25jYXQoaXRlbTEuY2xhc3NOYW1lcylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgTk9OX0RBVEVfUFJPUFMgPSB7XG4gICAgICAgIGlkOiBTdHJpbmcsXG4gICAgICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICAgICAgdGl0bGU6IFN0cmluZyxcbiAgICAgICAgdXJsOiBTdHJpbmcsXG4gICAgICAgIHJlbmRlcmluZzogU3RyaW5nLFxuICAgICAgICBleHRlbmRlZFByb3BzOiBudWxsXG4gICAgfTtcbiAgICB2YXIgREFURV9QUk9QUyA9IHtcbiAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgIGRhdGU6IG51bGwsXG4gICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgYWxsRGF5OiBudWxsXG4gICAgfTtcbiAgICB2YXIgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50KHJhdywgc291cmNlSWQsIGNhbGVuZGFyLCBhbGxvd09wZW5SYW5nZSkge1xuICAgICAgICB2YXIgYWxsRGF5RGVmYXVsdCA9IGNvbXB1dGVJc0FsbERheURlZmF1bHQoc291cmNlSWQsIGNhbGVuZGFyKTtcbiAgICAgICAgdmFyIGxlZnRvdmVyczAgPSB7fTtcbiAgICAgICAgdmFyIHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJhdywgLy8gcmF3LCBidXQgd2l0aCBzaW5nbGUtZXZlbnQgc3R1ZmYgc3RyaXBwZWQgb3V0XG4gICAgICAgIGFsbERheURlZmF1bHQsIGNhbGVuZGFyLmRhdGVFbnYsIGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5yZWN1cnJpbmdUeXBlcywgbGVmdG92ZXJzMCAvLyB3aWxsIHBvcHVsYXRlIHdpdGggbm9uLXJlY3VycmluZyBwcm9wc1xuICAgICAgICApO1xuICAgICAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihsZWZ0b3ZlcnMwLCBzb3VyY2VJZCwgcmVjdXJyaW5nUmVzLmFsbERheSwgQm9vbGVhbihyZWN1cnJpbmdSZXMuZHVyYXRpb24pLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBkZWYucmVjdXJyaW5nRGVmID0ge1xuICAgICAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBkZWY6IGRlZiwgaW5zdGFuY2U6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZWZ0b3ZlcnMxID0ge307XG4gICAgICAgICAgICB2YXIgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmF3LCBhbGxEYXlEZWZhdWx0LCBjYWxlbmRhciwgbGVmdG92ZXJzMSwgYWxsb3dPcGVuUmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKGxlZnRvdmVyczEsIHNvdXJjZUlkLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjYWxlbmRhcik7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cbiAgICBUaGUgRXZlbnROb25EYXRlSW5wdXQgaGFzIGJlZW4gbm9ybWFsaXplZCAoaWQgPT4gcHVibGljSWQsIGV0YykuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50RGVmKHJhdywgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjYWxlbmRhcikge1xuICAgICAgICB2YXIgbGVmdG92ZXJzID0ge307XG4gICAgICAgIHZhciBkZWYgPSBwbHVja05vbkRhdGVQcm9wcyhyYXcsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMpO1xuICAgICAgICBkZWYuZGVmSWQgPSBTdHJpbmcodWlkKyspO1xuICAgICAgICBkZWYuc291cmNlSWQgPSBzb3VyY2VJZDtcbiAgICAgICAgZGVmLmFsbERheSA9IGFsbERheTtcbiAgICAgICAgZGVmLmhhc0VuZCA9IGhhc0VuZDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5ldmVudERlZlBhcnNlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnREZWZQYXJzZXIgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgbmV3TGVmdG92ZXJzID0ge307XG4gICAgICAgICAgICBldmVudERlZlBhcnNlcihkZWYsIGxlZnRvdmVycywgbmV3TGVmdG92ZXJzKTtcbiAgICAgICAgICAgIGxlZnRvdmVycyA9IG5ld0xlZnRvdmVycztcbiAgICAgICAgfVxuICAgICAgICBkZWYuZXh0ZW5kZWRQcm9wcyA9IF9fYXNzaWduKGxlZnRvdmVycywgZGVmLmV4dGVuZGVkUHJvcHMgfHwge30pO1xuICAgICAgICAvLyBoZWxwIG91dCBFdmVudEFwaSBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW5jZUlkOiBTdHJpbmcodWlkKyspLFxuICAgICAgICAgICAgZGVmSWQ6IGRlZklkLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGZvcmNlZEVuZFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZEVuZFR6b1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVNpbmdsZShyYXcsIGFsbERheURlZmF1bHQsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHBsdWNrRGF0ZVByb3BzKHJhdywgbGVmdG92ZXJzKTtcbiAgICAgICAgdmFyIGFsbERheSA9IHByb3BzLmFsbERheTtcbiAgICAgICAgdmFyIHN0YXJ0TWV0YTtcbiAgICAgICAgdmFyIHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICAgICAgdmFyIGhhc0VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZW5kTWV0YTtcbiAgICAgICAgdmFyIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIHN0YXJ0TWV0YSA9IGNhbGVuZGFyLmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShwcm9wcy5zdGFydCk7XG4gICAgICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kTWV0YSA9IGNhbGVuZGFyLmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShwcm9wcy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGFsbERheURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbERheSA9IGFsbERheURlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRhdGUgcHJvcHMgTEFTVFxuICAgICAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyO1xuICAgICAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgICAgIGhhc0VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgICAgICBoYXNFbmQgPSBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpIHx8IGZhbHNlO1xuICAgICAgICAgICAgZW5kTWFya2VyID0gY2FsZW5kYXIuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICAgICAgY2FsZW5kYXIuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgICAgIGhhc0VuZDogaGFzRW5kLFxuICAgICAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhID8gZW5kTWV0YS5mb3JjZWRUem8gOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBsdWNrRGF0ZVByb3BzKHJhdywgbGVmdG92ZXJzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHJlZmluZVByb3BzKHJhdywgREFURV9QUk9QUywge30sIGxlZnRvdmVycyk7XG4gICAgICAgIHByb3BzLnN0YXJ0ID0gKHByb3BzLnN0YXJ0ICE9PSBudWxsKSA/IHByb3BzLnN0YXJ0IDogcHJvcHMuZGF0ZTtcbiAgICAgICAgZGVsZXRlIHByb3BzLmRhdGU7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGx1Y2tOb25EYXRlUHJvcHMocmF3LCBjYWxlbmRhciwgbGVmdG92ZXJzKSB7XG4gICAgICAgIHZhciBwcmVMZWZ0b3ZlcnMgPSB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMocmF3LCBOT05fREFURV9QUk9QUywge30sIHByZUxlZnRvdmVycyk7XG4gICAgICAgIHZhciB1aSA9IHByb2Nlc3NVbnNjb3BlZFVpUHJvcHMocHJlTGVmdG92ZXJzLCBjYWxlbmRhciwgbGVmdG92ZXJzKTtcbiAgICAgICAgcHJvcHMucHVibGljSWQgPSBwcm9wcy5pZDtcbiAgICAgICAgZGVsZXRlIHByb3BzLmlkO1xuICAgICAgICBwcm9wcy51aSA9IHVpO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJc0FsbERheURlZmF1bHQoc291cmNlSWQsIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciByZXMgPSBudWxsO1xuICAgICAgICBpZiAoc291cmNlSWQpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBjYWxlbmRhci5zdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSWRdO1xuICAgICAgICAgICAgcmVzID0gc291cmNlLmFsbERheURlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXMgPSBjYWxlbmRhci5vcHQoJ2FsbERheURlZmF1bHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHZhciBERUZfREVGQVVMVFMgPSB7XG4gICAgICAgIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgICAgICAgZW5kVGltZTogJzE3OjAwJyxcbiAgICAgICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgICAgICByZW5kZXJpbmc6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgICAgICBjbGFzc05hbWVzOiAnZmMtbm9uYnVzaW5lc3MnLFxuICAgICAgICBncm91cElkOiAnX2J1c2luZXNzSG91cnMnIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbiAgICB9O1xuICAgIC8qXG4gICAgVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4gICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNhbGVuZGFyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhyZWZpbmVJbnB1dHMoaW5wdXQpLCAnJywgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcbiAgICAgICAgdmFyIHJhd0RlZnM7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXG4gICAgICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChyYXdEZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3RGVmLmRheXNPZldlZWs7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXG4gICAgICAgICAgICByYXdEZWZzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmF3RGVmcyA9IHJhd0RlZnMubWFwKGZ1bmN0aW9uIChyYXdEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgREVGX0RFRkFVTFRTLCByYXdEZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJhd0RlZnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVtb2l6ZVJlbmRlcmluZyhyZW5kZXJGdW5jLCB1bnJlbmRlckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gW107IH1cbiAgICAgICAgdmFyIGRlcGVuZGVudHMgPSBbXTtcbiAgICAgICAgdmFyIHRoaXNDb250ZXh0O1xuICAgICAgICB2YXIgcHJldkFyZ3M7XG4gICAgICAgIGZ1bmN0aW9uIHVucmVuZGVyKCkge1xuICAgICAgICAgICAgaWYgKHByZXZBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZXBlbmRlbnRzXzEgPSBkZXBlbmRlbnRzOyBfaSA8IGRlcGVuZGVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVudCA9IGRlcGVuZGVudHNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVudC51bnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW5yZW5kZXJGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVuZGVyRnVuYy5hcHBseSh0aGlzQ29udGV4dCwgcHJldkFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2QXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzKCkge1xuICAgICAgICAgICAgaWYgKCFwcmV2QXJncyB8fCAhaXNBcnJheXNFcXVhbChwcmV2QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHVucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpc0NvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHByZXZBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMuZGVwZW5kZW50cyA9IGRlcGVuZGVudHM7XG4gICAgICAgIHJlcy51bnJlbmRlciA9IHVucmVuZGVyO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRlcGVuZGVuY2llc18xID0gZGVwZW5kZW5jaWVzOyBfaSA8IGRlcGVuZGVuY2llc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNfMVtfaV07XG4gICAgICAgICAgICBkZXBlbmRlbmN5LmRlcGVuZGVudHMucHVzaChyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWx1ZXNTaW1pbGFyKHZhbDAsIHZhbDEsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7IGRlcHRoID0gMTsgfVxuICAgICAgICBpZiAodmFsMCA9PT0gdmFsMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwwKSAmJiBBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheXNTaW1pbGFyKHZhbDAsIHZhbDEsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsMCA9PT0gJ29iamVjdCcgJiYgdmFsMCAmJiB0eXBlb2YgdmFsMSA9PT0gJ29iamVjdCcgJiYgdmFsMSkgeyAvLyBub24tbnVsbCBvYmplY3RzXG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3RzU2ltaWxhcih2YWwwLCB2YWwxLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBcnJheXNTaW1pbGFyKGEwLCBhMSwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHsgZGVwdGggPSAxOyB9XG4gICAgICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlcHRoID4gMCkge1xuICAgICAgICAgICAgaWYgKGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsdWVzU2ltaWxhcihhMFtpXSwgYTFbaV0sIGRlcHRoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc09iamVjdHNTaW1pbGFyKG9iajAsIG9iajEsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7IGRlcHRoID0gMTsgfVxuICAgICAgICBpZiAob2JqMCA9PT0gb2JqMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iajApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iajEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIG9iajApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWx1ZXNTaW1pbGFyKG9iajBbcHJvcF0sIG9iajFbcHJvcF0sIGRlcHRoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUHJvcHMob2JqMCwgb2JqMSwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHsgZGVwdGggPSAxOyB9XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIG9iajApIHx8XG4gICAgICAgICAgICAgICAgIWlzVmFsdWVzU2ltaWxhcihvYmowW3Byb3BdLCBvYmoxW3Byb3BdLCBkZXB0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gb2JqMVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbnlLZXlzUmVtb3ZlZChvYmowLCBvYmoxKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqMCkge1xuICAgICAgICAgICAgaWYgKCEocHJvcCBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuICAgIHZhciBTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3BsaXR0ZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5zcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSk7XG4gICAgICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBTcGxpdHRlci5wcm90b3R5cGUuc3BsaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgICAgICB2YXIgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgICAgIHZhciBkYXRlU2VsZWN0aW9ucyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgICAgICB2YXIgZXZlbnREcmFncyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnKTtcbiAgICAgICAgICAgIHZhciBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0gbWFwSGFzaChrZXlJbmZvcywgZnVuY3Rpb24gKGluZm8sIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XSB8fCBtZW1vaXplKGJ1aWxkRXZlbnRVaUZvcktleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRTdG9yZSA9IGV2ZW50U3RvcmVzW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkU7XG4gICAgICAgICAgICAgICAgdmFyIGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgc3BsaXRQcm9wc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBrZXlJbmZvLmJ1c2luZXNzSG91cnMgfHwgcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IGJ1aWxkRXZlbnRVaShwcm9wcy5ldmVudFVpQmFzZXNbJyddLCBrZXlJbmZvLnVpLCBpbmRpdmlkdWFsVWlba2V5XSksXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBldmVudERyYWc6IGV2ZW50RHJhZ3Nba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVzW2tleV0gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRQcm9wcztcbiAgICAgICAgfTtcbiAgICAgICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdERhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZVNwYW5zID0ge307XG4gICAgICAgICAgICBpZiAoZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgICAgICB9O1xuICAgICAgICBTcGxpdHRlci5wcm90b3R5cGUuX2dldEtleXNGb3JFdmVudERlZnMgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZGVmS2V5cykge1xuICAgICAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgICAgICAgICAgdmFyIHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmRlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGRlZktleXNbaW5zdGFuY2UuZGVmSWRdOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRTdG9yZXM7XG4gICAgICAgIH07XG4gICAgICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRJbmRpdmlkdWFsVWkgPSBmdW5jdGlvbiAoZXZlbnRVaUJhc2VzLCBkZWZLZXlzKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50VWlCYXNlcykge1xuICAgICAgICAgICAgICAgIGlmIChkZWZJZCkgeyAvLyBub3QgdGhlICcnIGtleVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0SGFzaGVzO1xuICAgICAgICB9O1xuICAgICAgICBTcGxpdHRlci5wcm90b3R5cGUuX3NwbGl0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkU3RvcmVzXzEgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMsIHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMoaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMpIC8vIGNhbid0IHVzZSBjYWNoZWQuIG1pZ2h0IGJlIGV2ZW50cyBmcm9tIG90aGVyIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFN0b3Jlc18xID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBtdXRhdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IGludGVyYWN0aW9uLm9yaWdTZWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhZmZlY3RlZFN0b3Jlc18xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtdXRhdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRTdGF0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcGxpdHRlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgICAgIHZhciBiYXNlUGFydHMgPSBbXTtcbiAgICAgICAgaWYgKGFsbFVpKSB7XG4gICAgICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50VWlGb3JLZXkpIHtcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHVmZiA9IHtcbiAgICAgICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kaXZpZHVhbFVpKSB7XG4gICAgICAgICAgICBfX2Fzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R1ZmY7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGVzIEhUTUwgZm9yIGFuIGFuY2hvciB0byBhbm90aGVyIHZpZXcgaW50byB0aGUgY2FsZW5kYXIuXG4gICAgLy8gV2lsbCBlaXRoZXIgZ2VuZXJhdGUgYW4gPGE+IHRhZyBvciBhIG5vbi1jbGlja2FibGUgPHNwYW4+IHRhZywgZGVwZW5kaW5nIG9uIGVuYWJsZWQgc2V0dGluZ3MuXG4gICAgLy8gYGdvdG9PcHRpb25zYCBjYW4gZWl0aGVyIGJlIGEgRGF0ZU1hcmtlciwgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvcm06XG4gICAgLy8geyBkYXRlLCB0eXBlLCBmb3JjZU9mZiB9XG4gICAgLy8gYHR5cGVgIGlzIGEgdmlldy10eXBlIGxpa2UgXCJkYXlcIiBvciBcIndlZWtcIi4gZGVmYXVsdCB2YWx1ZSBpcyBcImRheVwiLlxuICAgIC8vIGBhdHRyc2AgYW5kIGBpbm5lckh0bWxgIGFyZSB1c2UgdG8gZ2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIEhUTUwgdGFnLlxuICAgIGZ1bmN0aW9uIGJ1aWxkR290b0FuY2hvckh0bWwoY29tcG9uZW50LCBnb3RvT3B0aW9ucywgYXR0cnMsIGlubmVySHRtbCkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGNvbXBvbmVudC5kYXRlRW52O1xuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBmb3JjZU9mZjtcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucztcbiAgICAgICAgaWYgKGdvdG9PcHRpb25zIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBkYXRlLWxpa2UgaW5wdXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9ucy5kYXRlO1xuICAgICAgICAgICAgdHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XG4gICAgICAgICAgICBmb3JjZU9mZiA9IGdvdG9PcHRpb25zLmZvcmNlT2ZmO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYuZm9ybWF0SXNvKGRhdGUsIHsgb21pdFRpbWU6IHRydWUgfSksXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdkYXknXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbm5lckh0bWwgPSBhdHRycztcbiAgICAgICAgICAgIGF0dHJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhdHRycyA9IGF0dHJzID8gJyAnICsgYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxuICAgICAgICBpbm5lckh0bWwgPSBpbm5lckh0bWwgfHwgJyc7XG4gICAgICAgIGlmICghZm9yY2VPZmYgJiYgY29tcG9uZW50Lm9wdCgnbmF2TGlua3MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICc8YScgKyBhdHRycyArXG4gICAgICAgICAgICAgICAgJyBkYXRhLWdvdG89XCInICsgaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShmaW5hbE9wdGlvbnMpKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwgK1xuICAgICAgICAgICAgICAgICc8L2E+JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnPHNwYW4nICsgYXR0cnMgKyAnPicgK1xuICAgICAgICAgICAgICAgIGlubmVySHRtbCArXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEFsbERheUh0bWwoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQub3B0KCdhbGxEYXlIdG1sJykgfHwgaHRtbEVzY2FwZShjb21wb25lbnQub3B0KCdhbGxEYXlUZXh0JykpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBIVE1MIGNsYXNzTmFtZXMgZm9yIGEgc2luZ2xlLWRheSBlbGVtZW50XG4gICAgZnVuY3Rpb24gZ2V0RGF5Q2xhc3NlcyhkYXRlLCBkYXRlUHJvZmlsZSwgY29udGV4dCwgbm9UaGVtZUhpZ2hsaWdodCkge1xuICAgICAgICB2YXIgY2FsZW5kYXIgPSBjb250ZXh0LmNhbGVuZGFyLCB2aWV3ID0gY29udGV4dC52aWV3LCB0aGVtZSA9IGNvbnRleHQudGhlbWUsIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICAgIHZhciB0b2RheVN0YXJ0O1xuICAgICAgICB2YXIgdG9kYXlFbmQ7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZGlzYWJsZWQtZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLScgKyBEQVlfSURTW2RhdGUuZ2V0VVRDRGF5KCldKTtcbiAgICAgICAgICAgIGlmICh2aWV3Lm9wdCgnbW9udGhNb2RlJykgJiZcbiAgICAgICAgICAgICAgICBkYXRlRW52LmdldE1vbnRoKGRhdGUpICE9PSBkYXRlRW52LmdldE1vbnRoKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLW90aGVyLW1vbnRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2RheVN0YXJ0ID0gc3RhcnRPZkRheShjYWxlbmRhci5nZXROb3coKSk7XG4gICAgICAgICAgICB0b2RheUVuZCA9IGFkZERheXModG9kYXlTdGFydCwgMSk7XG4gICAgICAgICAgICBpZiAoZGF0ZSA8IHRvZGF5U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXBhc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGUgPj0gdG9kYXlFbmQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy10b2RheScpO1xuICAgICAgICAgICAgICAgIGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cblxuICAgIC8vIGdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbiAgICAvLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbiAgICAvLyBvciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbiAgICAvLyBpZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbiAgICBmdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgLy8gYW5kIGd1YXJkIGFnYWluc3QgYSBwcm9taXNlIEFORCBjYWxsYmFjayBiZWluZyB1c2VkIHRvZ2V0aGVyLlxuICAgICAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaXhpbigpIHtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaXggaW50byBhIENMQVNTXG4gICAgICAgIE1peGluLm1peEludG8gPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1peEludG9PYmooZGVzdENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG1peCBpbnRvIEFOWSBvYmplY3RcbiAgICAgICAgTWl4aW4ubWl4SW50b09iaiA9IGZ1bmN0aW9uIChkZXN0T2JqKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RPYmpbbmFtZV0pIHsgLy8gaWYgZGVzdGluYXRpb24gZG9lc24ndCBhbHJlYWR5IGRlZmluZSBpdFxuICAgICAgICAgICAgICAgICAgICBkZXN0T2JqW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIG1ldGhvZHNcbiAgICAgICAgVE9ETzogcmVtb3ZlISBub3QgdXNlZCBhbnltb3JlXG4gICAgICAgICovXG4gICAgICAgIE1peGluLm1peE92ZXIgPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNaXhpbjtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICBVU0FHRTpcbiAgICAgIGltcG9ydCB7IGRlZmF1bHQgYXMgRW1pdHRlck1peGluLCBFbWl0dGVySW50ZXJmYWNlIH0gZnJvbSAnLi9FbWl0dGVyTWl4aW4nXG4gICAgaW4gY2xhc3M6XG4gICAgICBvbjogRW1pdHRlckludGVyZmFjZVsnb24nXVxuICAgICAgb25lOiBFbWl0dGVySW50ZXJmYWNlWydvbmUnXVxuICAgICAgb2ZmOiBFbWl0dGVySW50ZXJmYWNlWydvZmYnXVxuICAgICAgdHJpZ2dlcjogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlciddXG4gICAgICB0cmlnZ2VyV2l0aDogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlcldpdGgnXVxuICAgICAgaGFzSGFuZGxlcnM6IEVtaXR0ZXJJbnRlcmZhY2VbJ2hhc0hhbmRsZXJzJ11cbiAgICBhZnRlciBjbGFzczpcbiAgICAgIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxuICAgICovXG4gICAgdmFyIEVtaXR0ZXJNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVtaXR0ZXJNaXhpbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW1pdHRlck1peGluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgYWRkVG9IYXNoKHRoaXMuX2hhbmRsZXJzIHx8ICh0aGlzLl9oYW5kbGVycyA9IHt9KSwgdHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgICAgIH07XG4gICAgICAgIC8vIHRvZG86IGFkZCBjb21tZW50c1xuICAgICAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBhZGRUb0hhc2godGhpcy5fb25lSGFuZGxlcnMgfHwgKHRoaXMuX29uZUhhbmRsZXJzID0ge30pLCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbiAgICAgICAgfTtcbiAgICAgICAgRW1pdHRlck1peGluLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5faGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5fb25lSGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuICAgICAgICB9O1xuICAgICAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcldpdGgodHlwZSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgICAgIH07XG4gICAgICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUudHJpZ2dlcldpdGggPSBmdW5jdGlvbiAodHlwZSwgY29udGV4dCwgYXJncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlBbGwodGhpcy5faGFuZGxlcnNbdHlwZV0sIGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlBbGwodGhpcy5fb25lSGFuZGxlcnNbdHlwZV0sIGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vbmVIYW5kbGVyc1t0eXBlXTsgLy8gd2lsbCBuZXZlciBmaXJlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgICAgIH07XG4gICAgICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUuaGFzSGFuZGxlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX29uZUhhbmRsZXJzICYmIHRoaXMuX29uZUhhbmRsZXJzW3R5cGVdICYmIHRoaXMuX29uZUhhbmRsZXJzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbWl0dGVyTWl4aW47XG4gICAgfShNaXhpbikpO1xuICAgIGZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAgICAgLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYXNoW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jICE9PSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIFJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG4gICAgQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuICAgIFByb3ZpZGVzIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIHRoZSBjYWNoZSBieSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHZhciBQb3NpdGlvbkNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5FbCA9IG9yaWdpbkVsO1xuICAgICAgICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IGlzSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IGlzVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVlcmllcyB0aGUgZWxzIGZvciBjb29yZGluYXRlcyBhbmQgc3RvcmVzIHRoZW0uXG4gICAgICAgIC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5FbCA9IHRoaXMub3JpZ2luRWw7XG4gICAgICAgICAgICB2YXIgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9XG4gICAgICAgICAgICAgICAgb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZEVsSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICAgICAgdmFyIGxlZnRzID0gW107XG4gICAgICAgICAgICB2YXIgcmlnaHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcbiAgICAgICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxWZXJ0aWNhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50VG9wKSB7XG4gICAgICAgICAgICB2YXIgdG9wcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGJvdHRvbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gICAgICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUubGVmdFRvSW5kZXggPSBmdW5jdGlvbiAobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGVmdHMgPSB0aGlzLmxlZnRzO1xuICAgICAgICAgICAgdmFyIHJpZ2h0cyA9IHRoaXMucmlnaHRzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxlZnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQb3NpdGlvbiA+PSBsZWZ0c1tpXSAmJiBsZWZ0UG9zaXRpb24gPCByaWdodHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAgICAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLnRvcFRvSW5kZXggPSBmdW5jdGlvbiAodG9wUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3BzID0gdGhpcy50b3BzO1xuICAgICAgICAgICAgdmFyIGJvdHRvbXMgPSB0aGlzLmJvdHRvbXM7XG4gICAgICAgICAgICB2YXIgbGVuID0gdG9wcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0b3BQb3NpdGlvbiA+PSB0b3BzW2ldICYmIHRvcFBvc2l0aW9uIDwgYm90dG9tc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9zaXRpb25DYWNoZTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICBBbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbiAgICBJbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdmVyeSBkaWZmZXJlbnRseSBmb3Igd2luZG93IHZlcnN1cyBET00gZWxlbWVudCxcbiAgICBzbyB0aGlzIG9iamVjdCBzZXJ2ZXMgYXMgYSBjb21tb24gaW50ZXJmYWNlLlxuICAgICovXG4gICAgdmFyIFNjcm9sbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjcm9sbENvbnRyb2xsZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCkgLSB0aGlzLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICB9O1xuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVmVydGljYWxseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbFRvcCgpID4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpID4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgICAgIH07XG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbERvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPiAwO1xuICAgICAgICB9O1xuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2Nyb2xsQ29udHJvbGxlcjtcbiAgICB9KCkpO1xuICAgIHZhciBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcihlbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmVsID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICAgICAgfTtcbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxMZWZ0O1xuICAgICAgICB9O1xuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICAgICAgdGhpcy5lbC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgIH07XG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH07XG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFdpZHRoO1xuICAgICAgICB9O1xuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xuICAgIH0oU2Nyb2xsQ29udHJvbGxlcikpO1xuICAgIHZhciBXaW5kb3dTY3JvbGxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoV2luZG93U2Nyb2xsQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gV2luZG93U2Nyb2xsQ29udHJvbGxlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgfTtcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgIH07XG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldENsaWVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXaW5kb3dTY3JvbGxDb250cm9sbGVyO1xuICAgIH0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG4gICAgLypcbiAgICBFbWJvZGllcyBhIGRpdiB0aGF0IGhhcyBwb3RlbnRpYWwgc2Nyb2xsYmFyc1xuICAgICovXG4gICAgdmFyIFNjcm9sbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNjcm9sbENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2Nyb2xsQ29tcG9uZW50KG92ZXJmbG93WCwgb3ZlcmZsb3dZKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmMtc2Nyb2xsZXInXG4gICAgICAgICAgICB9KSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLm92ZXJmbG93WCA9IG92ZXJmbG93WDtcbiAgICAgICAgICAgIF90aGlzLm92ZXJmbG93WSA9IG92ZXJmbG93WTtcbiAgICAgICAgICAgIF90aGlzLmFwcGx5T3ZlcmZsb3coKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodCgnYXV0bycpO1xuICAgICAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE92ZXJmbG93XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuYXBwbHlPdmVyZmxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5lbCwge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogdGhpcy5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiB0aGlzLm92ZXJmbG93WVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENhdXNlcyBhbnkgJ2F1dG8nIG92ZXJmbG93IHZhbHVlcyB0byByZXNvbHZlcyB0byAnc2Nyb2xsJyBvciAnaGlkZGVuJy5cbiAgICAgICAgLy8gVXNlZnVsIGZvciBwcmVzZXJ2aW5nIHNjcm9sbGJhciB3aWR0aHMgcmVnYXJkbGVzcyBvZiBmdXR1cmUgcmVzaXplcy5cbiAgICAgICAgLy8gQ2FuIHBhc3MgaW4gc2Nyb2xsYmFyV2lkdGhzIGZvciBvcHRpbWl6YXRpb24uXG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUubG9ja092ZXJmbG93ID0gZnVuY3Rpb24gKHNjcm9sbGJhcldpZHRocykge1xuICAgICAgICAgICAgdmFyIG92ZXJmbG93WCA9IHRoaXMub3ZlcmZsb3dYO1xuICAgICAgICAgICAgdmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gc2Nyb2xsYmFyV2lkdGhzIHx8IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1ggPSAoc2Nyb2xsYmFyV2lkdGhzLmJvdHRvbSB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsSG9yaXpvbnRhbGx5KCkgLy8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xuICAgICAgICAgICAgICAgICkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZID0gKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsVmVydGljYWxseSgpIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cbiAgICAgICAgICAgICAgICApID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5lbCwgeyBvdmVyZmxvd1g6IG92ZXJmbG93WCwgb3ZlcmZsb3dZOiBvdmVyZmxvd1kgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZVByb3AodGhpcy5lbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVkZ2VzID0gY29tcHV0ZUVkZ2VzKHRoaXMuZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IGVkZ2VzLnNjcm9sbGJhckJvdHRvbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjcm9sbENvbXBvbmVudDtcbiAgICB9KEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKSk7XG5cbiAgICB2YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRoZW1lKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhck9wdGlvbnMgPSBjYWxlbmRhck9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NJY29uT3ZlcnJpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBUaGVtZS5wcm90b3R5cGUucHJvY2Vzc0ljb25PdmVycmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKHRoaXMuY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRoZW1lLnByb3RvdHlwZS5zZXRJY29uT3ZlcnJpZGUgPSBmdW5jdGlvbiAoaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICAgICAgdmFyIGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgICAgIHZhciBidXR0b25OYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9IF9fYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcbiAgICAgICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkgeyAvLyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnO1xuICAgICAgICB9O1xuICAgICAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH07XG4gICAgICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRoZW1lO1xuICAgIH0oKSk7XG4gICAgVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcbiAgICBUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICBUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xuICAgIFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcblxuICAgIHZhciBndWlkID0gMDtcbiAgICB2YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnQoY29udGV4dCwgaXNWaWV3KSB7XG4gICAgICAgICAgICAvLyBIQUNLIHRvIHBvcHVsYXRlIHZpZXcgYXQgdG9wIG9mIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uIGNhbGwgY2hhaW5cbiAgICAgICAgICAgIGlmIChpc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnZpZXcgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51aWQgPSBTdHJpbmcoZ3VpZCsrKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnY7XG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gY29udGV4dC50aGVtZTtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IGNvbnRleHQudmlldztcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjb250ZXh0LmNhbGVuZGFyO1xuICAgICAgICAgICAgdGhpcy5pc1J0bCA9IHRoaXMub3B0KCdkaXInKSA9PT0gJ3J0bCc7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcG9uZW50LmFkZEVxdWFsaXR5RnVuY3MgPSBmdW5jdGlvbiAobmV3RnVuY3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLmVxdWFsaXR5RnVuY3MgPSBfX2Fzc2lnbih7fSwgdGhpcy5wcm90b3R5cGUuZXF1YWxpdHlGdW5jcywgbmV3RnVuY3MpO1xuICAgICAgICB9O1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm9wdGlvbnNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZWN5Y2xlUHJvcHModGhpcy5wcm9wcyB8fCB7fSwgcHJvcHMsIHRoaXMuZXF1YWxpdHlGdW5jcyksIGFueUNoYW5nZXMgPSBfYS5hbnlDaGFuZ2VzLCBjb21ib1Byb3BzID0gX2EuY29tYm9Qcm9wcztcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBjb21ib1Byb3BzO1xuICAgICAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcihjb21ib1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWZ0ZXIgZGVzdHJveSBpcyBjYWxsZWQsIHRoaXMgY29tcG9uZW50IHdvbid0IGV2ZXIgYmUgdXNlZCBhZ2FpblxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfSgpKTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmVxdWFsaXR5RnVuY3MgPSB7fTtcbiAgICAvKlxuICAgIFJldXNlcyBvbGQgdmFsdWVzIHdoZW4gZXF1YWwuIElmIGFueXRoaW5nIGlzIHVuZXF1YWwsIHJldHVybnMgbmV3UHJvcHMgYXMtaXMuXG4gICAgR3JlYXQgZm9yIFB1cmVDb21wb25lbnQsIGJ1dCB3b24ndCBiZSBmZWFzaWJsZSB3aXRoIFJlYWN0LCBzbyBqdXN0IGVsaW1pbmF0ZSBhbmQgdXNlIFJlYWN0J3MgRE9NIGRpZmZpbmcuXG4gICAgKi9cbiAgICBmdW5jdGlvbiByZWN5Y2xlUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzKSB7XG4gICAgICAgIHZhciBjb21ib1Byb3BzID0ge307IC8vIHNvbWUgb2xkLCBzb21lIG5ld1xuICAgICAgICB2YXIgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2xkUHJvcHMgJiYgKG9sZFByb3BzW2tleV0gPT09IG5ld1Byb3BzW2tleV0gfHxcbiAgICAgICAgICAgICAgICAoZXF1YWxpdHlGdW5jc1trZXldICYmIGVxdWFsaXR5RnVuY3Nba2V5XShvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldKSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXF1YWwgdG8gb2xkPyB1c2Ugb2xkIHByb3BcbiAgICAgICAgICAgICAgICBjb21ib1Byb3BzW2tleV0gPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tYm9Qcm9wc1trZXldID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBhbnlDaGFuZ2VzOiBhbnlDaGFuZ2VzLCBjb21ib1Byb3BzOiBjb21ib1Byb3BzIH07XG4gICAgfVxuXG4gICAgLypcbiAgICBQVVJQT1NFUzpcbiAgICAtIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4gICAgLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXG4gICAgKi9cbiAgICB2YXIgRGF0ZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERhdGVDb21wb25lbnQoY29udGV4dCwgZWwsIGlzVmlldykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgaXNWaWV3KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBXSEFUIEFCT1VUIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLmNvbXBvbmVudC5kb2VzRHJhZ01pcnJvcilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXZlbnQgRHJhZy1uLURyb3AgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLypcbiAgICAgICAgcmVuZGVyRXZlbnREcmFnU2VncyhzdGF0ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCB7IGlzRXZlbnQsIHNlZ3MsIHNvdXJjZVNlZyB9ID0gc3RhdGVcbiAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRSZW5kZXJlcikge1xuICAgICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuaGlkZUJ5SGFzaChzdGF0ZS5hZmZlY3RlZEluc3RhbmNlcylcbiAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgc29tZXRoaW5nIHRoYXQgaXMgY29uc2lkZXJlZCBhbiBldmVudCB3aXRoIHJlYWwgZXZlbnQgZGF0YSxcbiAgICAgICAgICAgIC8vIGFuZCB0aGlzIGNvbXBvbmVudCBsaWtlcyB0byBkbyBkcmFnIG1pcnJvcnMgT1IgdGhlIGNvbXBvbmVudCB3aGVyZSB0aGUgc2VnIGNhbWUgZnJvbVxuICAgICAgICAgICAgLy8gbGlrZXMgdG8gZG8gZHJhZyBtaXJyb3JzLCB0aGVuIHJlbmRlciBhIGRyYWcgbWlycm9yLlxuICAgICAgICAgICAgaWYgKGlzRXZlbnQgJiYgKHRoaXMuZG9lc0RyYWdNaXJyb3IgfHwgc291cmNlU2VnICYmIHNvdXJjZVNlZy5jb21wb25lbnQuZG9lc0RyYWdNaXJyb3IpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JSZW5kZXJlci5yZW5kZXJTZWdzKHNlZ3MsIHsgaXNEcmFnZ2luZzogdHJ1ZSwgc291cmNlU2VnIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgLy8gaWYgaXQgd291bGQgYmUgaW1wb3NzaWJsZSB0byByZW5kZXIgYSBkcmFnIG1pcnJvciBPUiB0aGlzIGNvbXBvbmVudCBsaWtlcyB0byByZW5kZXJcbiAgICAgICAgICAgIC8vIGhpZ2hsaWdodHMsIHRoZW4gcmVuZGVyIGEgaGlnaGxpZ2h0LlxuICAgICAgICAgICAgaWYgKCFpc0V2ZW50IHx8IHRoaXMuZG9lc0RyYWdIaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnaGlnaGxpZ2h0Jywgc2VncylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICAvLyBIaXQgU3lzdGVtXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkUG9zaXRpb25DYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVmFsaWRhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0ludGVyYWN0aW9uVmFsaWQgPSBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG4gICAgICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLnByb3BzLmRhdGVQcm9maWxlOyAvLyBIQUNLXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VzID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cy5pbnN0YW5jZXM7XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHsgLy8gSEFDSyBmb3IgRGF5VGlsZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGNhbGVuZGFyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNEYXRlU2VsZWN0aW9uVmFsaWQgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLnByb3BzLmRhdGVQcm9maWxlOyAvLyBIQUNLXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUgJiYgLy8gSEFDSyBmb3IgRGF5VGlsZVxuICAgICAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgc2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0RhdGVTZWxlY3Rpb25WYWxpZChzZWxlY3Rpb24sIHRoaXMuY2FsZW5kYXIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFRPRE86IG1vdmUgdG8gQ2FsZW5kYXJcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyKG5hbWUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXJBZnRlclNpemluZyA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlckFmdGVyU2l6aW5nKG5hbWUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oYXNQdWJsaWNIYW5kbGVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmhhc1B1YmxpY0hhbmRsZXJzKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVuZGVyZWRTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGlzTWlycm9ycykge1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudFBvc2l0aW9uZWQnKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlckFmdGVyU2l6aW5nKCdldmVudFBvc2l0aW9uZWQnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjYWxlbmRhciwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNaXJyb3I6IGlzTWlycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWcuZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdGhpcyAvLyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIuc3RhdGUubG9hZGluZ0xldmVsKSB7IC8vIGF2b2lkIGluaXRpYWwgZW1wdHkgc3RhdGUgd2hpbGUgcGVuZGluZ1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmFmdGVyU2l6aW5nVHJpZ2dlcnMuX2V2ZW50c1Bvc2l0aW9uZWQgPSBbbnVsbF07IC8vIGZpcmUgb25jZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyV2lsbFJlbW92ZVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgaXNNaXJyb3JzKSB7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcbiAgICAgICAgICAgICAgICBjYWxlbmRhci50cmlnZ2VyKCdldmVudEVsUmVtb3ZlJywgc2VnLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudERlc3Ryb3knKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgc2Vnc18zID0gc2VnczsgX2EgPCBzZWdzXzMubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzNbX2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREZXN0cm95JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY2FsZW5kYXIsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWlycm9yOiBpc01pcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHNlZy5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB0aGlzIC8vID9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBQb2ludGVyIEludGVyYWN0aW9uIFV0aWxzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWRTZWdEb3duRWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wcm9wcy5ldmVudERyYWcgJiYgLy8gSEFDS1xuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbWlycm9yJykgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5pc1BvcG92ZXIoKSB8fCAhdGhpcy5pc0luUG9wb3ZlcihlbCkpO1xuICAgICAgICAgICAgLy8gXmFib3ZlIGxpbmUgZW5zdXJlcyB3ZSBkb24ndCBkZXRlY3QgYSBzZWcgaW50ZXJhY3Rpb24gd2l0aGluIGEgbmVzdGVkIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIGl0J3MgYSBIQUNLIGJlY2F1c2UgaXQgb25seSBzdXBwb3J0cyBhIHBvcG92ZXIgYXMgdGhlIG5lc3RlZCBjb21wb25lbnQuXG4gICAgICAgIH07XG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWREYXRlRG93bkVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBlbGVtZW50Q2xvc2VzdChlbCwgdGhpcy5mZ1NlZ1NlbGVjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiAoIXNlZ0VsIHx8IHNlZ0VsLmNsYXNzTGlzdC5jb250YWlucygnZmMtbWlycm9yJykpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUnKSAmJiAvLyBhIFwibW9yZS4uXCIgbGlua1xuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1nb3RvXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNJblBvcG92ZXIoZWwpO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLXBvcG92ZXInKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNJblBvcG92ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xuICAgIH0oQ29tcG9uZW50KSk7XG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZmdTZWdTZWxlY3RvciA9ICcuZmMtZXZlbnQtY29udGFpbmVyID4gKic7XG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmdTZWdTZWxlY3RvciA9ICcuZmMtYmdldmVudDpub3QoLmZjLW5vbmJ1c2luZXNzKSc7XG5cbiAgICB2YXIgdWlkJDEgPSAwO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IFN0cmluZyh1aWQkMSsrKSxcbiAgICAgICAgICAgIGRlcHM6IGlucHV0LmRlcHMgfHwgW10sXG4gICAgICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgICAgICBldmVudERlZlBhcnNlcnM6IGlucHV0LmV2ZW50RGVmUGFyc2VycyB8fCBbXSxcbiAgICAgICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBpbnB1dC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGlucHV0LmRhdGVQb2ludFRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaW5wdXQudmlld1Byb3BzVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICAgICAgZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtczogaW5wdXQuZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJNb2RpZmllcnM6IGlucHV0LnZpZXdDb250YWluZXJNb2RpZmllcnMgfHwgW10sXG4gICAgICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGlucHV0LmV2ZW50RHJvcFRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICAgICAgdGhlbWVDbGFzc2VzOiBpbnB1dC50aGVtZUNsYXNzZXMgfHwge30sXG4gICAgICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGlucHV0LnJlY3VycmluZ1R5cGVzIHx8IFtdLFxuICAgICAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgICAgICBkZWZhdWx0VmlldzogaW5wdXQuZGVmYXVsdFZpZXcgfHwgJycsXG4gICAgICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBpbnB1dC5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBQbHVnaW5TeXN0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsdWdpblN5c3RlbSgpIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MgPSB7XG4gICAgICAgICAgICAgICAgcmVkdWNlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGV2ZW50RGVmUGFyc2VyczogW10sXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgICAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgICAgICAgICB2aWV3czoge30sXG4gICAgICAgICAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyTW9kaWZpZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcbiAgICAgICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmlldzogJycsXG4gICAgICAgICAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFkZGVkSGFzaCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFBsdWdpblN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkZGVkSGFzaFtwbHVnaW4uaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRlZEhhc2hbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHBsdWdpbi5kZXBzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChkZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzID0gY29tYmluZUhvb2tzKHRoaXMuaG9va3MsIHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQbHVnaW5TeXN0ZW07XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwLCBob29rczEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgICAgICAgICBldmVudERlZlBhcnNlcnM6IGhvb2tzMC5ldmVudERlZlBhcnNlcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZlBhcnNlcnMpLFxuICAgICAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxuICAgICAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICAgICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgICAgICB2aWV3czogX19hc3NpZ24oe30sIGhvb2tzMC52aWV3cywgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaG9va3MwLnZpZXdQcm9wc1RyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLnZpZXdQcm9wc1RyYW5zZm9ybWVycyksXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcbiAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgICAgICBldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zOiBob29rczAuZXZlbnRSZXNpemVKb2luVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV2ZW50UmVzaXplSm9pblRyYW5zZm9ybXMpLFxuICAgICAgICAgICAgdmlld0NvbnRhaW5lck1vZGlmaWVyczogaG9va3MwLnZpZXdDb250YWluZXJNb2RpZmllcnMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyTW9kaWZpZXJzKSxcbiAgICAgICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcbiAgICAgICAgICAgIHRoZW1lQ2xhc3NlczogX19hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMsIGhvb2tzMS50aGVtZUNsYXNzZXMpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGhvb2tzMC5yZWN1cnJpbmdUeXBlcy5jb25jYXQoaG9va3MxLnJlY3VycmluZ1R5cGVzKSxcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICAgICAgZGVmYXVsdFZpZXc6IGhvb2tzMC5kZWZhdWx0VmlldyB8fCBob29rczEuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBob29rczAuZWxlbWVudERyYWdnaW5nSW1wbCB8fCBob29rczEuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBfX2Fzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzLCBob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50U291cmNlRGVmID0ge1xuICAgICAgICBpZ25vcmVSYW5nZTogdHJ1ZSxcbiAgICAgICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7IC8vIHNob3J0IGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyYXcuZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXcuZXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzKSB7XG4gICAgICAgICAgICBzdWNjZXNzKHtcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIEFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl1cbiAgICB9KTtcblxuICAgIHZhciBldmVudFNvdXJjZURlZiQxID0ge1xuICAgICAgICBwYXJzZU1ldGE6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnZnVuY3Rpb24nKSB7IC8vIHNob3J0IGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhdy5ldmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3LmV2ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSBhcmcuY2FsZW5kYXIuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShhcmcucmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUoYXJnLnJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKGFyZy5yYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhhcmcucmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZTogZGF0ZUVudi50aW1lWm9uZVxuICAgICAgICAgICAgfSksIGZ1bmN0aW9uIChyYXdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMgfSk7IC8vIG5lZWRzIGFuIG9iamVjdCByZXNwb25zZVxuICAgICAgICAgICAgfSwgZmFpbHVyZSAvLyBzZW5kIGVycm9yT2JqIGRpcmVjdGx5IHRvIGZhaWx1cmUgY2FsbGJhY2tcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBGdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHVybCA9IGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhyZXMsIHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdGYWlsdXJlIHBhcnNpbmcgSlNPTicsIHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdXJsICtcbiAgICAgICAgICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICAgZW5jb2RlUGFyYW1zKHBhcmFtcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJicpO1xuICAgIH1cblxuICAgIHZhciBldmVudFNvdXJjZURlZiQyID0ge1xuICAgICAgICBwYXJzZU1ldGE6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykgeyAvLyBzaG9ydCBmb3JtXG4gICAgICAgICAgICAgICAgcmF3ID0geyB1cmw6IHJhdyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJhdyB8fCB0eXBlb2YgcmF3ICE9PSAnb2JqZWN0JyB8fCAhcmF3LnVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJhdy51cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmF3Lm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmF3LmV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgICAgIHN0YXJ0UGFyYW06IHJhdy5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByYXcuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmF3LnRpbWVab25lUGFyYW1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgICAgICB2YXIgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgYXJnLnJhbmdlLCBhcmcuY2FsZW5kYXIpO1xuICAgICAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zLCBmdW5jdGlvbiAocmF3RXZlbnRzLCB4aHIpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMsIHhocjogeGhyIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgeGhyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZSh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSwgeGhyOiB4aHIgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIEpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQyXVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBjYWxlbmRhci5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhcnRQYXJhbTtcbiAgICAgICAgdmFyIGVuZFBhcmFtO1xuICAgICAgICB2YXIgdGltZVpvbmVQYXJhbTtcbiAgICAgICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICAgICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnc3RhcnRQYXJhbScpO1xuICAgICAgICB9XG4gICAgICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICAgICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZFBhcmFtID0gY2FsZW5kYXIub3B0KCdlbmRQYXJhbScpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVab25lUGFyYW0gPSBjYWxlbmRhci5vcHQoJ3RpbWVab25lUGFyYW0nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBfX2Fzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgICAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xuICAgICAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIHZhciByZWN1cnJpbmcgPSB7XG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAocmF3RXZlbnQsIGxlZnRvdmVyUHJvcHMsIGRhdGVFbnYpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVNYXJrZXIgPSBkYXRlRW52LmNyZWF0ZU1hcmtlci5iaW5kKGRhdGVFbnYpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvcnMgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IGNyZWF0ZU1hcmtlcixcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogY3JlYXRlTWFya2VyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMocmF3RXZlbnQsIHByb2Nlc3NvcnMsIHt9LCBsZWZ0b3ZlclByb3BzKTtcbiAgICAgICAgICAgIHZhciBhbnlWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYW55VmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW55VmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcHJvcHMuc3RhcnRUaW1lICYmICFwcm9wcy5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IChwcm9wcy5zdGFydFRpbWUgJiYgcHJvcHMuZW5kVGltZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3REdXJhdGlvbnMocHJvcHMuZW5kVGltZSwgcHJvcHMuc3RhcnRUaW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlRGF0YTogcHJvcHMgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICAgICAgdmFyIGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICAgICAgaWYgKGNsaXBwZWRGcmFtaW5nUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBTaW1wbGVSZWN1cnJlbmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZXhwYW5kUmFuZ2VzKGRheXNPZldlZWssIHN0YXJ0VGltZSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgICAgIHZhciBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICAgICAgdmFyIGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmQ7XG4gICAgICAgIHZhciBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VTdGFydCBcbiAgICAgICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgICAgID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgICAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRhdGVFbnYuYWRkKGRheU1hcmtlciwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXlNYXJrZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlU3RhcnRzO1xuICAgIH1cblxuICAgIHZhciBEZWZhdWx0T3B0aW9uQ2hhbmdlSGFuZGxlcnMgPSBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICAgICAgZXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzLCBjYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgcGx1Z2luczogaGFuZGxlUGx1Z2luc1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIHVuZm91bmRTb3VyY2VzID0gaGFzaFZhbHVlc1RvQXJyYXkoY2FsZW5kYXIuc3RhdGUuZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgdmFyIG5ld0lucHV0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGlucHV0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZXNTaW1pbGFyKHVuZm91bmRTb3VyY2VzW2ldLl9yYXcsIGlucHV0LCAyKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgICAgICBpbnB1dEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgdW5mb3VuZFNvdXJjZXNfMSA9IHVuZm91bmRTb3VyY2VzOyBfYSA8IHVuZm91bmRTb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5mb3VuZFNvdXJjZSA9IHVuZm91bmRTb3VyY2VzXzFbX2FdO1xuICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBuZXdJbnB1dHNfMSA9IG5ld0lucHV0czsgX2IgPCBuZXdJbnB1dHNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdJbnB1dCA9IG5ld0lucHV0c18xW19iXTtcbiAgICAgICAgICAgIGNhbGVuZGFyLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzaG9ydGNvbWluZzogd29uJ3QgcmVtb3ZlIHBsdWdpbnNcbiAgICBmdW5jdGlvbiBoYW5kbGVQbHVnaW5zKGlucHV0cywgY2FsZW5kYXIpIHtcbiAgICAgICAgY2FsZW5kYXIuYWRkUGx1Z2luSW5wdXRzKGlucHV0cyk7IC8vIHdpbGwgZ3JhY2VmdWxseSBoYW5kbGUgZHVwbGljYXRlc1xuICAgIH1cblxuICAgIHZhciBjb25maWcgPSB7fTsgLy8gVE9ETzogbWFrZSB0aGVzZSBvcHRpb25zXG4gICAgdmFyIGdsb2JhbERlZmF1bHRzID0ge1xuICAgICAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgICAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJyxcbiAgICAgICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcbiAgICAgICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXG4gICAgICAgIC8vIGRpc3BsYXlcbiAgICAgICAgY29sdW1uSGVhZGVyOiB0cnVlLFxuICAgICAgICBkZWZhdWx0VmlldzogJycsXG4gICAgICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIGxlZnQ6ICd0aXRsZScsXG4gICAgICAgICAgICBjZW50ZXI6ICcnLFxuICAgICAgICAgICAgcmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtlbmRzOiB0cnVlLFxuICAgICAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcbiAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAvLyBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgICAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxuICAgICAgICBtaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgICAgICBtYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxuICAgICAgICAvLyBldmVudCBhamF4XG4gICAgICAgIGxhenlGZXRjaGluZzogdHJ1ZSxcbiAgICAgICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcbiAgICAgICAgZW5kUGFyYW06ICdlbmQnLFxuICAgICAgICB0aW1lWm9uZVBhcmFtOiAndGltZVpvbmUnLFxuICAgICAgICB0aW1lWm9uZTogJ2xvY2FsJyxcbiAgICAgICAgLy8gYWxsRGF5RGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBsb2NhbGVcbiAgICAgICAgbG9jYWxlczogW10sXG4gICAgICAgIGxvY2FsZTogJycsXG4gICAgICAgIC8vIGRpcjogd2lsbCBnZXQgdGhpcyBmcm9tIHRoZSBkZWZhdWx0IGxvY2FsZVxuICAgICAgICAvLyBidXR0b25JY29uczogbnVsbCxcbiAgICAgICAgLy8gYWxsb3dzIHNldHRpbmcgYSBtaW4taGVpZ2h0IHRvIHRoZSBldmVudCBzZWdtZW50IHRvIHByZXZlbnQgc2hvcnQgZXZlbnRzIG92ZXJsYXBwaW5nIGVhY2ggb3RoZXJcbiAgICAgICAgdGltZUdyaWRFdmVudE1pbkhlaWdodDogMCxcbiAgICAgICAgdGhlbWVTeXN0ZW06ICdzdGFuZGFyZCcsXG4gICAgICAgIC8vIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcbiAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG4gICAgICAgIGRyYWdTY3JvbGw6IHRydWUsXG4gICAgICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgICAgICAvLyBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxuICAgICAgICAvLyBzZWxlY3RNaW5EaXN0YW5jZTogMCxcbiAgICAgICAgZHJvcEFjY2VwdDogJyonLFxuICAgICAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gICAgICAgIC8vIF4gaWYgc3RhcnQgdGllLCBsb25nZXIgZXZlbnRzIGdvIGJlZm9yZSBzaG9ydGVyLiBmaW5hbCB0aWUtYnJlYWtlciBpcyB0aXRsZSB0ZXh0XG4gICAgICAgIC8vIHJlcmVuZGVyRGVsYXk6IG51bGwsXG4gICAgICAgIGV2ZW50TGltaXQ6IGZhbHNlLFxuICAgICAgICBldmVudExpbWl0Q2xpY2s6ICdwb3BvdmVyJyxcbiAgICAgICAgZGF5UG9wb3ZlckZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcbiAgICAgICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDAsXG4gICAgICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1IC8vIG9ubHkgYXBwbGllcyB0byBtb3VzZVxuICAgIH07XG4gICAgdmFyIHJ0bERlZmF1bHRzID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxuICAgICAgICAgICAgY2VudGVyOiAnJyxcbiAgICAgICAgICAgIHJpZ2h0OiAndGl0bGUnXG4gICAgICAgIH0sXG4gICAgICAgIGJ1dHRvbkljb25zOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIFJUTCBzdXBwb3J0IHRoZSByZXNwb25pYmlsaXR5IG9mIHRoZSB0aGVtZVxuICAgICAgICAgICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgICAgICAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgICAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgICAgICAgICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0J1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tcGxleE9wdGlvbnMgPSBbXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnZm9vdGVyJyxcbiAgICAgICAgJ2J1dHRvblRleHQnLFxuICAgICAgICAnYnV0dG9uSWNvbnMnXG4gICAgXTtcbiAgICAvLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcbiAgICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uT2Jqcykge1xuICAgICAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25PYmpzLCBjb21wbGV4T3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBzdHVmZiB0byBhIFwicGx1Z2luXCItcmVsYXRlZCBmaWxlLi4uXG4gICAgdmFyIElOVEVSTkFMX1BMVUdJTlMgPSBbXG4gICAgICAgIEFycmF5RXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgICAgIEZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICAgICAgSnNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgICAgICAgU2ltcGxlUmVjdXJyZW5jZVBsdWdpbixcbiAgICAgICAgRGVmYXVsdE9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgXTtcbiAgICBmdW5jdGlvbiByZWZpbmVQbHVnaW5EZWZzKHBsdWdpbklucHV0cykge1xuICAgICAgICB2YXIgcGx1Z2lucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBsdWdpbklucHV0c18xID0gcGx1Z2luSW5wdXRzOyBfaSA8IHBsdWdpbklucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBsdWdpbklucHV0ID0gcGx1Z2luSW5wdXRzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5JbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsTmFtZSA9ICdGdWxsQ2FsZW5kYXInICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHBsdWdpbklucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvd1tnbG9iYWxOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BsdWdpbiBmaWxlIG5vdCBsb2FkZWQgZm9yICcgKyBwbHVnaW5JbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2god2luZG93W2dsb2JhbE5hbWVdLmRlZmF1bHQpOyAvLyBpcyBhbiBFUzYgbW9kdWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbklucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSU5URVJOQUxfUExVR0lOUy5jb25jYXQocGx1Z2lucyk7XG4gICAgfVxuXG4gICAgdmFyIFJBV19FTl9MT0NBTEUgPSB7XG4gICAgICAgIGNvZGU6ICdlbicsXG4gICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgIGRvdzogMCxcbiAgICAgICAgICAgIGRveTogNCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgICAgICB9LFxuICAgICAgICBkaXI6ICdsdHInLFxuICAgICAgICBidXR0b25UZXh0OiB7XG4gICAgICAgICAgICBwcmV2OiAncHJldicsXG4gICAgICAgICAgICBuZXh0OiAnbmV4dCcsXG4gICAgICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgICAgICAgICB5ZWFyOiAneWVhcicsXG4gICAgICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgICAgIG1vbnRoOiAnbW9udGgnLFxuICAgICAgICAgICAgd2VlazogJ3dlZWsnLFxuICAgICAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgICAgIGxpc3Q6ICdsaXN0J1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrTGFiZWw6ICdXJyxcbiAgICAgICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgICAgICBldmVudExpbWl0VGV4dDogJ21vcmUnLFxuICAgICAgICBub0V2ZW50c01lc3NhZ2U6ICdObyBldmVudHMgdG8gZGlzcGxheSdcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRDb2RlID0gZXhwbGljaXRSYXdMb2NhbGVzLmxlbmd0aCA+IDAgPyBleHBsaWNpdFJhd0xvY2FsZXNbMF0uY29kZSA6ICdlbic7XG4gICAgICAgIHZhciBnbG9iYWxBcnJheSA9IHdpbmRvd1snRnVsbENhbGVuZGFyTG9jYWxlc0FsbCddIHx8IFtdOyAvLyBmcm9tIGxvY2FsZXMtYWxsLmpzXG4gICAgICAgIHZhciBnbG9iYWxPYmplY3QgPSB3aW5kb3dbJ0Z1bGxDYWxlbmRhckxvY2FsZXMnXSB8fCB7fTsgLy8gZnJvbSBsb2NhbGVzLyouanMuIGtleXMgYXJlIG1lYW5pbmdsZXNzXG4gICAgICAgIHZhciBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsQXJyYXkuY29uY2F0KC8vIGdsb2JhbEFycmF5IGlzIGxvdyBwcmlvXG4gICAgICAgIGhhc2hWYWx1ZXNUb0FycmF5KGdsb2JhbE9iamVjdCksIC8vIG1lZGl1bSBwcmlvXG4gICAgICAgIGV4cGxpY2l0UmF3TG9jYWxlcyAvLyBoaWdoZXN0IHByaW9cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgICAgIGVuOiBSQVdfRU5fTE9DQUxFIC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhbGxSYXdMb2NhbGVzXzEgPSBhbGxSYXdMb2NhbGVzOyBfaSA8IGFsbFJhd0xvY2FsZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByYXdMb2NhbGUgPSBhbGxSYXdMb2NhbGVzXzFbX2ldO1xuICAgICAgICAgICAgcmF3TG9jYWxlTWFwW3Jhd0xvY2FsZS5jb2RlXSA9IHJhd0xvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgICAgICAgICBkZWZhdWx0Q29kZTogZGVmYXVsdENvZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xuICAgICAgICB2YXIgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgICAgICB2YXIgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XG4gICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZVByb3BzKFtSQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWQuY29kZTsgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgICAgICAgdmFyIHdlZWsgPSBtZXJnZWQud2VlaztcbiAgICAgICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZUFyZzogY29kZUFyZyxcbiAgICAgICAgICAgIGNvZGVzOiBjb2RlcyxcbiAgICAgICAgICAgIHdlZWs6IHdlZWssXG4gICAgICAgICAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBPcHRpb25zTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT3B0aW9uc01hbmFnZXIob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IF9fYXNzaWduKHt9LCBvdmVycmlkZXMpOyAvLyBtYWtlIGEgY29weVxuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuICAgICAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBfX2Fzc2lnbih0aGlzLm92ZXJyaWRlcywgcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5hZGREeW5hbWljID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBfX2Fzc2lnbih0aGlzLmR5bmFtaWNPdmVycmlkZXMsIHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cbiAgICAgICAgLy8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG5vdCBhIHZlcnkgZWZmaWNpZW50IHN5c3RlbVxuICAgICAgICAgICAgdmFyIGxvY2FsZXMgPSBmaXJzdERlZmluZWQoLy8gZXhwbGljaXQgbG9jYWxlIG9wdGlvbiBnaXZlbj9cbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5sb2NhbGVzLCB0aGlzLm92ZXJyaWRlcy5sb2NhbGVzLCBnbG9iYWxEZWZhdWx0cy5sb2NhbGVzKTtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBmaXJzdERlZmluZWQoLy8gZXhwbGljaXQgbG9jYWxlcyBvcHRpb24gZ2l2ZW4/XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXMubG9jYWxlLCB0aGlzLm92ZXJyaWRlcy5sb2NhbGUsIGdsb2JhbERlZmF1bHRzLmxvY2FsZSk7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gcGFyc2VSYXdMb2NhbGVzKGxvY2FsZXMpO1xuICAgICAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzID0gYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlLm1hcCkub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaXJzdERlZmluZWQoLy8gYmFzZWQgb24gb3B0aW9ucyBjb21wdXRlZCBzbyBmYXIsIGlzIGRpcmVjdGlvbiBSVEw/XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXMuZGlyLCB0aGlzLm92ZXJyaWRlcy5kaXIsIGxvY2FsZURlZmF1bHRzLmRpcik7XG4gICAgICAgICAgICB2YXIgZGlyRGVmYXVsdHMgPSBkaXIgPT09ICdydGwnID8gcnRsRGVmYXVsdHMgOiB7fTtcbiAgICAgICAgICAgIHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVEZWZhdWx0cztcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBtZXJnZU9wdGlvbnMoW1xuICAgICAgICAgICAgICAgIGdsb2JhbERlZmF1bHRzLFxuICAgICAgICAgICAgICAgIGRpckRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzLFxuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlc1xuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPcHRpb25zTWFuYWdlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fTtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNhbGVuZGFyU3lzdGVtKG5hbWUsIHRoZUNsYXNzKSB7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbiAgICB9XG4gICAgdmFyIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSgpIHtcbiAgICAgICAgfVxuICAgICAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuZ2V0TWFya2VyWWVhciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICB9O1xuICAgICAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuZ2V0TWFya2VyTW9udGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlckRheSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5hcnJheVRvTWFya2VyID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgICAgIH07XG4gICAgICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5tYXJrZXJUb0FycmF5ID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbTtcbiAgICB9KCkpO1xuICAgIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XG5cbiAgICB2YXIgSVNPX1JFID0gL15cXHMqKFxcZHs0fSkoLShcXGR7Mn0pKC0oXFxkezJ9KShbVCBdKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG4gICAgZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgICAgIHZhciBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBuZXcgRGF0ZShEYXRlLlVUQyhOdW1iZXIobVsxXSksIG1bM10gPyBOdW1iZXIobVszXSkgLSAxIDogMCwgTnVtYmVyKG1bNV0gfHwgMSksIE51bWJlcihtWzddIHx8IDApLCBOdW1iZXIobVs4XSB8fCAwKSwgTnVtYmVyKG1bMTBdIHx8IDApLCBtWzEyXSA/IE51bWJlcignMC4nICsgbVsxMl0pICogMTAwMCA6IDApKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IHRpbWVab25lT2Zmc2V0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgRGF0ZUVudiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUVudihzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIHRpbWVab25lID0gdGhpcy50aW1lWm9uZSA9IHNldHRpbmdzLnRpbWVab25lO1xuICAgICAgICAgICAgdmFyIGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsID0gbmV3IHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0gPSBjcmVhdGVDYWxlbmRhclN5c3RlbShzZXR0aW5ncy5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcbiAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRveTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtEb3kgPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53ZWVrTGFiZWwgPSBzZXR0aW5ncy53ZWVrTGFiZWwgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtMYWJlbCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtMYWJlbDtcbiAgICAgICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5jcmVhdGVNYXJrZXJNZXRhKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU5vd01hcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxuICAgICAgICAgICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTWFya2VyTWV0YSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IG51bGwgfHwgIWlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1hcmtlcjogbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBwYXJzZShzKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHBhcnRzLm1hcmtlcjtcbiAgICAgICAgICAgIHZhciBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcnRzLnRpbWVab25lT2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem86IGZvcmNlZFR6byB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBBY2Nlc3NvcnNcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtYXJrZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobWFya2VyLCBkdXIpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcbiAgICAgICAgICAgIGFbMV0gKz0gZHVyLm1vbnRocztcbiAgICAgICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xuICAgICAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xuICAgICAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmFkZFllYXJzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgICAgIGFbMF0gKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmFkZE1vbnRocyA9IGZ1bmN0aW9uIChtYXJrZXIsIG4pIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgICAgICBhWzFdICs9IG47XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmRpZmZXaG9sZVllYXJzID0gZnVuY3Rpb24gKG0wLCBtMSkge1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyU3lzdGVtID0gdGhpcy5jYWxlbmRhclN5c3RlbTtcbiAgICAgICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkgJiZcbiAgICAgICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmRpZmZXaG9sZU1vbnRocyA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5ncmVhdGVzdFdob2xlVW5pdCA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jb3VudER1cmF0aW9uc0JldHdlZW4gPSBmdW5jdGlvbiAobTAsIG0xLCBkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBjYW4gdXNlIGdyZWF0ZXN0V2hvbGVVbml0XG4gICAgICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0LU9mXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2YgPSBmdW5jdGlvbiAobSwgdW5pdCkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZZZWFyKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXQgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRPZkRheShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mSG91cihtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXQgPT09ICdtaW51dGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mU2Vjb25kKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mWWVhciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mTW9udGggPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mV2VlayA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSAtICgobS5nZXRVVENEYXkoKSAtIHRoaXMud2Vla0RvdyArIDcpICUgNylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZWVrIE51bWJlclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jb21wdXRlV2Vla051bWJlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogY2hva2Ugb24gdGltZVpvbmVOYW1lOiBsb25nXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChkYXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGRhdGVPcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkTXMoZW5kLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihzdGFydClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKG1hcmtlciwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09PSB2b2lkIDApIHsgZXh0cmFPcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGltZVpvbmVcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUudGltZXN0YW1wVG9NYXJrZXIgPSBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUobXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLm9mZnNldEZvck1hcmtlciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgLy8gY29udmVydCBcImludmVyc2VcIiBvZmZzZXQgdG8gXCJub3JtYWxcIiBvZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbnZlcnNpb25cbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUudG9EYXRlID0gZnVuY3Rpb24gKG0sIGZvcmNlZFR6bykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSk7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpICogMTAwMCAqIDYwIC8vIGNvbnZlcnQgbWludXRlcyAtPiBtc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEYXRlRW52O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0lNUExFX1NPVVJDRV9QUk9QUyA9IHtcbiAgICAgICAgaWQ6IFN0cmluZyxcbiAgICAgICAgYWxsRGF5RGVmYXVsdDogQm9vbGVhbixcbiAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiBGdW5jdGlvbixcbiAgICAgICAgc3VjY2VzczogRnVuY3Rpb24sXG4gICAgICAgIGZhaWx1cmU6IEZ1bmN0aW9uXG4gICAgfTtcbiAgICB2YXIgdWlkJDIgPSAwO1xuICAgIGZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBkZWZzID0gY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICAgICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VFdmVudFNvdXJjZShyYXcsIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBkZWZzID0gY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICAgICAgdmFyIG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XG4gICAgICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwYXJzZUV2ZW50U291cmNlUHJvcHModHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgPyByYXcgOiB7fSwgbWV0YSwgaSwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgICAgIHJlcy5fcmF3ID0gZnJlZXplUmF3KHJhdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VFdmVudFNvdXJjZVByb3BzKHJhdywgbWV0YSwgc291cmNlRGVmSWQsIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBsZWZ0b3ZlcnMwID0ge307XG4gICAgICAgIHZhciBwcm9wcyA9IHJlZmluZVByb3BzKHJhdywgU0lNUExFX1NPVVJDRV9QUk9QUywge30sIGxlZnRvdmVyczApO1xuICAgICAgICB2YXIgbGVmdG92ZXJzMSA9IHt9O1xuICAgICAgICB2YXIgdWkgPSBwcm9jZXNzVW5zY29wZWRVaVByb3BzKGxlZnRvdmVyczAsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMxKTtcbiAgICAgICAgcHJvcHMuaXNGZXRjaGluZyA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5sYXRlc3RGZXRjaElkID0gJyc7XG4gICAgICAgIHByb3BzLmZldGNoUmFuZ2UgPSBudWxsO1xuICAgICAgICBwcm9wcy5wdWJsaWNJZCA9IFN0cmluZyhyYXcuaWQgfHwgJycpO1xuICAgICAgICBwcm9wcy5zb3VyY2VJZCA9IFN0cmluZyh1aWQkMisrKTtcbiAgICAgICAgcHJvcHMuc291cmNlRGVmSWQgPSBzb3VyY2VEZWZJZDtcbiAgICAgICAgcHJvcHMubWV0YSA9IG1ldGE7XG4gICAgICAgIHByb3BzLnVpID0gdWk7XG4gICAgICAgIHByb3BzLmV4dGVuZGVkUHJvcHMgPSBsZWZ0b3ZlcnMxO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzIChldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FERF9FVkVOVF9TT1VSQ0VTJzogLy8gYWxyZWFkeSBwYXJzZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9EQVRFJzpcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9USU1FWk9ORSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkcyA/XG4gICAgICAgICAgICAgICAgICAgIGFycmF5VG9IYXNoKGFjdGlvbi5zb3VyY2VJZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjYWxlbmRhciksIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjYWxlbmRhcik7XG4gICAgICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJlc3BvbnNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UpO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVpZCQzID0gMDtcbiAgICBmdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfaSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzXzFbX2ldO1xuICAgICAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoLCBoYXNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VIYXNoLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoLCBmZXRjaFJhbmdlLCBjYWxlbmRhcikge1xuICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjYWxlbmRhcik7XG4gICAgICAgIH0pLCBmZXRjaFJhbmdlLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKSB7XG4gICAgICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY2FsZW5kYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIWNhbGVuZGFyLm9wdCgnbGF6eUZldGNoaW5nJykgfHxcbiAgICAgICAgICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2Uuc3RhcnQgPCBldmVudFNvdXJjZS5mZXRjaFJhbmdlLnN0YXJ0IHx8XG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFNvdXJjZXNCeUlkcyhwcmV2U291cmNlcywgc291cmNlSWRIYXNoLCBmZXRjaFJhbmdlLCBjYWxlbmRhcikge1xuICAgICAgICB2YXIgbmV4dFNvdXJjZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgICAgICBpZiAoc291cmNlSWRIYXNoW3NvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0U291cmNlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBzb3VyY2VEZWYgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICAgICAgdmFyIGZldGNoSWQgPSBTdHJpbmcodWlkJDMrKyk7XG4gICAgICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgICAgICBldmVudFNvdXJjZTogZXZlbnRTb3VyY2UsXG4gICAgICAgICAgICBjYWxlbmRhcjogY2FsZW5kYXIsXG4gICAgICAgICAgICByYW5nZTogZmV0Y2hSYW5nZVxuICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB2YXIgcmF3RXZlbnRzID0gcmVzLnJhd0V2ZW50cztcbiAgICAgICAgICAgIHZhciBjYWxTdWNjZXNzID0gY2FsZW5kYXIub3B0KCdldmVudFNvdXJjZVN1Y2Nlc3MnKTtcbiAgICAgICAgICAgIHZhciBjYWxTdWNjZXNzUmVzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVN1Y2Nlc3NSZXM7XG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHNvdXJjZVN1Y2Nlc3NSZXMgPSBldmVudFNvdXJjZS5zdWNjZXNzKHJhd0V2ZW50cywgcmVzLnhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNhbFN1Y2Nlc3NSZXMgPSBjYWxTdWNjZXNzKHJhd0V2ZW50cywgcmVzLnhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYXdFdmVudHMgPSBzb3VyY2VTdWNjZXNzUmVzIHx8IGNhbFN1Y2Nlc3NSZXMgfHwgcmF3RXZlbnRzO1xuICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IHJhd0V2ZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGNhbGxGYWlsdXJlID0gY2FsZW5kYXIub3B0KCdldmVudFNvdXJjZUZhaWx1cmUnKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxGYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgY2FsbEZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgZmV0Y2hJZDogZmV0Y2hJZCxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGV2ZW50U291cmNlLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBzb3VyY2VIYXNoLCAoX2EgPSB7fSwgX2Fbc291cmNlSWRdID0gX19hc3NpZ24oe30sIGV2ZW50U291cmNlLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlIH0pLCBfYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VIYXNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNhbGVuZGFyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY2FsZW5kYXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERhdGVQcm9maWxlR2VuZXJhdG9yKHZpZXdTcGVjLCBjYWxlbmRhcikge1xuICAgICAgICAgICAgdGhpcy52aWV3U3BlYyA9IHZpZXdTcGVjO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdmlld1NwZWMub3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuZGF0ZUVudiA9IGNhbGVuZGFyLmRhdGVFbnY7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUHJldiA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGROZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5kYXRlRW52O1xuICAgICAgICAgICAgdmFyIG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgICAgICAvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcbiAgICAgICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZSwgZGlyZWN0aW9uLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVRvVmFsaWQgPT09IHZvaWQgMCkgeyBmb3JjZVRvVmFsaWQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHZhbGlkUmFuZ2U7XG4gICAgICAgICAgICB2YXIgbWluVGltZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VGltZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZm87XG4gICAgICAgICAgICB2YXIgaXNSYW5nZUFsbERheTtcbiAgICAgICAgICAgIHZhciByZW5kZXJSYW5nZTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVSYW5nZTtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XG4gICAgICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEluZm8gPSB0aGlzLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyhjdXJyZW50RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpO1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluVGltZSA9IGNyZWF0ZUR1cmF0aW9uKHRoaXMub3B0aW9ucy5taW5UaW1lKTtcbiAgICAgICAgICAgIG1heFRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aGlzLm9wdGlvbnMubWF4VGltZSk7XG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIHZhbGlkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgICAgIGlzVmFsaWQgPSByYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlOiB2YWxpZFJhbmdlLFxuICAgICAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuICAgICAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXG4gICAgICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xuICAgICAgICAgICAgICAgIGFjdGl2ZVJhbmdlOiBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgICAgIHJlbmRlclJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgICAgIG1pblRpbWU6IG1pblRpbWUsXG4gICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgICAgIG1heFRpbWU6IG1heFRpbWUsXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICAgICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgICAgICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAgICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlT3B0aW9uKCd2YWxpZFJhbmdlJywgdGhpcy5jYWxlbmRhci5nZXROb3coKSkgfHxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgdGhlIFwiY3VycmVudFwiIHJhbmdlLCB0aGUgcmFuZ2UgdGhhdCBpc1xuICAgICAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAgICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdG8gaGF2ZSBgcmFuZ2VgIGFuZCBgdW5pdGAgcHJvcGVydGllcy4gYGR1cmF0aW9uYCBpcyBvcHRpb25hbC5cbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHZpZXdTcGVjID0gX2Eudmlld1NwZWMsIGRhdGVFbnYgPSBfYS5kYXRlRW52O1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB1bml0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZGF5Q291bnQ7XG4gICAgICAgICAgICBpZiAodmlld1NwZWMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHZpZXdTcGVjLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIHVuaXQgPSB2aWV3U3BlYy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLm9wdGlvbnMuZGF5Q291bnQpKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gZGF0ZUVudi5ncmVhdGVzdFdob2xlVW5pdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKS51bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICB1bml0ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKS51bml0O1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IGR1cmF0aW9uLCB1bml0OiB1bml0LCByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgICAgICAvLyBtaW5UaW1lIG9yIG1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5hZGp1c3RBY3RpdmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3U3BlYy5jbGFzcy5wcm90b3R5cGUudXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIG1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKG1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5hZGQoc3RhcnQsIG1pblRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIG1heFRpbWUgaXMgYmV5b25kIG9uZSBkYXkgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKG1heFRpbWUpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBtYXhUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gICAgICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XG4gICAgICAgICAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5vcHRpb25zLmRhdGVBbGlnbm1lbnQ7XG4gICAgICAgICAgICB2YXIgZGF0ZUluY3JlbWVudElucHV0O1xuICAgICAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnREdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgICAgICBpZiAoIWFsaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0aW9ucy5kYXRlSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudER1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hNcyhkYXRlSW5jcmVtZW50RHVyYXRpb24pIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnREdXJhdGlvbiwgIWdldFdlZWtzRnJvbUlucHV0KGRhdGVJbmNyZW1lbnRJbnB1dCkpLnVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2YoZGF0ZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGRhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EYXlDb3VudCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdGlvbnMuZGF0ZUFsaWdubWVudDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZTtcbiAgICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgICBpZiAoY3VzdG9tQWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGN1c3RvbUFsaWdubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIDEpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgICAgICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1c3RvbVZpc2libGVSYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlUmFuZ2UgPSB0aGlzLmdldFJhbmdlT3B0aW9uKCd2aXNpYmxlUmFuZ2UnLCBkYXRlRW52LnRvRGF0ZShkYXRlKSk7XG4gICAgICAgICAgICBpZiAodmlzaWJsZVJhbmdlICYmICh2aXNpYmxlUmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCB2aXNpYmxlUmFuZ2UuZW5kID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmlzaWJsZVJhbmdlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cbiAgICAgICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJhbmdlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gICAgICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZERhdGVJbmNyZW1lbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdGlvbnMuZGF0ZUluY3JlbWVudDtcbiAgICAgICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5vcHRpb25zLmRhdGVBbGlnbm1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFyZ3VtZW50cyBhZnRlciBuYW1lIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGEgaHlwb3RoZXRpY2FsIGZ1bmN0aW9uIHZhbHVlXG4gICAgICAgIC8vIFdBUk5JTkc6IHBhc3NlZC1pbiBhcmd1bWVudHMgd2lsbCBiZSBnaXZlbiB0byBnZW5lcmF0b3IgZnVuY3Rpb25zIGFzLWlzIGFuZCBjYW4gY2F1c2Ugc2lkZS1lZmZlY3RzLlxuICAgICAgICAvLyBBbHdheXMgY2xvbmUgeW91ciBvYmplY3RzIGlmIHlvdSBmZWFyIG11dGF0aW9uLlxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0UmFuZ2VPcHRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvdGhlckFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5vcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuYXBwbHkobnVsbCwgb3RoZXJBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZVJhbmdlKHZhbCwgdGhpcy5kYXRlRW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICAvKiBIaWRkZW4gRGF5c1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoaWRkZW5EYXlzID0gdGhpcy5vcHRpb25zLmhpZGRlbkRheXMgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgICAgICAgICB2YXIgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgICAgIHZhciBkYXlDbnQgPSAwO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndlZWtlbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXlDbnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRheUNudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cbiAgICAgICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuICAgICAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIERhdGUgKHVzZWQgZm9yIFVUQylcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgICAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5za2lwSGlkZGVuRGF5cyA9IGZ1bmN0aW9uIChkYXRlLCBpbmMsIGlzRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxuICAgICAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB2b2lkIDApIHsgaXNFeGNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNIaWRkZW5EYXlIYXNoWyhkYXRlLmdldFVUQ0RheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgfSgpKTtcbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIGNvbXBhcmluZyBEYXRlUHJvZmlsZXMuIGl0J3MgdGVkaW91c1xuICAgIGZ1bmN0aW9uIGlzRGF0ZVByb2ZpbGVzRXF1YWwocDAsIHAxKSB7XG4gICAgICAgIHJldHVybiByYW5nZXNFcXVhbChwMC5hY3RpdmVSYW5nZSwgcDEuYWN0aXZlUmFuZ2UpICYmXG4gICAgICAgICAgICByYW5nZXNFcXVhbChwMC52YWxpZFJhbmdlLCBwMS52YWxpZFJhbmdlKSAmJlxuICAgICAgICAgICAgZHVyYXRpb25zRXF1YWwocDAubWluVGltZSwgcDEubWluVGltZSkgJiZcbiAgICAgICAgICAgIGR1cmF0aW9uc0VxdWFsKHAwLm1heFRpbWUsIHAxLm1heFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZHVjZSAoc3RhdGUsIGFjdGlvbiwgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIHZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUudmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKHN0YXRlLmRhdGVQcm9maWxlLCBhY3Rpb24sIHN0YXRlLmN1cnJlbnREYXRlLCB2aWV3VHlwZSwgY2FsZW5kYXIpO1xuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXIpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gX19hc3NpZ24oe30sIHN0YXRlLCB7IHZpZXdUeXBlOiB2aWV3VHlwZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgY3VycmVudERhdGU6IHJlZHVjZUN1cnJlbnREYXRlKHN0YXRlLmN1cnJlbnREYXRlLCBhY3Rpb24sIGRhdGVQcm9maWxlKSwgZXZlbnRTb3VyY2VzOiBldmVudFNvdXJjZXMsIGV2ZW50U3RvcmU6IHJlZHVjZUV2ZW50U3RvcmUoc3RhdGUuZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhciksIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uLCBjYWxlbmRhciksIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLCBldmVudERyYWc6IHJlZHVjZUV2ZW50RHJhZyhzdGF0ZS5ldmVudERyYWcsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBjYWxlbmRhciksIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGNhbGVuZGFyKSwgZXZlbnRTb3VyY2VMb2FkaW5nTGV2ZWw6IGNvbXB1dGVMb2FkaW5nTGV2ZWwoZXZlbnRTb3VyY2VzKSwgbG9hZGluZ0xldmVsOiBjb21wdXRlTG9hZGluZ0xldmVsKGV2ZW50U291cmNlcykgfSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MucmVkdWNlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVkdWNlckZ1bmMgPSBfYVtfaV07XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyRnVuYyhuZXh0U3RhdGUsIGFjdGlvbiwgY2FsZW5kYXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGFjdGlvbi50eXBlLCBuZXh0U3RhdGUpXG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKGN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24udmlld1R5cGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Vmlld1R5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCB2aWV3VHlwZSwgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIG5ld0RhdGVQcm9maWxlO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRlUHJvZmlsZSA9IGNhbGVuZGFyLmRhdGVQcm9maWxlR2VuZXJhdG9yc1t2aWV3VHlwZV0uYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICAgICAgbmV3RGF0ZVByb2ZpbGUgPSBjYWxlbmRhci5kYXRlUHJvZmlsZUdlbmVyYXRvcnNbdmlld1R5cGVdLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9EQVRFJzpcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSB8fFxuICAgICAgICAgICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBhY3Rpb24uZGF0ZU1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZVByb2ZpbGUgPSBjYWxlbmRhci5kYXRlUHJvZmlsZUdlbmVyYXRvcnNbdmlld1R5cGVdLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyLCB1bmRlZmluZWQsIHRydWUgLy8gZm9yY2VUb1ZhbGlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VUX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICAgICAgdmFyIGdlbmVyYXRvciA9IGNhbGVuZGFyLmRhdGVQcm9maWxlR2VuZXJhdG9yc1t2aWV3VHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZpZXdUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgRnVsbENhbGVuZGFyIHZpZXcgXCInICsgdmlld1R5cGUgKyAnXCIgZG9lcyBub3QgZXhpc3QuIE1ha2Ugc3VyZSB5b3VyIHBsdWdpbnMgYXJlIGxvYWRlZCBjb3JyZWN0bHkuJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnTm8gYXZhaWxhYmxlIEZ1bGxDYWxlbmRhciB2aWV3IHBsdWdpbnMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0RhdGVQcm9maWxlID0gZ2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlLCB1bmRlZmluZWQsIHRydWUgLy8gZm9yY2VUb1ZhbGlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3RGF0ZVByb2ZpbGUgJiZcbiAgICAgICAgICAgIG5ld0RhdGVQcm9maWxlLmlzVmFsaWQgJiZcbiAgICAgICAgICAgICEoY3VycmVudERhdGVQcm9maWxlICYmIGlzRGF0ZVByb2ZpbGVzRXF1YWwoY3VycmVudERhdGVQcm9maWxlLCBuZXdEYXRlUHJvZmlsZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3RGF0ZVByb2ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24sIGRhdGVQcm9maWxlKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnU0VUX0RBVEUnOlxuICAgICAgICAgICAgY2FzZSAnU0VUX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIG5ld0RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIGFjdGlvbiwgY2FsZW5kYXIpIHtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZCwgYWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgICAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24sIHNvdXJjZXMsIGNhbGVuZGFyKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICB2YXIgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IG5ld0RyYWcub3JpZ1NlZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50UmVzaXplKGN1cnJlbnRSZXNpemUsIGFjdGlvbiwgc291cmNlcywgY2FsZW5kYXIpIHtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICAgICAgdmFyIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IG5ld1Jlc2l6ZS5vcmlnU2VnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMb2FkaW5nTGV2ZWwoZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIHZhciBjbnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBzb3VyY2VJZCBpbiBldmVudFNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICBjbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY250O1xuICAgIH1cblxuICAgIHZhciBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgYWxsRGF5OiBCb29sZWFuXG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZURhdGVTcGFuKHJhdywgZGF0ZUVudiwgZGVmYXVsdER1cmF0aW9uKSB7XG4gICAgICAgIHZhciBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICAgICAgdmFyIHJhbmdlID0gc3Bhbi5yYW5nZTtcbiAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cbiAgICBXaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XG4gICAgICAgIHZhciBsZWZ0b3ZlcnMgPSB7fTtcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTLCB7fSwgbGVmdG92ZXJzKTtcbiAgICAgICAgdmFyIHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgICAgICB2YXIgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XG4gICAgICAgIHZhciBhbGxEYXkgPSBzdGFuZGFyZFByb3BzLmFsbERheTtcbiAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIHRoaXMgbGVmdG92ZXIgb2JqZWN0IGFzIHRoZSBzZWxlY3Rpb24gb2JqZWN0XG4gICAgICAgIGxlZnRvdmVycy5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydE1ldGEgPyBzdGFydE1ldGEubWFya2VyIDogbnVsbCxcbiAgICAgICAgICAgIGVuZDogZW5kTWV0YSA/IGVuZE1ldGEubWFya2VyIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBsZWZ0b3ZlcnMuYWxsRGF5ID0gYWxsRGF5O1xuICAgICAgICByZXR1cm4gbGVmdG92ZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgICAgICAgICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICAgICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbiAgICB9XG4gICAgLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbiAgICBmdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmFuZ2UnICYmIHByb3BOYW1lICE9PSAnYWxsRGF5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgcHJvcHMgdGhhdCBzcGFuMCBoYXMgdGhhdCBzcGFuMSBET0VTTidUIGhhdmU/XG4gICAgICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzcGFuMCkge1xuICAgICAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5lbmQpLFxuICAgICAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhzcGFuLnJhbmdlLmVuZCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKHNwYW4ucmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgJycsIC8vIHNvdXJjZUlkXG4gICAgICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgICAgIGNhbGVuZGFyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgICAgICAgICAgcmFuZ2U6IGRhdGVTcGFuLnJhbmdlLFxuICAgICAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGlzRW5kOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgICAgdmFyIHZpZXdUeXBlO1xuICAgICAgICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZpZXdUeXBlIGluIG92ZXJyaWRlQ29uZmlncykge1xuICAgICAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzaFt2aWV3VHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgICAgICBpZiAodmlld0RlZikge1xuICAgICAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3RGVmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnc1t2aWV3VHlwZV07XG4gICAgICAgIHZhciBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgICAgIHZhciBxdWVyeVByb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAgICAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhlQ2xhc3MgPSBxdWVyeVByb3AoJ2NsYXNzJyk7XG4gICAgICAgIHZhciBzdXBlclR5cGUgPSBxdWVyeVByb3AoJ3N1cGVyVHlwZScpO1xuICAgICAgICBpZiAoIXN1cGVyVHlwZSAmJiB0aGVDbGFzcykge1xuICAgICAgICAgICAgc3VwZXJUeXBlID1cbiAgICAgICAgICAgICAgICBmaW5kVmlld05hbWVCeVN1YmNsYXNzKHRoZUNsYXNzLCBvdmVycmlkZUNvbmZpZ3MpIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpbmRWaWV3TmFtZUJ5U3ViY2xhc3ModGhlQ2xhc3MsIGRlZmF1bHRDb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwZXJEZWYgPSBzdXBlclR5cGUgPyBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykgOiBudWxsO1xuICAgICAgICBpZiAoIXRoZUNsYXNzICYmIHN1cGVyRGVmKSB7XG4gICAgICAgICAgICB0aGVDbGFzcyA9IHN1cGVyRGVmLmNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhlQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICBjbGFzczogdGhlQ2xhc3MsXG4gICAgICAgICAgICBkZWZhdWx0czogX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcub3B0aW9ucyA6IHt9KSksXG4gICAgICAgICAgICBvdmVycmlkZXM6IF9fYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5vdmVycmlkZXMgOiB7fSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLm9wdGlvbnMgOiB7fSkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRWaWV3TmFtZUJ5U3ViY2xhc3Modmlld1N1YmNsYXNzLCBjb25maWdzKSB7XG4gICAgICAgIHZhciBzdXBlclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZpZXdTdWJjbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKHZhciB2aWV3VHlwZSBpbiBjb25maWdzKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gY29uZmlnc1t2aWV3VHlwZV07XG4gICAgICAgICAgICAvLyBuZWVkIERJUkVDVCBzdWJjbGFzcywgc28gaW5zdGFuY2VvZiB3b24ndCBkbyBpdFxuICAgICAgICAgICAgaWYgKHBhcnNlZC5jbGFzcyAmJiBwYXJzZWQuY2xhc3MucHJvdG90eXBlID09PSBzdXBlclByb3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG4gICAgfVxuICAgIHZhciBWSUVXX0RFRl9QUk9QUyA9IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBjbGFzczogbnVsbFxuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlnKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlucHV0ID0geyBjbGFzczogaW5wdXQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSByZWZpbmVQcm9wcyhpbnB1dCwgVklFV19ERUZfUFJPUFMsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1cGVyVHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgIGNsYXNzOiBwcm9wcy5jbGFzcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25zTWFuYWdlcikge1xuICAgICAgICB2YXIgZGVmYXVsdENvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKGRlZmF1bHRJbnB1dHMpO1xuICAgICAgICB2YXIgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25zTWFuYWdlci5vdmVycmlkZXMudmlld3MpO1xuICAgICAgICB2YXIgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCBmdW5jdGlvbiAodmlld0RlZikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25zTWFuYWdlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uc01hbmFnZXIpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uSW5wdXQgPSB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLmR1cmF0aW9uO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xuICAgICAgICB2YXIgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgICAgIHZhciBzaW5nbGVVbml0ID0gJyc7XG4gICAgICAgIHZhciBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgICAgIHZhciBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbiwgIWdldFdlZWtzRnJvbUlucHV0KGR1cmF0aW9uSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5vcHRpb25zIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeUJ1dHRvblRleHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHRNYXAgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgICAgICAgICB2YXIgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgICAgIGlmIChidXR0b25UZXh0S2V5ICE9IG51bGwgJiYgYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICAgICAgY2xhc3M6IHZpZXdEZWYuY2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IGR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHNpbmdsZVVuaXQ6IHNpbmdsZVVuaXQsXG4gICAgICAgICAgICBvcHRpb25zOiBfX2Fzc2lnbih7fSwgZ2xvYmFsRGVmYXVsdHMsIHZpZXdEZWYuZGVmYXVsdHMsIG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzLCBvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cywgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLCBzaW5nbGVVbml0T3ZlcnJpZGVzLCB2aWV3RGVmLm92ZXJyaWRlcywgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcyksXG4gICAgICAgICAgICBidXR0b25UZXh0T3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5keW5hbWljT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5vdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxuICAgICAgICAgICAgYnV0dG9uVGV4dERlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIuZGlyRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KGdsb2JhbERlZmF1bHRzKSB8fFxuICAgICAgICAgICAgICAgIHZpZXdEZWYudHlwZSAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUb29sYmFyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUb29sYmFyKGNvbnRleHQsIGV4dHJhQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuX3JlbmRlckxheW91dCA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyTGF5b3V0LCBfdGhpcy51bnJlbmRlckxheW91dCk7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlVGl0bGUgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnVwZGF0ZVRpdGxlLCBudWxsLCBbX3RoaXMuX3JlbmRlckxheW91dF0pO1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZUJ1dHRvbiA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMudXBkYXRlQWN0aXZlQnV0dG9uLCBudWxsLCBbX3RoaXMuX3JlbmRlckxheW91dF0pO1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVRvZGF5ID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy51cGRhdGVUb2RheSwgbnVsbCwgW190aGlzLl9yZW5kZXJMYXlvdXRdKTtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVQcmV2ID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy51cGRhdGVQcmV2LCBudWxsLCBbX3RoaXMuX3JlbmRlckxheW91dF0pO1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZU5leHQgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnVwZGF0ZU5leHQsIG51bGwsIFtfdGhpcy5fcmVuZGVyTGF5b3V0XSk7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhciAnICsgZXh0cmFDbGFzc05hbWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGF5b3V0LnVucmVuZGVyKCk7IC8vIHNob3VsZCB1bnJlbmRlciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGF5b3V0KHByb3BzLmxheW91dCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaXRsZShwcm9wcy50aXRsZSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVCdXR0b24ocHJvcHMuYWN0aXZlQnV0dG9uKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvZGF5KHByb3BzLmlzVG9kYXlFbmFibGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByZXYocHJvcHMuaXNQcmV2RW5hYmxlZCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVOZXh0KHByb3BzLmlzTmV4dEVuYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXJMYXlvdXQgPSBmdW5jdGlvbiAobGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgdGhpcy52aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoZWwsIHRoaXMucmVuZGVyU2VjdGlvbignbGVmdCcsIGxheW91dC5sZWZ0KSk7XG4gICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoZWwsIHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJywgbGF5b3V0LmNlbnRlcikpO1xuICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50KGVsLCB0aGlzLnJlbmRlclNlY3Rpb24oJ3JpZ2h0JywgbGF5b3V0LnJpZ2h0KSk7XG4gICAgICAgIH07XG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnVucmVuZGVyTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgYnV0dG9uU3RyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgdGhlbWUgPSBfYS50aGVtZSwgY2FsZW5kYXIgPSBfYS5jYWxlbmRhcjtcbiAgICAgICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IGNhbGVuZGFyLm9wdGlvbnNNYW5hZ2VyO1xuICAgICAgICAgICAgdmFyIHZpZXdTcGVjcyA9IGNhbGVuZGFyLnZpZXdTcGVjcztcbiAgICAgICAgICAgIHZhciBzZWN0aW9uRWwgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLScgKyBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBvcHRpb25zTWFuYWdlci5jb21wdXRlZC5jdXN0b21CdXR0b25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dCA9IG9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkLmJ1dHRvblRleHQgfHwge307XG4gICAgICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uU3RyLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uR3JvdXBTdHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBFbDtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25OYW1lLCBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tQnV0dG9uUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld1NwZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklubmVySHRtbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25DbGFzc2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkFyaWFBdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuLnB1c2goaHRtbFRvRWxlbWVudCgnPGgyPiZuYnNwOzwvaDI+JykpOyAvLyB3ZSBhbHdheXMgd2FudCBpdCB0byB0YWtlIHVwIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGJ1dHRvbkVsLCBldik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXiBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSBodG1sRXNjYXBlKGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQXJpYUF0dHIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSBcIjxzcGFuIGNsYXNzPSdcIiArIGJ1dHRvbkljb24gKyBcIic+PC9zcGFuPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQXJpYUF0dHIgPSAnIGFyaWEtbGFiZWw9XCInICsgYnV0dG9uTmFtZSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwgPSBodG1sVG9FbGVtZW50KC8vIHR5cGU9XCJidXR0b25cIiBzbyB0aGF0IGl0IGRvZXNuJ3Qgc3VibWl0IGEgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCInICsgYnV0dG9uQ2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc+JyArIGJ1dHRvbklubmVySHRtbCArICc8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBidXR0b25DbGljayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4ucHVzaChidXR0b25FbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwQ2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkdyb3VwQ2xhc3NOYW1lID0gdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbmx5QnV0dG9ucyAmJiBidXR0b25Hcm91cENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuY2xhc3NMaXN0LmFkZChidXR0b25Hcm91cENsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoZ3JvdXBFbCwgZ3JvdXBDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kQ2hpbGQoZ3JvdXBFbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoc2VjdGlvbkVsLCBncm91cENoaWxkcmVuKTsgLy8gMSBvciAwIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uRWw7XG4gICAgICAgIH07XG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZVRvZGF5ID0gZnVuY3Rpb24gKGlzVG9kYXlFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbkVuYWJsZWQoJ3RvZGF5JywgaXNUb2RheUVuYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVQcmV2ID0gZnVuY3Rpb24gKGlzUHJldkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uRW5hYmxlZCgncHJldicsIGlzUHJldkVuYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVOZXh0ID0gZnVuY3Rpb24gKGlzTmV4dEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uRW5hYmxlZCgnbmV4dCcsIGlzTmV4dEVuYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICBmaW5kRWxlbWVudHModGhpcy5lbCwgJ2gyJykuZm9yRWFjaChmdW5jdGlvbiAodGl0bGVFbCkge1xuICAgICAgICAgICAgICAgIHRpdGxlRWwuaW5uZXJUZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMudGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpO1xuICAgICAgICAgICAgZmluZEVsZW1lbnRzKHRoaXMuZWwsICdidXR0b24nKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25FbCkge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lICYmIGJ1dHRvbkVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUudG9nZ2xlQnV0dG9uRW5hYmxlZCA9IGZ1bmN0aW9uIChidXR0b25OYW1lLCBib29sKSB7XG4gICAgICAgICAgICBmaW5kRWxlbWVudHModGhpcy5lbCwgJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJykuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uRWwpIHtcbiAgICAgICAgICAgICAgICBidXR0b25FbC5kaXNhYmxlZCA9ICFib29sO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUb29sYmFyO1xuICAgIH0oQ29tcG9uZW50KSk7XG5cbiAgICB2YXIgQ2FsZW5kYXJDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDYWxlbmRhckNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FsZW5kYXJDb21wb25lbnQoY29udGV4dCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5fcmVuZGVyVG9vbGJhcnMgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnJlbmRlclRvb2xiYXJzKTtcbiAgICAgICAgICAgIF90aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHByZXBlbmRUb0VsZW1lbnQoZWwsIF90aGlzLmNvbnRlbnRFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdmlldy1jb250YWluZXInIH0pKTtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IF90aGlzLmNhbGVuZGFyO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy52aWV3Q29udGFpbmVyTW9kaWZpZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZnlWaWV3Q29udGFpbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1vZGlmeVZpZXdDb250YWluZXIoX3RoaXMuY29udGVudEVsLCBjYWxlbmRhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy50b2dnbGVFbENsYXNzTmFtZXModHJ1ZSk7XG4gICAgICAgICAgICBfdGhpcy5jb21wdXRlVGl0bGUgPSBtZW1vaXplKGNvbXB1dGVUaXRsZSk7XG4gICAgICAgICAgICBfdGhpcy5wYXJzZUJ1c2luZXNzSG91cnMgPSBtZW1vaXplKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIF90aGlzLmNhbGVuZGFyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb290ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMuY29udGVudEVsKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRWxDbGFzc05hbWVzKGZhbHNlKTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUudG9nZ2xlRWxDbGFzc05hbWVzID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLmVsLmNsYXNzTGlzdDtcbiAgICAgICAgICAgIHZhciBkaXJDbGFzc05hbWUgPSAnZmMtJyArIHRoaXMub3B0KCdkaXInKTtcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzTmFtZSA9IHRoaXMudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldCcpO1xuICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdmYycpO1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoZGlyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKHRoZW1lQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2ZjJyk7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShkaXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUodGhlbWVDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5jb21wdXRlVGl0bGUocHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLnZpZXdTcGVjLm9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVG9vbGJhcnMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5jdXJyZW50RGF0ZSwgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcywgdGl0bGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnRoYXdIZWlnaHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclRvb2xiYXJzID0gZnVuY3Rpb24gKHZpZXdTcGVjLCBkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB0aXRsZSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlckxheW91dCA9IHRoaXMub3B0KCdoZWFkZXInKTtcbiAgICAgICAgICAgIHZhciBmb290ZXJMYXlvdXQgPSB0aGlzLm9wdCgnZm9vdGVyJyk7XG4gICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcbiAgICAgICAgICAgIHZhciB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3cpO1xuICAgICAgICAgICAgdmFyIHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICB2YXIgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIHZhciB0b29sYmFyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICAgICAgICAgIGlzUHJldkVuYWJsZWQ6IHByZXZJbmZvLmlzVmFsaWQsXG4gICAgICAgICAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IFRvb2xiYXIodGhpcy5jb250ZXh0LCAnZmMtaGVhZGVyLXRvb2xiYXInKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZFRvRWxlbWVudCh0aGlzLmVsLCB0aGlzLmhlYWRlci5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyLnJlY2VpdmVQcm9wcyhfX2Fzc2lnbih7IGxheW91dDogaGVhZGVyTGF5b3V0IH0sIHRvb2xiYXJQcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvb3RlckxheW91dCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb290ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb290ZXIgPSBuZXcgVG9vbGJhcih0aGlzLmNvbnRleHQsICdmYy1mb290ZXItdG9vbGJhcicpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQodGhpcy5lbCwgdGhpcy5mb290ZXIuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZvb3Rlci5yZWNlaXZlUHJvcHMoX19hc3NpZ24oeyBsYXlvdXQ6IGZvb3RlckxheW91dCB9LCB0b29sYmFyUHJvcHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb290ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9vdGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclZpZXcgPSBmdW5jdGlvbiAocHJvcHMsIHRpdGxlKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgICAgIHZhciB2aWV3U3BlYyA9IHByb3BzLnZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3IHx8IHZpZXcudmlld1NwZWMgIT09IHZpZXdTcGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLnZpZXcgPSBuZXcgdmlld1NwZWNbJ2NsYXNzJ10oe1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcjogdGhpcy5jYWxlbmRhcixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUVudjogdGhpcy5kYXRlRW52LFxuICAgICAgICAgICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdmlld1NwZWMub3B0aW9uc1xuICAgICAgICAgICAgICAgIH0sIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdGhpcy5jb250ZW50RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlldy5hZGRTY3JvbGwodmlldy5xdWVyeVNjcm9sbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcudGl0bGUgPSB0aXRsZTsgLy8gZm9yIHRoZSBBUElcbiAgICAgICAgICAgIHZhciB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VCdXNpbmVzc0hvdXJzKHZpZXdTcGVjLm9wdGlvbnMuYnVzaW5lc3NIb3VycyksXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSxcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoaXMuY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHRyYW5zZm9ybWVyc18xID0gdHJhbnNmb3JtZXJzOyBfaSA8IHRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgICAgICAgICBfX2Fzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHZpZXdTcGVjLCBwcm9wcywgdmlldykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5yZWNlaXZlUHJvcHModmlld1Byb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XG4gICAgICAgICAgICBpZiAoaXNSZXNpemUgPT09IHZvaWQgMCkgeyBpc1Jlc2l6ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuYWRkU2Nyb2xsKHZpZXcucXVlcnlTY3JvbGwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNSZXNpemUgfHwgdGhpcy5pc0hlaWdodEF1dG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUhlaWdodFZhcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcudXBkYXRlU2l6ZShpc1Jlc2l6ZSwgdGhpcy52aWV3SGVpZ2h0LCB0aGlzLmlzSGVpZ2h0QXV0byk7XG4gICAgICAgICAgICB2aWV3LnVwZGF0ZU5vd0luZGljYXRvcigpOyAvLyB3ZSBuZWVkIHRvIGd1YXJhbnRlZSB0aGlzIHdpbGwgcnVuIGFmdGVyIHVwZGF0ZVNpemVcbiAgICAgICAgICAgIHZpZXcucG9wU2Nyb2xsKGlzUmVzaXplKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLmNvbXB1dGVIZWlnaHRWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjsgLy8geXVjay4gbmVlZCB0byBoYW5kbGUgZHluYW1pYyBvcHRpb25zXG4gICAgICAgICAgICB2YXIgaGVpZ2h0SW5wdXQgPSBjYWxlbmRhci5vcHQoJ2hlaWdodCcpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHRJbnB1dCA9IGNhbGVuZGFyLm9wdCgnY29udGVudEhlaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5pc0hlaWdodEF1dG8gPSBoZWlnaHRJbnB1dCA9PT0gJ2F1dG8nIHx8IGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ2F1dG8nO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7IC8vIGV4aXN0cyBhbmQgbm90ICdhdXRvJ1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7IC8vIGV4aXN0cyBhbmQgbm90ICdhdXRvJ1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IGhlaWdodElucHV0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0SW5wdXQgPT09ICdwYXJlbnQnKSB7IC8vIHNldCB0byBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSB0aGlzLmVsLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuY29udGVudEVsLm9mZnNldFdpZHRoIC9cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY2FsZW5kYXIub3B0KCdhc3BlY3RSYXRpbycpLCAuNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUucXVlcnlUb29sYmFyc0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKHRoaXMuaGVhZGVyLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyh0aGlzLmZvb3Rlci5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBIZWlnaHQgXCJGcmVlemluZ1wiXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS5mcmVlemVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHRoaXMuZWwsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZWwub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS50aGF3SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZSh0aGlzLmVsLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2FsZW5kYXJDb21wb25lbnQ7XG4gICAgfShDb21wb25lbnQpKTtcbiAgICAvLyBUaXRsZSBhbmQgRGF0ZSBGb3JtYXR0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVUaXRsZShkYXRlUHJvZmlsZSwgdmlld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2VcbiAgICAgICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgY29tcHV0ZVRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSwgdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvciksIHsgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkgfSk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbiAgICAvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuICAgIGZ1bmN0aW9uIGNvbXB1dGVUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xuICAgICAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRheXMgPSBkaWZmV2hvbGVEYXlzKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgICAgICAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQbHVnaW5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnModGhlQ2xhc3Nlcykge1xuICAgICAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKHRoZUNsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoZUNsYXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSW50ZXJhY3Rpb247XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICBlbDogaW5wdXQuZWwsXG4gICAgICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICAgICAgX2Fbc2V0dGluZ3MuY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncyxcbiAgICAgICAgICAgIF9hO1xuICAgIH1cbiAgICAvLyBnbG9iYWwgc3RhdGVcbiAgICB2YXIgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0ge307XG5cbiAgICAvKlxuICAgIERldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuICAgICovXG4gICAgdmFyIEV2ZW50Q2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFdmVudENsaWNraW5nLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFdmVudENsaWNraW5nKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0NsaWNrID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCAnLmZjLWhhcy11cmwnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudENsaWNrJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbXBvbmVudC5jYWxlbmRhciwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogY29tcG9uZW50LnZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XG4gICAgICAgICAgICBfdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3Rvcihjb21wb25lbnQuZWwsICdjbGljaycsIGNvbXBvbmVudC5mZ1NlZ1NlbGVjdG9yICsgJywnICsgY29tcG9uZW50LmJnU2VnU2VsZWN0b3IsIF90aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXZlbnRDbGlja2luZztcbiAgICB9KEludGVyYWN0aW9uKSk7XG5cbiAgICAvKlxuICAgIFRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuICAgIGVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXG4gICAgKi9cbiAgICB2YXIgRXZlbnRIb3ZlcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEV2ZW50SG92ZXJpbmcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50SG92ZXJpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICAgICAgLy8gZm9yIHNpbXVsYXRpbmcgYW4gZXZlbnRNb3VzZUxlYXZlIHdoZW4gdGhlIGV2ZW50IGVsIGlzIGRlc3Ryb3llZCB3aGlsZSBtb3VzZSBpcyBvdmVyIGl0XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2VnTGVhdmUobnVsbCwgX3RoaXMuY3VycmVudFNlZ0VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2VnRW50ZXIgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIHNlZ0VsLmNsYXNzTGlzdC5hZGQoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycyA9IGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbXBvbmVudC5lbCwgY29tcG9uZW50LmZnU2VnU2VsZWN0b3IgKyAnLCcgKyBjb21wb25lbnQuYmdTZWdTZWxlY3RvciwgX3RoaXMuaGFuZGxlU2VnRW50ZXIsIF90aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jYWxlbmRhci5vbignZXZlbnRFbFJlbW92ZScsIF90aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5jYWxlbmRhci5vZmYoJ2V2ZW50RWxSZW1vdmUnLCB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudEhvdmVyaW5nLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoIWV2IHx8IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHVibGljbHlUcmlnZ2VyKHB1YmxpY0V2TmFtZSwgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKHRoaXMuY29tcG9uZW50LmNhbGVuZGFyLCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogY29tcG9uZW50LnZpZXdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRIb3ZlcmluZztcbiAgICB9KEludGVyYWN0aW9uKSk7XG5cbiAgICB2YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN0YW5kYXJkVGhlbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YW5kYXJkVGhlbWU7XG4gICAgfShUaGVtZSkpO1xuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gICAgICAgIHdpZGdldDogJ2ZjLXVudGhlbWVkJyxcbiAgICAgICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXG4gICAgICAgIHdpZGdldENvbnRlbnQ6ICdmYy13aWRnZXQtY29udGVudCcsXG4gICAgICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcbiAgICAgICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICAgICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXG4gICAgICAgIHBvcG92ZXJIZWFkZXI6ICdmYy13aWRnZXQtaGVhZGVyJyxcbiAgICAgICAgcG9wb3ZlckNvbnRlbnQ6ICdmYy13aWRnZXQtY29udGVudCcsXG4gICAgICAgIC8vIGRheSBncmlkXG4gICAgICAgIGhlYWRlclJvdzogJ2ZjLXdpZGdldC1oZWFkZXInLFxuICAgICAgICBkYXlSb3c6ICdmYy13aWRnZXQtY29udGVudCcsXG4gICAgICAgIC8vIGxpc3Qgdmlld1xuICAgICAgICBsaXN0VmlldzogJ2ZjLXdpZGdldC1jb250ZW50J1xuICAgIH07XG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcbiAgICBTdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcbiAgICAgICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgICAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgICAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgICAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnXG4gICAgfTtcbiAgICBTdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnO1xuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcbiAgICBTdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG4gICAgdmFyIENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxlbmRhcihlbCwgb3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVJhd0xvY2FsZXMgPSBtZW1vaXplKHBhcnNlUmF3TG9jYWxlcyk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52KTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaVNpbmdsZUJhc2UgPSBtZW1vaXplKHRoaXMuX2J1aWxkRXZlbnRVaVNpbmdsZUJhc2UpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFNlbGVjdGlvbkNvbmZpZyA9IG1lbW9pemUodGhpcy5fYnVpbGRTZWxlY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemVPdXRwdXQoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzT2JqZWN0c1NpbWlsYXIpO1xuICAgICAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pc1JlZHVjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBpc0Rpc3BsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZSAvLyBpbnN0YWxsZWQgaW4gRE9NPyBhY2NlcHRpbmcgcmVuZGVycz9cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXJlbmRlciA9IGZhbHNlOyAvLyBuZWVkcyBhIHJlbmRlcj9cbiAgICAgICAgICAgIHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTsgLy8gY3VycmVudGx5IGluIHRoZSBleGVjdXRlUmVuZGVyIGZ1bmN0aW9uP1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdQYXVzZURlcHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVpbGREZWxheWVkUmVyZW5kZXIgPSBtZW1vaXplKGJ1aWxkRGVsYXllZFJlcmVuZGVyKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJTaXppbmdUcmlnZ2VycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5pc1ZpZXdVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzRGF0ZXNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzRXZlbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcihvdmVycmlkZXMgfHwge30pO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5TeXN0ZW0gPSBuZXcgUGx1Z2luU3lzdGVtKCk7XG4gICAgICAgICAgICAvLyBvbmx5IGRvIG9uY2UuIGRvbid0IGRvIGluIGhhbmRsZU9wdGlvbnMuIGJlY2F1c2UgY2FuJ3QgcmVtb3ZlIHBsdWdpbnNcbiAgICAgICAgICAgIHRoaXMuYWRkUGx1Z2luSW5wdXRzKHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWQucGx1Z2lucyB8fCBbXSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9wdGlvbnModGhpcy5vcHRpb25zTWFuYWdlci5jb21wdXRlZCk7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignX2luaXQnKTsgLy8gZm9yIHRlc3RzXG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSB0aGlzLnBsdWdpblN5c3RlbS5ob29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKF90aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5hZGRQbHVnaW5JbnB1dHMgPSBmdW5jdGlvbiAocGx1Z2luSW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luRGVmcyA9IHJlZmluZVBsdWdpbkRlZnMocGx1Z2luSW5wdXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGx1Z2luRGVmc18xID0gcGx1Z2luRGVmczsgX2kgPCBwbHVnaW5EZWZzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbkRlZiA9IHBsdWdpbkRlZnNfMVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5TeXN0ZW0uYWRkKHBsdWdpbkRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYWxlbmRhci5wcm90b3R5cGUsIFwidmlld1wiLCB7XG4gICAgICAgICAgICAvLyBwdWJsaWMgQVBJXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC52aWV3IDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQdWJsaWMgQVBJIGZvciByZW5kZXJpbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmFibGVFdmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlcmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5kZXN0cm95KCk7IC8vIGRvbid0IG51bGwtb3V0LiBpbiBjYXNlIEFQSSBuZWVkcyBhY2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7IC8vIHVtbSA/Pz9cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jYWxlbmRhckludGVyYWN0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdfZGVzdHJveWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEhhbmRsZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gZXZlbnQgZGVsZWdhdGlvbiBmb3IgbmF2IGxpbmtzXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5hdkxpbmtMaXN0ZW5lciA9IGxpc3RlbkJ5U2VsZWN0b3IodGhpcy5lbCwgJ2NsaWNrJywgJ2FbZGF0YS1nb3RvXScsIGZ1bmN0aW9uIChldiwgYW5jaG9yRWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ290bycpO1xuICAgICAgICAgICAgICAgIGdvdG9PcHRpb25zID0gZ290b09wdGlvbnMgPyBKU09OLnBhcnNlKGdvdG9PcHRpb25zKSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZU1hcmtlciA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGdvdG9PcHRpb25zLmRhdGUpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3VHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgbGlrZSBcIm5hdkxpbmtEYXlDbGlja1wiLiBtaWdodCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXdPcHQoJ25hdkxpbmsnICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHZpZXdUeXBlKSArICdDbGljaycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbihkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0KCdoYW5kbGVXaW5kb3dSZXNpemUnKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gZGVib3VuY2UoLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLm9wdCgnd2luZG93UmVzaXplRGVsYXknKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5hdkxpbmtMaXN0ZW5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMud2luZG93UmVzaXplUHJveHkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy53aW5kb3dSZXNpemVQcm94eSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemVQcm94eSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIERpc3BhdGNoZXJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYnVpbGRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICAgIHZhciByYXdTb3VyY2VzID0gdGhpcy5vcHQoJ2V2ZW50U291cmNlcycpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHNpbmdsZVJhd1NvdXJjZSA9IHRoaXMub3B0KCdldmVudHMnKTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgICAgICAgICAgaWYgKHNpbmdsZVJhd1NvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChzaW5nbGVSYXdTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdTb3VyY2VzXzEgPSByYXdTb3VyY2VzOyBfaSA8IHJhd1NvdXJjZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF3U291cmNlID0gcmF3U291cmNlc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goeyB0eXBlOiAnSU5JVCcgfSk7IC8vIHBhc3MgaW4gc291cmNlcyBoZXJlP1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogc291cmNlcyB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IF90aGlzLm9wdCgnZGVmYXVsdFZpZXcnKSB8fCBfdGhpcy5wbHVnaW5TeXN0ZW0uaG9va3MuZGVmYXVsdFZpZXdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYnVpbGRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdMZXZlbDogMCxcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZUxvYWRpbmdMZXZlbDogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZTogdGhpcy5nZXRJbml0aWFsRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlczoge30sXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1JlZHVjaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlZHVjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmFjdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5yZWR1Y2UodGhpcy5zdGF0ZSwgdGhpcy5hY3Rpb25RdWV1ZS5zaGlmdCgpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVkdWNpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFN0YXRlLmxvYWRpbmdMZXZlbCAmJiBuZXdTdGF0ZS5sb2FkaW5nTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBbdHJ1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGF0ZS5sb2FkaW5nTGV2ZWwgJiYgIW5ld1N0YXRlLmxvYWRpbmdMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignbG9hZGluZycsIFtmYWxzZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50LnZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmV2ZW50U3RvcmUgIT09IG5ld1N0YXRlLmV2ZW50U3RvcmUgfHwgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0V2ZW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5kYXRlUHJvZmlsZSAhPT0gbmV3U3RhdGUuZGF0ZVByb2ZpbGUgfHwgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuZGF0ZVByb2ZpbGUgJiYgdmlldykgeyAvLyB3aHkgd291bGQgdmlldyBiZSBudWxsIT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXRlc0Rlc3Ryb3knLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogdmlldy5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEYXRlc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUudmlld1R5cGUgIT09IG5ld1N0YXRlLnZpZXdUeXBlIHx8IHRoaXMubmVlZHNGdWxsUmVyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLnZpZXdUeXBlICYmIHZpZXcpIHsgLy8gd2h5IHdvdWxkIHZpZXcgYmUgbnVsbCE/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1NrZWxldG9uRGVzdHJveScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiB2aWV3LmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ZpZXdVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBjYWxlbmRhcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZShzdGF0ZSwgYWN0aW9uLCBjYWxlbmRhcik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbmRlciBRdWV1ZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVxdWVzdFJlcmVuZGVyID0gZnVuY3Rpb24gKG5lZWRzRnVsbCkge1xuICAgICAgICAgICAgaWYgKG5lZWRzRnVsbCA9PT0gdm9pZCAwKSB7IG5lZWRzRnVsbCA9IGZhbHNlOyB9XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlciA9IHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgfHwgbmVlZHNGdWxsO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkUmVyZW5kZXIoKTsgLy8gd2lsbCBjYWxsIGEgZGVib3VuY2VkLXZlcnNpb24gb2YgdHJ5UmVyZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnRyeVJlcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50ICYmIC8vIG11c3QgYmUgYWNjZXB0aW5nIHJlbmRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVyZW5kZXIgJiYgLy8gaW5kaWNhdGVzIHRoYXQgYSByZXJlbmRlciB3YXMgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgIXRoaXMucmVuZGVyaW5nUGF1c2VEZXB0aCAmJiAvLyBub3QgcGF1c2VkXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNSZW5kZXJpbmcgLy8gbm90IGN1cnJlbnRseSBpbiB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYmF0Y2hSZW5kZXJpbmcgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdQYXVzZURlcHRoKys7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ1BhdXNlRGVwdGgtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW5kZXJpbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmV4ZWN1dGVSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmVlZHNGdWxsUmVyZW5kZXIgPSB0aGlzLm5lZWRzRnVsbFJlcmVuZGVyOyAvLyBzYXZlIGJlZm9yZSBjbGVhcmluZ1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlc2UgQkVGT1JFIHRoZSByZW5kZXIgc28gdGhhdCBuZXcgdmFsdWVzIHdpbGwgYWNjdW11bGF0ZSBkdXJpbmcgcmVuZGVyXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDb21wb25lbnQobmVlZHNGdWxsUmVyZW5kZXIpO1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZWQgYSByZXJlbmRlciByZXF1ZXN0IHdoaWxlIHJlbmRlcmluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZXJlbmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZFJlcmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIGRvbid0IGNhbGwgdGhpcyBkaXJlY3RseS4gdXNlIGV4ZWN1dGVSZW5kZXIgaW5zdGVhZFxuICAgICAgICAqL1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5lZWRzRnVsbCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIHZpZXdUeXBlID0gc3RhdGUudmlld1R5cGU7XG4gICAgICAgICAgICB2YXIgdmlld1NwZWMgPSB0aGlzLnZpZXdTcGVjc1t2aWV3VHlwZV07XG4gICAgICAgICAgICB2YXIgc2F2ZWRTY3JvbGwgPSAobmVlZHNGdWxsICYmIGNvbXBvbmVudCkgPyBjb21wb25lbnQudmlldy5xdWVyeVNjcm9sbCgpIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdmlld1NwZWMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3IHR5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IHZhbGlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgc291cmNlcyBhcmUgc3RpbGwgbG9hZGluZyBhbmQgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGhhc24ndCBiZWVuIGVuYWJsZWQsXG4gICAgICAgICAgICAvLyBrZWVwIHJlbmRlcmluZyB0aGUgbGFzdCBmdWxseSBsb2FkZWQgc2V0IG9mIGV2ZW50c1xuICAgICAgICAgICAgdmFyIHJlbmRlcmFibGVFdmVudFN0b3JlID0gdGhpcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9XG4gICAgICAgICAgICAgICAgKHN0YXRlLmV2ZW50U291cmNlTG9hZGluZ0xldmVsICYmICF0aGlzLm9wdCgncHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZycpKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyYWJsZUV2ZW50U3RvcmUgOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlO1xuICAgICAgICAgICAgdmFyIGV2ZW50VWlTaW5nbGVCYXNlID0gdGhpcy5idWlsZEV2ZW50VWlTaW5nbGVCYXNlKHZpZXdTcGVjLm9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2Uoc3RhdGUuZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgICAgIHZhciBldmVudFVpQmFzZXMgPSB0aGlzLmV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgICAgICBpZiAobmVlZHNGdWxsIHx8ICFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5mcmVlemVIZWlnaHQoKTsgLy8gbmV4dCBjb21wb25lbnQgd2lsbCB1bmZyZWV6ZSBpdFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCA9IG5ldyBDYWxlbmRhckNvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkYXRlRW52OiB0aGlzLmRhdGVFbnYsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQucmVjZWl2ZVByb3BzKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyB2aWV3U3BlYzogdmlld1NwZWMsIGRhdGVQcm9maWxlOiBzdGF0ZS5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IHRoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JzW3ZpZXdUeXBlXSwgZXZlbnRTdG9yZTogcmVuZGVyYWJsZUV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogZXZlbnRVaUJhc2VzLCBkYXRlU2VsZWN0aW9uOiBzdGF0ZS5kYXRlU2VsZWN0aW9uLCBldmVudFNlbGVjdGlvbjogc3RhdGUuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogc3RhdGUuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogc3RhdGUuZXZlbnRSZXNpemUgfSkpO1xuICAgICAgICAgICAgaWYgKHNhdmVkU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnZpZXcuYXBwbHlTY3JvbGwoc2F2ZWRTY3JvbGwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVmlld1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1NrZWxldG9uUmVuZGVyJywgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb21wb25lbnQudmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBjb21wb25lbnQudmlldy5lbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RhdGVzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEYXRlc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF0ZXNSZW5kZXInLCBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbXBvbmVudC52aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGNvbXBvbmVudC52aWV3LmVsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbnRzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFdmVudHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VBZnRlclNpemluZ1RyaWdnZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE9wdGlvbnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLypcbiAgICAgICAgTm90IG1lYW50IGZvciBwdWJsaWMgQVBJXG4gICAgICAgICovXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZXNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjaGFuZ2VIYW5kbGVycyA9IHRoaXMucGx1Z2luU3lzdGVtLmhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICAgICAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcztcbiAgICAgICAgICAgIHZhciBvbGROb3JtYWxPcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgbm9ybWFsT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIHNwZWNpYWxPcHRpb25zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gb2xkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlSGFuZGxlcnNbbmFtZV8xXSkge1xuICAgICAgICAgICAgICAgICAgICBvbGROb3JtYWxPcHRpb25zW25hbWVfMV0gPSBvbGRPcHRpb25zW25hbWVfMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlSGFuZGxlcnNbbmFtZV8yXSkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsT3B0aW9uc1tuYW1lXzJdID0gb3B0aW9uc1tuYW1lXzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsT3B0aW9uc1tuYW1lXzJdID0gb3B0aW9uc1tuYW1lXzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChhbnlLZXlzUmVtb3ZlZChvbGROb3JtYWxPcHRpb25zLCBub3JtYWxPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzT3B0aW9ucyhvcHRpb25zLCAncmVzZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NPcHRpb25zKGNvbXB1dGVDaGFuZ2VkUHJvcHMob2xkTm9ybWFsT3B0aW9ucywgbm9ybWFsT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBvcHRpb25zIGxhc3RcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gc3BlY2lhbE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbbmFtZV8zXShzcGVjaWFsT3B0aW9uc1tuYW1lXzNdLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIE5vdCBtZWFudCBmb3IgcHVibGljIEFQSS4gV29uJ3QgZ2l2ZSB0aGUgc2FtZSBwcmVjZWRlbmNlIHRoYXQgc2V0T3B0aW9uIGRvZXNcbiAgICAgICAgKi9cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjaGFuZ2VIYW5kbGVycyA9IHRoaXMucGx1Z2luU3lzdGVtLmhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICAgICAgdmFyIG5vcm1hbE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzcGVjaWFsT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV80IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlSGFuZGxlcnNbbmFtZV80XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsT3B0aW9uc1tuYW1lXzRdID0gb3B0aW9uc1tuYW1lXzRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsT3B0aW9uc1tuYW1lXzRdID0gb3B0aW9uc1tuYW1lXzRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NPcHRpb25zKG5vcm1hbE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIG9wdGlvbnMgbGFzdFxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfNSBpbiBzcGVjaWFsT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tuYW1lXzVdKHNwZWNpYWxPcHRpb25zW25hbWVfNV0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIG1vZGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb2xkRGF0ZUVudiA9IHRoaXMuZGF0ZUVudjsgLy8gZG8gdGhpcyBiZWZvcmUgaGFuZGxlT3B0aW9uc1xuICAgICAgICAgICAgdmFyIGlzVGltZVpvbmVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzU2l6ZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYW55RGlmZmljdWx0T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV82IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oaGVpZ2h0fGNvbnRlbnRIZWlnaHR8YXNwZWN0UmF0aW8pJC8udGVzdChuYW1lXzYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2l6ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL14oZGVmYXVsdERhdGV8ZGVmYXVsdFZpZXcpJC8udGVzdChuYW1lXzYpKSA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFueURpZmZpY3VsdE9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZV82ID09PSAndGltZVpvbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVab25lRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICAgICAgICBhbnlEaWZmaWN1bHRPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnJlc2V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGREeW5hbWljKG9wdGlvbnMpOyAvLyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGQob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW55RGlmZmljdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3B0aW9ucyh0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkKTsgLy8gb25seSBmb3IgXCJkaWZmaWN1bHRcIiBvcHRpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVab25lRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1RJTUVaT05FJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREYXRlRW52OiBvbGREYXRlRW52XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBIQUNLXG4gICAgICAgICAgICAgICAgICAgIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyB0aGlzLnJlcXVlc3RSZXJlbmRlcih0cnVlKVxuICAgICAgICAgICAgICAgICAgICBidXQgcmVjb21wdXRlcyB0aGUgc3RhdGUncyBkYXRlUHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogX3RoaXMuc3RhdGUudmlld1R5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTaXplRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc09wdGlvbnMoKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksICdkeW5hbWljJyk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWRbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWRbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS52aWV3T3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdPcHRzKClbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS52aWV3T3B0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdTcGVjc1t0aGlzLnN0YXRlLnZpZXdUeXBlXS5vcHRpb25zO1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICByZWJ1aWxkcyB0aGluZ3MgYmFzZWQgb2ZmIG9mIGEgY29tcGxldGUgc2V0IG9mIHJlZmluZWQgb3B0aW9uc1xuICAgICAgICAqL1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuaGFuZGxlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBsdWdpbkhvb2tzID0gdGhpcy5wbHVnaW5TeXN0ZW0uaG9va3M7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ob3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkUmVyZW5kZXIgPSB0aGlzLmJ1aWxkRGVsYXllZFJlcmVuZGVyKG9wdGlvbnMucmVyZW5kZXJEZWxheSk7XG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhpcy5idWlsZFRoZW1lKG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IHRoaXMucGFyc2VSYXdMb2NhbGVzKG9wdGlvbnMubG9jYWxlcyk7XG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGUubWFwO1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMuYnVpbGRMb2NhbGUob3B0aW9ucy5sb2NhbGUgfHwgYXZhaWxhYmxlLmRlZmF1bHRDb2RlLCBhdmFpbGFibGUubWFwKTtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KGxvY2FsZSwgb3B0aW9ucy50aW1lWm9uZSwgcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLCBvcHRpb25zLmZpcnN0RGF5LCBvcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbiwgb3B0aW9ucy53ZWVrTGFiZWwsIHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcik7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbmZpZyA9IHRoaXMuYnVpbGRTZWxlY3Rpb25Db25maWcob3B0aW9ucyk7IC8vIG5lZWRzIGRhdGVFbnYuIGRvIGFmdGVyIDooXG4gICAgICAgICAgICAvLyBpbmVmZmVjaWVudCB0byBkbyBldmVyeSB0aW1lP1xuICAgICAgICAgICAgdGhpcy52aWV3U3BlY3MgPSBidWlsZFZpZXdTcGVjcyhwbHVnaW5Ib29rcy52aWV3cywgdGhpcy5vcHRpb25zTWFuYWdlcik7XG4gICAgICAgICAgICAvLyBpbmVmZmVjaWVudCB0byBkbyBldmVyeSB0aW1lP1xuICAgICAgICAgICAgdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvcnMgPSBtYXBIYXNoKHRoaXMudmlld1NwZWNzLCBmdW5jdGlvbiAodmlld1NwZWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZpZXdTcGVjLmNsYXNzLnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHZpZXdTcGVjLCBfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEF2YWlsYWJsZUxvY2FsZUNvZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5fYnVpbGRTZWxlY3Rpb25Db25maWcgPSBmdW5jdGlvbiAocmF3T3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NTY29wZWRVaVByb3BzKCdzZWxlY3QnLCByYXdPcHRzLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLl9idWlsZEV2ZW50VWlTaW5nbGVCYXNlID0gZnVuY3Rpb24gKHJhd09wdHMpIHtcbiAgICAgICAgICAgIGlmIChyYXdPcHRzLmVkaXRhYmxlKSB7IC8vIHNvICdlZGl0YWJsZScgYWZmZWN0ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgcmF3T3B0cyA9IF9fYXNzaWduKHt9LCByYXdPcHRzLCB7IGV2ZW50RWRpdGFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1Njb3BlZFVpUHJvcHMoJ2V2ZW50JywgcmF3T3B0cywgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hhbmRsZXJzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHQobmFtZSk7IC8vIGhhbmRsZXIgc3BlY2lmaWVkIGluIG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1YmxpY2x5VHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgb3B0SGFuZGxlciA9IHRoaXMub3B0KG5hbWUpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyV2l0aChuYW1lLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcHRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdEhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXJBZnRlclNpemluZyA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXJTaXppbmdUcmlnZ2VycyA9IHRoaXMuYWZ0ZXJTaXppbmdUcmlnZ2VycztcbiAgICAgICAgICAgIChhZnRlclNpemluZ1RyaWdnZXJzW25hbWVdIHx8IChhZnRlclNpemluZ1RyaWdnZXJzW25hbWVdID0gW10pKS5wdXNoKGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVsZWFzZUFmdGVyU2l6aW5nVHJpZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXJTaXppbmdUcmlnZ2VycyA9IHRoaXMuYWZ0ZXJTaXppbmdUcmlnZ2VycztcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfNyBpbiBhZnRlclNpemluZ1RyaWdnZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGFmdGVyU2l6aW5nVHJpZ2dlcnNbbmFtZV83XTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKG5hbWVfNywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZnRlclNpemluZ1RyaWdnZXJzID0ge307XG4gICAgICAgIH07XG4gICAgICAgIC8vIFZpZXdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmlzVmFsaWRWaWV3VHlwZSA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy52aWV3U3BlY3Nbdmlld1R5cGVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiAodmlld1R5cGUsIGRhdGVPclJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZU1hcmtlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGREeW5hbWljKHsgdmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZSB9KTsgLy8gd2lsbCBub3QgcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcHRpb25zKHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWQpOyAvLyAuLi5idXQgeXVja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYSBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIgPSB0aGlzLmRhdGVFbnYuY3JlYXRlTWFya2VyKGRhdGVPclJhbmdlKTsgLy8ganVzdCBsaWtlIGdvdG9EYXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgICAgIC8vIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24gKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3BlYztcbiAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgICAgIHNwZWMgPSB0aGlzLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlOiBzcGVjLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVNYXJrZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0RBVEUnLFxuICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cbiAgICAgICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciB2aWV3VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgICAgICAvLyBwdXQgdmlld3MgdGhhdCBoYXZlIGJ1dHRvbnMgZmlyc3QuIHRoZXJlIHdpbGwgYmUgZHVwbGljYXRlcywgYnV0IG9oXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmhlYWRlcikge1xuICAgICAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoLmFwcGx5KHZpZXdUeXBlcywgY29tcG9uZW50LmhlYWRlci52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgdmlld1R5cGVzLnB1c2guYXBwbHkodmlld1R5cGVzLCBjb21wb25lbnQuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgdmlld1R5cGUgaW4gdGhpcy52aWV3U3BlY3MpIHtcbiAgICAgICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEN1cnJlbnQgRGF0ZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdERhdGVJbnB1dCA9IHRoaXMub3B0KCdkZWZhdWx0RGF0ZScpO1xuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgICAgICAgICBpZiAoZGVmYXVsdERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGVmYXVsdERhdGVJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHRoaXMuZGF0ZUVudi5hZGRZZWFycyh0aGlzLnN0YXRlLmN1cnJlbnREYXRlLCAtMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUubmV4dFllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHRoaXMuZGF0ZUVudi5hZGRZZWFycyh0aGlzLnN0YXRlLmN1cnJlbnREYXRlLCAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogdGhpcy5nZXROb3coKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5nb3RvRGF0ZSA9IGZ1bmN0aW9uICh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9EQVRFJyxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiB0aGlzLmRhdGVFbnYuY3JlYXRlTWFya2VyKHpvbmVkRGF0ZUlucHV0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfREFURScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHRoaXMuZGF0ZUVudi5hZGQodGhpcy5zdGF0ZS5jdXJyZW50RGF0ZSwgZGVsdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBleHRlcm5hbCBBUElcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24gKGQsIGZvcm1hdHRlcikge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZDAsIGQxLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzLCB0aGlzLm9wdCgnZGVmYXVsdFJhbmdlU2VwYXJhdG9yJykpLCBzZXR0aW5ncyk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JtYXRJc28gPSBmdW5jdGlvbiAoZCwgb21pdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5kYXRlRW52O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQpLCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS53aW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hhbmRsaW5nV2luZG93UmVzaXplICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgJiYgLy8gd2h5P1xuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93IC8vIG5vdCBhIGpxdWkgcmVzaXplIGV2ZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGFuZGxpbmdXaW5kb3dSZXNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd3aW5kb3dSZXNpemUnLCBbdGhpcy52aWV3XSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0hhbmRsaW5nV2luZG93UmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7IC8vIHdoZW4/XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQudXBkYXRlU2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpO1xuICAgICAgICAgICAgdmFyIERFRkFVTFRfSU5URVJBQ1RJT05TID0gW1xuICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXG4gICAgICAgICAgICAgICAgRXZlbnRIb3ZlcmluZ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wbHVnaW5TeXN0ZW0uaG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKGZ1bmN0aW9uIChpbnRlcmFjdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gICAgICAgIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbnB1dDtcbiAgICAgICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCB0aGlzLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSAvLyBUT0RPOiBjYWNoZSB0aGlzP1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJEYXRlVW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnRyaWdnZXJEYXRlU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdGlvbiwgcGV2KSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5idWlsZERhdGVTcGFuQXBpKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBhcmcuanNFdmVudCA9IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsO1xuICAgICAgICAgICAgYXJnLnZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignc2VsZWN0JywgW2FyZ10pO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudHJpZ2dlckRhdGVVbnNlbGVjdCA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLnZpZXdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogcmVjZWl2ZSBwZXY/XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS50cmlnZ2VyRGF0ZUNsaWNrID0gZnVuY3Rpb24gKGRhdGVTcGFuLCBkYXlFbCwgdmlldywgZXYpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLmJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGFyZy5kYXlFbCA9IGRheUVsO1xuICAgICAgICAgICAgYXJnLmpzRXZlbnQgPSBldjtcbiAgICAgICAgICAgIGFyZy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXRlQ2xpY2snLCBbYXJnXSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5idWlsZERhdGVQb2ludEFwaSA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5wbHVnaW5TeXN0ZW0uaG9va3MuZGF0ZVBvaW50VHJhbnNmb3JtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIF9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fYXNzaWduKHByb3BzLCBidWlsZERhdGVQb2ludEFwaShkYXRlU3BhbiwgdGhpcy5kYXRlRW52KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5idWlsZERhdGVTcGFuQXBpID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnBsdWdpblN5c3RlbS5ob29rcy5kYXRlU3BhblRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBfX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCB0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2Fzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgdGhpcy5kYXRlRW52KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIERhdGUgVXRpbHNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUmV0dXJucyBhIERhdGVNYXJrZXIgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvblxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0Tm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMub3B0KCdub3cnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbm93ID0gbm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm93ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LmNyZWF0ZU5vd01hcmtlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXZlbnQtRGF0ZSBVdGlsaXRpZXNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuICAgICAgICAvLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZnVuY3Rpb24gKGFsbERheSwgbWFya2VyKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gbWFya2VyO1xuICAgICAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmRhdGVFbnYuYWRkKGVuZCwgdGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmRhdGVFbnYuYWRkKGVuZCwgdGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEFwaSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRJbnB1dC5faW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pIC8vIFRPRE86IGJldHRlciB1dGlsIGZvciB0d28gYXJncz9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZUlkO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VJZCA9IHNvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBhbiBldmVudCBzb3VyY2Ugd2l0aCBJRCBcIicgKyBzb3VyY2VJbnB1dCArICdcIicpOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQgPSBzb3VyY2VBcGkuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBwYXJzZUV2ZW50KGV2ZW50SW5wdXQsIHNvdXJjZUlkLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkodGhpcywgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLmV2ZW50U3RvcmUsIGRlZnMgPSBfYS5kZWZzLCBpbnN0YW5jZXMgPSBfYS5pbnN0YW5jZXM7XG4gICAgICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50QXBpKHRoaXMsIGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGVmSWQgPT09IGRlZi5kZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50QXBpKHRoaXMsIGRlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZS5ldmVudFN0b3JlLCBkZWZzID0gX2EuZGVmcywgaW5zdGFuY2VzID0gX2EuaW5zdGFuY2VzO1xuICAgICAgICAgICAgdmFyIGV2ZW50QXBpcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50QXBpKHRoaXMsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudEFwaXM7XG4gICAgICAgIH07XG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRTJyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRVNFVF9FVkVOVFMnIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VIYXNoID0gdGhpcy5zdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgICAgICB2YXIgc291cmNlQXBpcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICAgICAgc291cmNlQXBpcy5wdXNoKG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlQXBpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSB0aGlzLnN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgICAgIGlkID0gU3RyaW5nKGlkKTtcbiAgICAgICAgICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkodGhpcywgc291cmNlSGFzaFtzb3VyY2VJZF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlQXBpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VJbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogW2V2ZW50U291cmNlXSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHRoaXMsIGV2ZW50U291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVmZXRjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNjcm9sbFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuc2Nyb2xsVG9UaW1lID0gZnVuY3Rpb24gKHRpbWVJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC52aWV3LnNjcm9sbFRvVGltZSh0aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyO1xuICAgIH0oKSk7XG4gICAgRW1pdHRlck1peGluLm1peEludG8oQ2FsZW5kYXIpO1xuICAgIC8vIGZvciBtZW1vaXplcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZUVudihsb2NhbGUsIHRpbWVab25lLCBuYW1lZFRpbWVab25lSW1wbCwgZmlyc3REYXksIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgd2Vla0xhYmVsLCBjbWRGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgICAgICB0aW1lWm9uZTogdGltZVpvbmUsXG4gICAgICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogbmFtZWRUaW1lWm9uZUltcGwsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgICAgICAgICAgZmlyc3REYXk6IGZpcnN0RGF5LFxuICAgICAgICAgICAgd2Vla0xhYmVsOiB3ZWVrTGFiZWwsXG4gICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IGNtZEZvcm1hdHRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRUaGVtZShjYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoZW1lQ2xhc3MgPSB0aGlzLnBsdWdpblN5c3RlbS5ob29rcy50aGVtZUNsYXNzZXNbY2FsZW5kYXJPcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgICAgICByZXR1cm4gbmV3IHRoZW1lQ2xhc3MoY2FsZW5kYXJPcHRpb25zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGREZWxheWVkUmVyZW5kZXIod2FpdCkge1xuICAgICAgICB2YXIgZnVuYyA9IHRoaXMudHJ5UmVyZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHdhaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZnVuYyA9IGRlYm91bmNlKGZ1bmMsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZS51aTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgICAgICB2YXIgZXZlbnRVaUJhc2VzID0geyAnJzogZXZlbnRVaVNpbmdsZUJhc2UgfTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYuc291cmNlSWQgJiYgZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbiAgICB9XG5cbiAgICB2YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFZpZXcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXcoY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy12aWV3IGZjLScgKyB2aWV3U3BlYy50eXBlICsgJy12aWV3JyB9KSwgdHJ1ZSAvLyBpc1ZpZXcgKEhBQ0spXG4gICAgICAgICAgICApIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXRlc01lbSA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyRGF0ZXNXcmFwLCBfdGhpcy51bnJlbmRlckRhdGVzV3JhcCk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzLCBfdGhpcy51bnJlbmRlckJ1c2luZXNzSG91cnMsIFtfdGhpcy5yZW5kZXJEYXRlc01lbV0pO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbk1lbSA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbldyYXAsIF90aGlzLnVucmVuZGVyRGF0ZVNlbGVjdGlvbldyYXAsIFtfdGhpcy5yZW5kZXJEYXRlc01lbV0pO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnRzTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJFdmVudHMsIF90aGlzLnVucmVuZGVyRXZlbnRzLCBbX3RoaXMucmVuZGVyRGF0ZXNNZW1dKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50U2VsZWN0aW9uTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbldyYXAsIF90aGlzLnVucmVuZGVyRXZlbnRTZWxlY3Rpb25XcmFwLCBbX3RoaXMucmVuZGVyRXZlbnRzTWVtXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudERyYWdNZW0gPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnJlbmRlckV2ZW50RHJhZ1dyYXAsIF90aGlzLnVucmVuZGVyRXZlbnREcmFnV3JhcCwgW190aGlzLnJlbmRlckRhdGVzTWVtXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFJlc2l6ZU1lbSA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyRXZlbnRSZXNpemVXcmFwLCBfdGhpcy51bnJlbmRlckV2ZW50UmVzaXplV3JhcCwgW190aGlzLnJlbmRlckRhdGVzTWVtXSk7XG4gICAgICAgICAgICBfdGhpcy52aWV3U3BlYyA9IHZpZXdTcGVjO1xuICAgICAgICAgICAgX3RoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBkYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSB2aWV3U3BlYy50eXBlO1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gcGFyc2VGaWVsZFNwZWNzKF90aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcbiAgICAgICAgICAgIF90aGlzLm5leHREYXlUaHJlc2hvbGQgPSBjcmVhdGVEdXJhdGlvbihfdGhpcy5vcHQoJ25leHREYXlUaHJlc2hvbGQnKSk7XG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChfdGhpcy5lbCk7XG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXcucHJvdG90eXBlLCBcImFjdGl2ZVN0YXJ0XCIsIHtcbiAgICAgICAgICAgIC8vIERhdGUgU2V0dGluZy9VbnNldHRpbmdcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlldy5wcm90b3R5cGUsIFwiYWN0aXZlRW5kXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlldy5wcm90b3R5cGUsIFwiY3VycmVudFN0YXJ0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlldy5wcm90b3R5cGUsIFwiY3VycmVudEVuZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnByb3BzLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEdlbmVyYWwgUmVuZGVyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRlc01lbShwcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckJ1c2luZXNzSG91cnNNZW0ocHJvcHMuYnVzaW5lc3NIb3Vycyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGVTZWxlY3Rpb25NZW0ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50c01lbShwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRTZWxlY3Rpb25NZW0ocHJvcHMuZXZlbnRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudERyYWdNZW0ocHJvcHMuZXZlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRSZXNpemVNZW0ocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGVzTWVtLnVucmVuZGVyKCk7IC8vIHNob3VsZCB1bnJlbmRlciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSB8fCBjYWxlbmRhci5pc1ZpZXdVcGRhdGVkIHx8IGNhbGVuZGFyLmlzRGF0ZXNVcGRhdGVkIHx8IGNhbGVuZGFyLmlzRXZlbnRzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHNvcnQgb2YgdGhlIGNhdGNoLWFsbCBzaXppbmdcbiAgICAgICAgICAgICAgICAvLyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNhdXNlIGRpbWVuc2lvbiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCYXNlU2l6ZShpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUudXBkYXRlQmFzZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xuICAgICAgICB9O1xuICAgICAgICAvLyBEYXRlIFJlbmRlcmluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlc1dyYXAgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZXMoZGF0ZVByb2ZpbGUpO1xuICAgICAgICAgICAgdGhpcy5hZGRTY3JvbGwoe1xuICAgICAgICAgICAgICAgIHRpbWVNczogY3JlYXRlRHVyYXRpb24odGhpcy5vcHQoJ3Njcm9sbFRpbWUnKSkubWlsbGlzZWNvbmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROb3dJbmRpY2F0b3IoZGF0ZVByb2ZpbGUpOyAvLyBzaG91bGRuJ3QgcmVuZGVyIHlldCBiZWNhdXNlIHVwZGF0ZVNpemUgd2lsbCBiZSBjYWxsZWQgc29vblxuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckRhdGVzV3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5vd0luZGljYXRvcigpO1xuICAgICAgICAgICAgdGhpcy51bnJlbmRlckRhdGVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7IH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8vIEJ1c2luZXNzIEhvdXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VycykgeyB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8vIERhdGUgU2VsZWN0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckRhdGVTZWxlY3Rpb25XcmFwID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckRhdGVTZWxlY3Rpb25XcmFwID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZW5kZXJEYXRlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckRhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7IH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgfTtcbiAgICAgICAgLy8gRXZlbnQgUmVuZGVyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFN0b3JlKSB7IH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvLyB1dGlsIGZvciBzdWJjbGFzc2VzXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnNsaWNlRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGFsbERheSkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHJldHVybiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBwcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgYWxsRGF5ID8gdGhpcy5uZXh0RGF5VGhyZXNob2xkIDogbnVsbCkuZmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV2ZW50IFNlbGVjdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJFdmVudFNlbGVjdGlvbldyYXAgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50U2VsZWN0aW9uKGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50U2VsZWN0aW9uV3JhcCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZW5kZXJFdmVudFNlbGVjdGlvbihpbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUucmVuZGVyRXZlbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkgeyB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHsgfTtcbiAgICAgICAgLy8gRXZlbnQgRHJhZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJFdmVudERyYWdXcmFwID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50RHJhZyhzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRXZlbnREcmFnV3JhcCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnJlbmRlckV2ZW50RHJhZyhzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50RHJhZyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50RHJhZyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyB9O1xuICAgICAgICAvLyBFdmVudCBSZXNpemVcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgVmlldy5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemVXcmFwID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50UmVzaXplKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZVdyYXAgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZW5kZXJFdmVudFJlc2l6ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7IH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoc3RhdGUpIHsgfTtcbiAgICAgICAgLyogTm93IEluZGljYXRvclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICAvLyBJbW1lZGlhdGVseSByZW5kZXIgdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYW5kIGJlZ2lucyByZS1yZW5kZXJpbmcgaXQgYXQgYW4gaW50ZXJ2YWwsXG4gICAgICAgIC8vIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KCkuXG4gICAgICAgIC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cbiAgICAgICAgVmlldy5wcm90b3R5cGUuc3RhcnROb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciB1bml0O1xuICAgICAgICAgICAgdmFyIHVwZGF0ZTtcbiAgICAgICAgICAgIHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0KCdub3dJbmRpY2F0b3InKSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoZGF0ZVByb2ZpbGUpO1xuICAgICAgICAgICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRoaXMudXBkYXRlTm93SW5kaWNhdG9yLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSB0aGlzLmNhbGVuZGFyLmdldE5vdygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKHRoaXMuaW5pdGlhbE5vd0RhdGUsIHVuaXQpLCBjcmVhdGVEdXJhdGlvbigxLCB1bml0KSkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93RGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGFsd2F5cyB1c2Ugc2V0VGltZW91dCwgd2FpdGluZyB1bnRpbCBzdGFydCBvZiBuZXh0IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMTAwMDsgLy8gZXZlcnkgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSA9IDEwMDAgKiA2MDsgLy8gb3RoZXJ3aXNlLCBldmVyeSBtaW51dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGUsIGRlbGF5KTsgLy8gdXBkYXRlIGV2ZXJ5IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIHdpbGwgYmUgaW5pdGlhdGVkIGluIHVwZGF0ZVNpemVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVyZW5kZXJzIHRoZSBub3cgaW5kaWNhdG9yLCBjb21wdXRpbmcgdGhlIG5ldyBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgcGFzc2VkXG4gICAgICAgIC8vIHNpbmNlIHRoZSBpbml0aWFsIGdldE5vdyBjYWxsLlxuICAgICAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRlUHJvZmlsZSAmJiAvLyBhIHdheSB0byBkZXRlcm1pbmUgaWYgZGF0ZXMgd2VyZSByZW5kZXJlZCB5ZXRcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlIC8vIGFjdGl2YXRlZCBiZWZvcmU/XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7IC8vIHdvbid0IHVucmVuZGVyIGlmIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IoYWRkTXModGhpcy5pbml0aWFsTm93RGF0ZSwgbmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBJbW1lZGlhdGVseSB1bnJlbmRlcnMgdGhlIHZpZXcncyBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBzdG9wcyBhbnkgcmUtcmVuZGVyaW5nIHRpbWVycy5cbiAgICAgICAgLy8gV29uJ3QgY2F1c2Ugc2lkZSBlZmZlY3RzIGlmIGluZGljYXRvciBpc24ndCByZW5kZXJlZC5cbiAgICAgICAgVmlldy5wcm90b3R5cGUuc3RvcE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVuZGVycyBhIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYXQgdGhlIGdpdmVuIGRhdGV0aW1lXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAvLyBTVUJDTEFTU0VTIE1VU1QgUEFTUyBUTyBDSElMRFJFTiFcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVW5kb2VzIHRoZSByZW5kZXJpbmcgYWN0aW9ucyBmcm9tIHJlbmRlck5vd0luZGljYXRvclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNVQkNMQVNTRVMgTVVTVCBQQVNTIFRPIENISUxEUkVOIVxuICAgICAgICB9O1xuICAgICAgICAvKiBTY3JvbGxlclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5hZGRTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVkU2Nyb2xsID0gdGhpcy5xdWV1ZWRTY3JvbGwgfHwgKHRoaXMucXVldWVkU2Nyb2xsID0ge30pO1xuICAgICAgICAgICAgX19hc3NpZ24ocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5wb3BTY3JvbGwgPSBmdW5jdGlvbiAoaXNSZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlRdWV1ZWRTY3JvbGwoaXNSZXNpemUpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRTY3JvbGwgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5hcHBseVF1ZXVlZFNjcm9sbCA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVNjcm9sbCh0aGlzLnF1ZXVlZFNjcm9sbCB8fCB7fSwgaXNSZXNpemUpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3LnByb3RvdHlwZS5xdWVyeVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7IC8vIGRhdGVzIHJlbmRlcmVkIHlldD9cbiAgICAgICAgICAgICAgICBfX2Fzc2lnbihzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjcm9sbDtcbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUuYXBwbHlTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsLCBpc1Jlc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVNcyA9IHNjcm9sbC50aW1lTXM7XG4gICAgICAgICAgICBpZiAodGltZU1zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2Nyb2xsLnRpbWVNcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkgeyAvLyBkYXRlcyByZW5kZXJlZCB5ZXQ/XG4gICAgICAgICAgICAgICAgICAgIF9fYXNzaWduKHNjcm9sbCwgdGhpcy5jb21wdXRlRGF0ZVNjcm9sbCh0aW1lTXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkgeyAvLyBkYXRlcyByZW5kZXJlZCB5ZXQ/XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseURhdGVTY3JvbGwoc2Nyb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZURhdGVTY3JvbGwgPSBmdW5jdGlvbiAodGltZU1zKSB7XG4gICAgICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIFZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcbiAgICAgICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIEFQSVxuICAgICAgICBWaWV3LnByb3RvdHlwZS5zY3JvbGxUb1RpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVNjcm9sbCh7XG4gICAgICAgICAgICAgICAgdGltZU1zOiB0aW1lLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmlldztcbiAgICB9KERhdGVDb21wb25lbnQpKTtcbiAgICBFbWl0dGVyTWl4aW4ubWl4SW50byhWaWV3KTtcbiAgICBWaWV3LnByb3RvdHlwZS51c2VzTWluTWF4VGltZSA9IGZhbHNlO1xuICAgIFZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcblxuICAgIHZhciBGZ0V2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZnRXZlbnRSZW5kZXJlcihjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnNlZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaXNTaXplRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VVcGRhdGVkKCk7IC8vIGNhbGxlZCB0b28gZnJlcXVlbnRseSA6KFxuICAgICAgICAgICAgLy8gcmVuZGVyIGFuIGAuZWxgIG9uIGVhY2ggc2VnXG4gICAgICAgICAgICAvLyByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzLiBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuICAgICAgICAgICAgc2VncyA9IHRoaXMucmVuZGVyU2VnRWxzKHNlZ3MsIG1pcnJvckluZm8pO1xuICAgICAgICAgICAgdGhpcy5zZWdzID0gc2VncztcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2VncyhzZWdzLCBtaXJyb3JJbmZvKTtcbiAgICAgICAgICAgIHRoaXMuaXNTaXplRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnZpZXcudHJpZ2dlclJlbmRlcmVkU2Vncyh0aGlzLnNlZ3MsIEJvb2xlYW4obWlycm9ySW5mbykpO1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKF9zZWdzLCBtaXJyb3JJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudmlldy50cmlnZ2VyV2lsbFJlbW92ZVNlZ3ModGhpcy5zZWdzLCBCb29sZWFuKG1pcnJvckluZm8pKTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoU2Vncyh0aGlzLnNlZ3MpO1xuICAgICAgICAgICAgdGhpcy5zZWdzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJhbmdlVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZGlzcGxheUV2ZW50VGltZTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5RXZlbnRFbmQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50VGltZUZvcm1hdCA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCB0aGlzLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQoKSwgb3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IG9wdGlvbnMuZGlzcGxheUV2ZW50VGltZTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50VGltZSgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IG9wdGlvbnMuZGlzcGxheUV2ZW50RW5kO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50RW5kKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRUaW1lID0gZGlzcGxheUV2ZW50VGltZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUV2ZW50RW5kID0gZGlzcGxheUV2ZW50RW5kO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxuICAgICAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnRWxzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aCkgeyAvLyBkb24ndCBidWlsZCBhbiBlbXB0eSBodG1sIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBldmVudCBzZWdtZW50IEhUTUxcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyU2VnSHRtbChzZWdzW2ldLCBtaXJyb3JJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LiBBbiBlbCBtaWdodCBiZSBudWxsIGlmIHRoZSBldmVudFJlbmRlciBjYWxsYmFjayByZXR1cm5lZCBmYWxzZS5cbiAgICAgICAgICAgICAgICBodG1sVG9FbGVtZW50cyhodG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwgPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlZ3MgPSBmaWx0ZXJTZWdzVmlhRWxzKHRoaXMuY29udGV4dC52aWV3LCBzZWdzLCBCb29sZWFuKG1pcnJvckluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBHZW5lcmljIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdGhlIEhUTUwgY2xhc3NOYW1lcyBmb3IgYW4gZXZlbnQgc2VnbWVudCdzIGVsZW1lbnRcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdDbGFzc2VzID0gZnVuY3Rpb24gKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlLCBtaXJyb3JJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICAnZmMtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID8gJ2ZjLXN0YXJ0JyA6ICdmYy1ub3Qtc3RhcnQnLFxuICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA/ICdmYy1lbmQnIDogJ2ZjLW5vdC1lbmQnXG4gICAgICAgICAgICBdLmNvbmNhdChzZWcuZXZlbnRSYW5nZS51aS5jbGFzc05hbWVzKTtcbiAgICAgICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZHJhZ2dhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNSZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXJlc2l6YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pcnJvckluZm8pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLW1pcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChtaXJyb3JJbmZvLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWlycm9ySW5mby5pc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXppbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gYW4gZXZlbnQncyBlbGVtZW50LlxuICAgICAgICAvLyBgcmFuZ2VgIGNhbiBiZSB0aGUgRXZlbnQgb2JqZWN0IGl0c2VsZiwgb3Igc29tZXRoaW5nIHJhbmdlLWxpa2UsIHdpdGggYXQgbGVhc3QgYSBgc3RhcnRgLlxuICAgICAgICAvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGZvcm1hdHRlciB3aWxsIGRlZmF1bHQgdG8gdGhlIGV2ZW50VGltZUZvcm1hdCBzZXR0aW5nLFxuICAgICAgICAvLyBhbmQgZGlzcGxheUVuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGRpc3BsYXlFdmVudEVuZCBzZXR0aW5nLlxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRpbWVUZXh0ID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UsIGZvcm1hdHRlciwgZGlzcGxheUVuZCkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50UmFuZ2UuZGVmLCBpbnN0YW5jZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGltZVRleHQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGRlZi5oYXNFbmQgPyBpbnN0YW5jZS5yYW5nZS5lbmQgOiBudWxsLCBkZWYuYWxsRGF5LCBmb3JtYXR0ZXIsIGRpc3BsYXlFbmQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pO1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLl9nZXRUaW1lVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBhbGxEYXksIGZvcm1hdHRlciwgZGlzcGxheUVuZCwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmNvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlciA9IHRoaXMuZXZlbnRUaW1lRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3BsYXlFbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlFbmQgPSB0aGlzLmRpc3BsYXlFdmVudEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgJiYgIWFsbERheSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5RW5kICYmIGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogZm9yY2VkU3RhcnRUem9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgICAgICAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBldmVudCBza2luLXJlbGF0ZWQgQ1NTIHByb3BlcnRpZXNcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTa2luQ3NzID0gZnVuY3Rpb24gKHVpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3InOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogdWkudGV4dENvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnNvcnRFdmVudFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgdmFyIHNwZWNzID0gdGhpcy5jb250ZXh0LnZpZXcuZXZlbnRPcmRlclNwZWNzO1xuICAgICAgICAgICAgdmFyIG9ianMgPSBzZWdzLm1hcChidWlsZFNlZ0NvbXBhcmVPYmopO1xuICAgICAgICAgICAgb2Jqcy5zb3J0KGZ1bmN0aW9uIChvYmowLCBvYmoxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgc3BlY3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5fc2VnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZVNpemVzID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5pc1NpemVEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNlZ1NpemVzKHRoaXMuc2Vncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduU2l6ZXMgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSB8fCB0aGlzLmlzU2l6ZURpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25TZWdTaXplcyh0aGlzLnNlZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTaXplRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlU2VnU2l6ZXMgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNlZ1NpemVzID0gZnVuY3Rpb24gKHNlZ3MpIHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWFuaXB1bGF0aW9uIG9uIHJlbmRlcmVkIHNlZ3NcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5oaWRlQnlIYXNoID0gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIGlmIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2VnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc2hvd0J5SGFzaCA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICBpZiAoaGFzaCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnNlbGVjdEJ5SW5zdGFuY2VJZCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlICYmIGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCA9PT0gaW5zdGFuY2VJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwuY2xhc3NMaXN0LmFkZCgnZmMtc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnNlbGVjdEJ5SW5zdGFuY2VJZCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHsgLy8gbmVjZXNzYXJ5P1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGZ0V2ZW50UmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICAvLyByZXR1cm5zIGEgb2JqZWN0IHdpdGggYWxsIHByaW1pdGl2ZSBwcm9wcyB0aGF0IGNhbiBiZSBjb21wYXJlZFxuICAgIGZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQgPyByYW5nZS5zdGFydC52YWx1ZU9mKCkgOiAwOyAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igb3Blbi1yYW5nZSBldmVudHNcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwOyAvLyBcIlxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMsIGV2ZW50RGVmLCB7IGlkOiBldmVudERlZi5wdWJsaWNJZCwgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsIGR1cmF0aW9uOiBlbmQgLSBzdGFydCwgYWxsRGF5OiBOdW1iZXIoZXZlbnREZWYuYWxsRGF5KSwgX3NlZzogc2VnIC8vIGZvciBsYXRlciByZXRyaWV2YWxcbiAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZpbGxSZW5kZXJlcihjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxTZWdUYWcgPSAnZGl2JztcbiAgICAgICAgICAgIHRoaXMuZGlydHlTaXplRmxhZ3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsc0J5VHlwZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zZWdzQnlUeXBlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdzQnlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ3NCeVR5cGVbdHlwZV0gfHwgW107XG4gICAgICAgIH07XG4gICAgICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRTZWdzID0gdGhpcy5yZW5kZXJTZWdFbHModHlwZSwgc2Vncyk7IC8vIGFzc2lnbmVzIGAuZWxgIHRvIGVhY2ggc2VnLiByZXR1cm5zIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCBzZWdzXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWxzID0gdGhpcy5hdHRhY2hTZWdzKHR5cGUsIHJlbmRlcmVkU2Vncyk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyRWxzKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gKHRoaXMuY29udGFpbmVyRWxzQnlUeXBlW3R5cGVdIHx8ICh0aGlzLmNvbnRhaW5lckVsc0J5VHlwZVt0eXBlXSA9IFtdKSkpLnB1c2guYXBwbHkoX2EsIGNvbnRhaW5lckVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlZ3NCeVR5cGVbdHlwZV0gPSByZW5kZXJlZFNlZ3M7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2JnRXZlbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnZpZXcudHJpZ2dlclJlbmRlcmVkU2VncyhyZW5kZXJlZFNlZ3MsIGZhbHNlKTsgLy8gaXNNaXJyb3I9ZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHlTaXplRmxhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBVbnJlbmRlcnMgYSBzcGVjaWZpYyB0eXBlIG9mIGZpbGwgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2Vnc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgICAgIGlmIChzZWdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudmlldy50cmlnZ2VyV2lsbFJlbW92ZVNlZ3Moc2VncywgZmFsc2UpOyAvLyBpc01pcnJvcj1mYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaFNlZ3ModHlwZSwgc2Vncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBzZWdtZW50IEhUTUxcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyU2VnSHRtbCh0eXBlLCBzZWdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LlxuICAgICAgICAgICAgICAgIGh0bWxUb0VsZW1lbnRzKGh0bWwpLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBzZWdzID0gZmlsdGVyU2Vnc1ZpYUVscyh0aGlzLmNvbnRleHQudmlldywgc2VncywgZmFsc2UgLy8gaXNNaXJyb3IuIGJhY2tncm91bmQgZXZlbnRzIGNhbiBuZXZlciBiZSBtaXJyb3IgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBlbGVtZW50IHR5cGU/ICh3b3VsZCBiZSBiYWQgaWYgYSBub24tVEQgd2VyZSBpbnNlcnRlZCBpbnRvIGEgdGFibGUgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgc2VncyA9IHNlZ3MuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVzKHNlZy5lbCwgX3RoaXMuZmlsbFNlZ1RhZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdIdG1sID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xuICAgICAgICAgICAgdmFyIGNzcyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdoaWdobGlnaHQnICYmIHR5cGUgIT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBzZWcuZXZlbnRSYW5nZS51aS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdoaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuY29uY2F0KHNlZy5ldmVudFJhbmdlLnVpLmNsYXNzTmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtYmdldmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy0nICsgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLmZpbGxTZWdUYWcgK1xuICAgICAgICAgICAgICAgIChjbGFzc05hbWVzLmxlbmd0aCA/ICcgY2xhc3M9XCInICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyAnXCInIDogJycpICtcbiAgICAgICAgICAgICAgICAoY3NzID8gJyBzdHlsZT1cIicgKyBjc3NUb1N0cihjc3MpICsgJ1wiJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJz48LycgKyB0aGlzLmZpbGxTZWdUYWcgKyAnPic7XG4gICAgICAgIH07XG4gICAgICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoU2VncyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWxzID0gdGhpcy5jb250YWluZXJFbHNCeVR5cGVbdHlwZV07XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyRWxzKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxzLmZvckVhY2gocmVtb3ZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyRWxzQnlUeXBlW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTaXplcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLnNlZ3NCeVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5kaXJ0eVNpemVGbGFnc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVTZWdTaXplcyh0aGlzLnNlZ3NCeVR5cGVbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hc3NpZ25TaXplcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLnNlZ3NCeVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5kaXJ0eVNpemVGbGFnc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2lnblNlZ1NpemVzKHRoaXMuc2Vnc0J5VHlwZVt0eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eVNpemVGbGFncyA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTZWdTaXplcyA9IGZ1bmN0aW9uIChzZWdzKSB7XG4gICAgICAgIH07XG4gICAgICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduU2VnU2l6ZXMgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRmlsbFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgTmFtZWRUaW1lWm9uZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lTmFtZSkge1xuICAgICAgICAgICAgdGhpcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hbWVkVGltZVpvbmVJbXBsO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgIEFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxuICAgIERvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxuICAgIC0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuICAgIC0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXG5cbiAgICBzdWJjbGFzc2VzIG11c3QgZW1pdDpcbiAgICAtIHBvaW50ZXJkb3duXG4gICAgLSBkcmFnc3RhcnRcbiAgICAtIGRyYWdtb3ZlXG4gICAgLSBwb2ludGVydXBcbiAgICAtIGRyYWdlbmRcbiAgICAqL1xuICAgIHZhciBFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnREcmFnZ2luZyhlbCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXJNaXhpbigpO1xuICAgICAgICB9XG4gICAgICAgIEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfTtcbiAgICAgICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICAgICAgfTtcbiAgICAgICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgICAgICB9O1xuICAgICAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldEF1dG9TY3JvbGxFbmFibGVkID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbGVtZW50RHJhZ2dpbmc7XG4gICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZUlucHV0LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkgeyBzZXR0aW5ncyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEoc2V0dGluZ3MpO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKTtcbiAgICAgICAgdmFyIGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XG4gICAgICAgIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgc2V0dGluZ3MgLy8gbWl4dHVyZSBvZiBlbnYgYW5kIGZvcm1hdHRlciBzZXR0aW5nc1xuICAgICkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudiQxKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcgJiYgc2V0dGluZ3MgPyBzZXR0aW5ncyA6IHt9KTsgLy8gcGFzcyBpbiBpZiBub24tbnVsbCBvYmplY3RcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihzZXR0aW5ncywgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICAgICAgdmFyIGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpO1xuICAgICAgICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgICAgIGlzRW5kRXhjbHVzaXZlOiBzZXR0aW5ncy5pc0VuZEV4Y2x1c2l2ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZUVudiQxKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBidWlsZExvY2FsZShzZXR0aW5ncy5sb2NhbGUgfHwgJ2VuJywgcGFyc2VSYXdMb2NhbGVzKFtdKS5tYXApOyAvLyBUT0RPOiBkb24ndCBoYXJkY29kZSAnZW4nIGV2ZXJ5d2hlcmVcbiAgICAgICAgLy8gZW5zdXJlIHJlcXVpcmVkIHNldHRpbmdzXG4gICAgICAgIHNldHRpbmdzID0gX19hc3NpZ24oeyB0aW1lWm9uZTogZ2xvYmFsRGVmYXVsdHMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MsIHsgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUVudihzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgdmFyIERSQUdfTUVUQV9QUk9QUyA9IHtcbiAgICAgICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgICAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgICAgIHNvdXJjZUlkOiBTdHJpbmdcbiAgICB9O1xuICAgIHZhciBEUkFHX01FVEFfREVGQVVMVFMgPSB7XG4gICAgICAgIGNyZWF0ZTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VEcmFnTWV0YShyYXcpIHtcbiAgICAgICAgdmFyIGxlZnRvdmVyUHJvcHMgPSB7fTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9QUk9QUywgRFJBR19NRVRBX0RFRkFVTFRTLCBsZWZ0b3ZlclByb3BzKTtcbiAgICAgICAgcmVmaW5lZC5sZWZ0b3ZlclByb3BzID0gbGVmdG92ZXJQcm9wcztcbiAgICAgICAgcmV0dXJuIHJlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF5Q250KSB7XG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICAgICAgICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB3ZWVrZGF5OiAnc2hvcnQnIH07IC8vIFwiU2F0XCJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJywgb21pdENvbW1hczogdHJ1ZSB9OyAvLyBcIlNhdCAxMS8xMlwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB3ZWVrZGF5OiAnbG9uZycgfTsgLy8gXCJTYXR1cmRheVwiXG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRGF0ZUNlbGwoZGF0ZU1hcmtlciwgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBjb2xDbnQsIGNvbEhlYWRGb3JtYXQsIGNvbnRleHQsIGNvbHNwYW4sIG90aGVyQXR0cnMpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBjb250ZXh0LnZpZXcsIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIHRoZW1lID0gY29udGV4dC50aGVtZSwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZU1hcmtlcik7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXG4gICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJylcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGlubmVySHRtbDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbHVtbkhlYWRlckh0bWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlubmVySHRtbCA9IG9wdGlvbnMuY29sdW1uSGVhZGVySHRtbChkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuY29sdW1uSGVhZGVyVGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaW5uZXJIdG1sID0gaHRtbEVzY2FwZShvcHRpb25zLmNvbHVtbkhlYWRlclRleHQoZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlubmVySHRtbCA9IGh0bWxFc2NhcGUoZGF0ZUVudi5mb3JtYXQoZGF0ZU1hcmtlciwgY29sSGVhZEZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG9ubHkgb25lIHJvdyBvZiBkYXlzLCB0aGUgY2xhc3NOYW1lcyBvbiB0aGUgaGVhZGVyIGNhbiByZXByZXNlbnQgdGhlIHNwZWNpZmljIGRheXMgYmVuZWF0aFxuICAgICAgICBpZiAoZGF0ZXNSZXBEaXN0aW5jdERheXMpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmNvbmNhdChcbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIHRoZSBkYXktb2Ytd2VlayBjbGFzc1xuICAgICAgICAgICAgLy8gbm9UaGVtZUhpZ2hsaWdodD10cnVlIChkb24ndCBoaWdobGlnaHQgdGhlIGhlYWRlcilcbiAgICAgICAgICAgIGdldERheUNsYXNzZXMoZGF0ZU1hcmtlciwgZGF0ZVByb2ZpbGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIERBWV9JRFNbZGF0ZU1hcmtlci5nZXRVVENEYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xuICAgICAgICAgICAgKChpc0RhdGVWYWxpZCAmJiBkYXRlc1JlcERpc3RpbmN0RGF5cykgP1xuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGVNYXJrZXIsIHsgb21pdFRpbWU6IHRydWUgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAnJykgK1xuICAgICAgICAgICAgKGNvbHNwYW4gPiAxID9cbiAgICAgICAgICAgICAgICAnIGNvbHNwYW49XCInICsgY29sc3BhbiArICdcIicgOlxuICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XG4gICAgICAgICAgICAgICAgJyAnICsgb3RoZXJBdHRycyA6XG4gICAgICAgICAgICAgICAgJycpICtcbiAgICAgICAgICAgICc+JyArXG4gICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXG4gICAgICAgICAgICAgICAgYnVpbGRHb3RvQW5jaG9ySHRtbCh2aWV3LCB7IGRhdGU6IGRhdGVNYXJrZXIsIGZvcmNlT2ZmOiAhZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgY29sQ250ID09PSAxIH0sIGlubmVySHRtbCkgOlxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCB2YWxpZCwgZGlzcGxheSB0ZXh0LCBidXQgbm8gbGlua1xuICAgICAgICAgICAgICAgIGlubmVySHRtbCkgK1xuICAgICAgICAgICAgJzwvdGg+JztcbiAgICB9XG5cbiAgICB2YXIgRGF5SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGF5SGVhZGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEYXlIZWFkZXIoY29udGV4dCwgcGFyZW50RWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgICAgICBwYXJlbnRFbC5pbm5lckhUTUwgPSAnJzsgLy8gYmVjYXVzZSBtaWdodCBiZSBuYnNwXG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChfdGhpcy5lbCA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgY2xhc3M9XCJmYy1yb3cgJyArIF90aGlzLnRoZW1lLmdldENsYXNzKCdoZWFkZXJSb3cnKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIF90aGlzLnRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRoZWFkPjwvdGhlYWQ+JyArXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicpKTtcbiAgICAgICAgICAgIF90aGlzLnRoZWFkID0gX3RoaXMuZWwucXVlcnlTZWxlY3RvcigndGhlYWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBEYXlIZWFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBEYXlIZWFkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gcHJvcHMuZGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzID0gcHJvcHMuZGF0ZXNSZXBEaXN0aW5jdERheXM7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5yZW5kZXJJbnRyb0h0bWwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHByb3BzLnJlbmRlckludHJvSHRtbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xIZWFkRm9ybWF0ID0gY3JlYXRlRm9ybWF0dGVyKHRoaXMub3B0KCdjb2x1bW5IZWFkZXJGb3JtYXQnKSB8fFxuICAgICAgICAgICAgICAgIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRhdGVzXzEgPSBkYXRlczsgX2kgPCBkYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gZGF0ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChyZW5kZXJEYXRlQ2VsbChkYXRlLCBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCwgY29sSGVhZEZvcm1hdCwgdGhpcy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1J0bCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGhlYWQuaW5uZXJIVE1MID0gJzx0cj4nICsgcGFydHMuam9pbignJykgKyAnPC90cj4nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF5SGVhZGVyO1xuICAgIH0oQ29tcG9uZW50KSk7XG5cbiAgICB2YXIgRGF5U2VyaWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEYXlTZXJpZXMocmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZUdlbmVyYXRvci5pc0hpZGRlbkRheShkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgICAgIHRoaXMuY250ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIERheVNlcmllcy5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuICAgICAgICAgICAgdmFyIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XG4gICAgICAgICAgICB2YXIgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICAgICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgICAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG4gICAgICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuICAgICAgICBEYXlTZXJpZXMucHJvdG90eXBlLmdldERhdGVEYXlJbmRleCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgICAgIHZhciBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF5U2VyaWVzO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRGF5VGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERheVRhYmxlKGRheVNlcmllcywgYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBkYXlTZXJpZXMuZGF0ZXM7XG4gICAgICAgICAgICB2YXIgZGF5c1BlclJvdztcbiAgICAgICAgICAgIHZhciBmaXJzdERheTtcbiAgICAgICAgICAgIHZhciByb3dDbnQ7XG4gICAgICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlc1tkYXlzUGVyUm93XS5nZXRVVENEYXkoKSA9PT0gZmlyc3REYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICAgICAgdGhpcy5kYXlTZXJpZXMgPSBkYXlTZXJpZXM7XG4gICAgICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgRGF5VGFibGUucHJvdG90eXBlLmJ1aWxkQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKGNlbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICB9O1xuICAgICAgICBEYXlUYWJsZS5wcm90b3R5cGUuYnVpbGRDZWxsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF5U2VyaWVzLmRhdGVzW3JvdyAqIHRoaXMuY29sQ250ICsgY29sXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF5VGFibGUucHJvdG90eXBlLmJ1aWxkSGVhZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgICAgICB9O1xuICAgICAgICBEYXlUYWJsZS5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuICAgICAgICAgICAgdmFyIHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZXJpZXNTZWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IHNlcmllc1NlZy5maXJzdEluZGV4LCBsYXN0SW5kZXggPSBzZXJpZXNTZWcubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF5VGFibGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNsaWNlcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5zbGljZUV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NsaWNlRXZlbnRTdG9yZSk7XG4gICAgICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZVByb3BzID0gZnVuY3Rpb24gKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudFVpQmFzZXMgPSBwcm9wcy5ldmVudFVpQmFzZXM7XG4gICAgICAgICAgICB2YXIgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUuYXBwbHkodGhpcywgW3Byb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbXBvbmVudF0uY29uY2F0KGV4dHJhQXJncykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uU2VnczogdGhpcy5zbGljZURhdGVTZWxlY3Rpb24uYXBwbHkodGhpcywgW3Byb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50VWlCYXNlcywgY29tcG9uZW50XS5jb25jYXQoZXh0cmFBcmdzKSksXG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMuYXBwbHkodGhpcywgW3Byb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgICAgICAgICAgIGJnRXZlbnRTZWdzOiBldmVudFNlZ3MuYmcsXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnLmFwcGx5KHRoaXMsIFtwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbXBvbmVudF0uY29uY2F0KGV4dHJhQXJncykpLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUuYXBwbHkodGhpcywgW3Byb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb25cbiAgICAgICAgICAgIH07IC8vIFRPRE86IGdpdmUgaW50ZXJhY3Rpb25TZWdzP1xuICAgICAgICB9O1xuICAgICAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlTm93RGF0ZSA9IGZ1bmN0aW9uICgvLyBkb2VzIG5vdCBtZW1vaXplXG4gICAgICAgIGRhdGUsIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbi5hcHBseSh0aGlzLCBbeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50XS5jb25jYXQoZXh0cmFBcmdzKSk7XG4gICAgICAgIH07XG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnVzaW5lc3NIb3Vycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGljZUV2ZW50U3RvcmUuYXBwbHkodGhpcywgW2V4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb21wb25lbnQuY2FsZW5kYXIpLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIG5leHREYXlUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50XS5jb25jYXQoZXh0cmFBcmdzKSkuYmc7XG4gICAgICAgIH07XG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlRXZlbnRTdG9yZSA9IGZ1bmN0aW9uIChldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gNTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFBcmdzW19pIC0gNV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBjb21wb25lbnQsIGV4dHJhQXJncyksXG4gICAgICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGNvbXBvbmVudCwgZXh0cmFBcmdzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gNTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFBcmdzW19pIC0gNV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgY29tcG9uZW50LCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2VTZWc6IGludGVyYWN0aW9uLm9yaWdTZWdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlRGF0ZVNwYW4gPSBmdW5jdGlvbiAoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29tcG9uZW50LmNhbGVuZGFyKTtcbiAgICAgICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIFtkYXRlU3Bhbi5yYW5nZV0uY29uY2F0KGV4dHJhQXJncykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBzZWdzXzEgPSBzZWdzOyBfYSA8IHNlZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19hXTtcbiAgICAgICAgICAgICAgICBzZWcuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAgICAgKi9cbiAgICAgICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzLCBjb21wb25lbnQsIC8vIFRPRE86IGtpbGxcbiAgICAgICAgZXh0cmFBcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudFJhbmdlc18xID0gZXZlbnRSYW5nZXM7IF9pIDwgZXZlbnRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCB0aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBjb21wb25lbnQsIGV4dHJhQXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICAgICAqL1xuICAgICAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlRXZlbnRSYW5nZSA9IGZ1bmN0aW9uIChldmVudFJhbmdlLCBjb21wb25lbnQsIC8vIFRPRE86IGtpbGxcbiAgICAgICAgZXh0cmFBcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCBbZXZlbnRSYW5nZS5yYW5nZV0uY29uY2F0KGV4dHJhQXJncykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcbiAgICAgICAgICAgICAgICBzZWcuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2xpY2VyO1xuICAgIH0oKSk7XG4gICAgLypcbiAgICBmb3IgaW5jb3Jwb3JhdGluZyBtaW5UaW1lL21heFRpbWUgaWYgYXBwcm9wcmlhdGVcbiAgICBUT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcbiAgICBUaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuICAgICovXG4gICAgZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUubWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICAgICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLm1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBleHBvcnRzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgdmVyc2lvbiA9ICc0LjEuMCc7XG5cbiAgICBleHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXI7XG4gICAgZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5EYXRlQ29tcG9uZW50ID0gRGF0ZUNvbXBvbmVudDtcbiAgICBleHBvcnRzLkRhdGVFbnYgPSBEYXRlRW52O1xuICAgIGV4cG9ydHMuRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICBleHBvcnRzLkRheUhlYWRlciA9IERheUhlYWRlcjtcbiAgICBleHBvcnRzLkRheVNlcmllcyA9IERheVNlcmllcztcbiAgICBleHBvcnRzLkRheVRhYmxlID0gRGF5VGFibGU7XG4gICAgZXhwb3J0cy5FbGVtZW50RHJhZ2dpbmcgPSBFbGVtZW50RHJhZ2dpbmc7XG4gICAgZXhwb3J0cy5FbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuRW1pdHRlck1peGluID0gRW1pdHRlck1peGluO1xuICAgIGV4cG9ydHMuRXZlbnRBcGkgPSBFdmVudEFwaTtcbiAgICBleHBvcnRzLkZnRXZlbnRSZW5kZXJlciA9IEZnRXZlbnRSZW5kZXJlcjtcbiAgICBleHBvcnRzLkZpbGxSZW5kZXJlciA9IEZpbGxSZW5kZXJlcjtcbiAgICBleHBvcnRzLkludGVyYWN0aW9uID0gSW50ZXJhY3Rpb247XG4gICAgZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuICAgIGV4cG9ydHMuTmFtZWRUaW1lWm9uZUltcGwgPSBOYW1lZFRpbWVab25lSW1wbDtcbiAgICBleHBvcnRzLlBvc2l0aW9uQ2FjaGUgPSBQb3NpdGlvbkNhY2hlO1xuICAgIGV4cG9ydHMuU2Nyb2xsQ29tcG9uZW50ID0gU2Nyb2xsQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU2Nyb2xsQ29udHJvbGxlciA9IFNjcm9sbENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5TbGljZXIgPSBTbGljZXI7XG4gICAgZXhwb3J0cy5TcGxpdHRlciA9IFNwbGl0dGVyO1xuICAgIGV4cG9ydHMuVGhlbWUgPSBUaGVtZTtcbiAgICBleHBvcnRzLlZpZXcgPSBWaWV3O1xuICAgIGV4cG9ydHMuV2luZG93U2Nyb2xsQ29udHJvbGxlciA9IFdpbmRvd1Njcm9sbENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5hZGREYXlzID0gYWRkRGF5cztcbiAgICBleHBvcnRzLmFkZER1cmF0aW9ucyA9IGFkZER1cmF0aW9ucztcbiAgICBleHBvcnRzLmFkZE1zID0gYWRkTXM7XG4gICAgZXhwb3J0cy5hZGRXZWVrcyA9IGFkZFdlZWtzO1xuICAgIGV4cG9ydHMuYWxsb3dDb250ZXh0TWVudSA9IGFsbG93Q29udGV4dE1lbnU7XG4gICAgZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IGFsbG93U2VsZWN0aW9uO1xuICAgIGV4cG9ydHMuYXBwZW5kVG9FbGVtZW50ID0gYXBwZW5kVG9FbGVtZW50O1xuICAgIGV4cG9ydHMuYXBwbHlBbGwgPSBhcHBseUFsbDtcbiAgICBleHBvcnRzLmFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlO1xuICAgIGV4cG9ydHMuYXBwbHlTdHlsZSA9IGFwcGx5U3R5bGU7XG4gICAgZXhwb3J0cy5hcHBseVN0eWxlUHJvcCA9IGFwcGx5U3R5bGVQcm9wO1xuICAgIGV4cG9ydHMuYXNSb3VnaE1pbnV0ZXMgPSBhc1JvdWdoTWludXRlcztcbiAgICBleHBvcnRzLmFzUm91Z2hNcyA9IGFzUm91Z2hNcztcbiAgICBleHBvcnRzLmFzUm91Z2hTZWNvbmRzID0gYXNSb3VnaFNlY29uZHM7XG4gICAgZXhwb3J0cy5idWlsZEdvdG9BbmNob3JIdG1sID0gYnVpbGRHb3RvQW5jaG9ySHRtbDtcbiAgICBleHBvcnRzLmJ1aWxkU2VnQ29tcGFyZU9iaiA9IGJ1aWxkU2VnQ29tcGFyZU9iajtcbiAgICBleHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IGNhcGl0YWxpc2VGaXJzdExldHRlcjtcbiAgICBleHBvcnRzLmNvbWJpbmVFdmVudFVpcyA9IGNvbWJpbmVFdmVudFVpcztcbiAgICBleHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IGNvbXBhcmVCeUZpZWxkU3BlYztcbiAgICBleHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xuICAgIGV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSBjb21wYXJlTnVtYmVycztcbiAgICBleHBvcnRzLmNvbXBlbnNhdGVTY3JvbGwgPSBjb21wZW5zYXRlU2Nyb2xsO1xuICAgIGV4cG9ydHMuY29tcHV0ZUNsaXBwaW5nUmVjdCA9IGNvbXB1dGVDbGlwcGluZ1JlY3Q7XG4gICAgZXhwb3J0cy5jb21wdXRlRWRnZXMgPSBjb21wdXRlRWRnZXM7XG4gICAgZXhwb3J0cy5jb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgPSBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQ7XG4gICAgZXhwb3J0cy5jb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyA9IGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zO1xuICAgIGV4cG9ydHMuY29tcHV0ZUlubmVyUmVjdCA9IGNvbXB1dGVJbm5lclJlY3Q7XG4gICAgZXhwb3J0cy5jb21wdXRlUmVjdCA9IGNvbXB1dGVSZWN0O1xuICAgIGV4cG9ydHMuY29tcHV0ZVZpc2libGVEYXlSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2U7XG4gICAgZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG4gICAgZXhwb3J0cy5jb25zdHJhaW5Qb2ludCA9IGNvbnN0cmFpblBvaW50O1xuICAgIGV4cG9ydHMuY3JlYXRlRHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuICAgIGV4cG9ydHMuY3JlYXRlRW1wdHlFdmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlO1xuICAgIGV4cG9ydHMuY3JlYXRlRXZlbnRJbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2U7XG4gICAgZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXI7XG4gICAgZXhwb3J0cy5jcmVhdGVQbHVnaW4gPSBjcmVhdGVQbHVnaW47XG4gICAgZXhwb3J0cy5jc3NUb1N0ciA9IGNzc1RvU3RyO1xuICAgIGV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBleHBvcnRzLmRpZmZEYXRlcyA9IGRpZmZEYXRlcztcbiAgICBleHBvcnRzLmRpZmZEYXlBbmRUaW1lID0gZGlmZkRheUFuZFRpbWU7XG4gICAgZXhwb3J0cy5kaWZmRGF5cyA9IGRpZmZEYXlzO1xuICAgIGV4cG9ydHMuZGlmZlBvaW50cyA9IGRpZmZQb2ludHM7XG4gICAgZXhwb3J0cy5kaWZmV2Vla3MgPSBkaWZmV2Vla3M7XG4gICAgZXhwb3J0cy5kaWZmV2hvbGVEYXlzID0gZGlmZldob2xlRGF5cztcbiAgICBleHBvcnRzLmRpZmZXaG9sZVdlZWtzID0gZGlmZldob2xlV2Vla3M7XG4gICAgZXhwb3J0cy5kaXNhYmxlQ3Vyc29yID0gZGlzYWJsZUN1cnNvcjtcbiAgICBleHBvcnRzLmRpc3RyaWJ1dGVIZWlnaHQgPSBkaXN0cmlidXRlSGVpZ2h0O1xuICAgIGV4cG9ydHMuZWxlbWVudENsb3Nlc3QgPSBlbGVtZW50Q2xvc2VzdDtcbiAgICBleHBvcnRzLmVsZW1lbnRNYXRjaGVzID0gZWxlbWVudE1hdGNoZXM7XG4gICAgZXhwb3J0cy5lbmFibGVDdXJzb3IgPSBlbmFibGVDdXJzb3I7XG4gICAgZXhwb3J0cy5ldmVudFR1cGxlVG9TdG9yZSA9IGV2ZW50VHVwbGVUb1N0b3JlO1xuICAgIGV4cG9ydHMuZmlsdGVyRXZlbnRTdG9yZURlZnMgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcztcbiAgICBleHBvcnRzLmZpbHRlckhhc2ggPSBmaWx0ZXJIYXNoO1xuICAgIGV4cG9ydHMuZmluZENoaWxkcmVuID0gZmluZENoaWxkcmVuO1xuICAgIGV4cG9ydHMuZmluZEVsZW1lbnRzID0gZmluZEVsZW1lbnRzO1xuICAgIGV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xuICAgIGV4cG9ydHMuZm9yY2VDbGFzc05hbWUgPSBmb3JjZUNsYXNzTmFtZTtcbiAgICBleHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xuICAgIGV4cG9ydHMuZm9ybWF0SXNvVGltZVN0cmluZyA9IGZvcm1hdElzb1RpbWVTdHJpbmc7XG4gICAgZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGZvcm1hdFJhbmdlO1xuICAgIGV4cG9ydHMuZnJlZXplUmF3ID0gZnJlZXplUmF3O1xuICAgIGV4cG9ydHMuZ2V0QWxsRGF5SHRtbCA9IGdldEFsbERheUh0bWw7XG4gICAgZXhwb3J0cy5nZXRDbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHM7XG4gICAgZXhwb3J0cy5nZXREYXlDbGFzc2VzID0gZ2V0RGF5Q2xhc3NlcztcbiAgICBleHBvcnRzLmdldEVsU2VnID0gZ2V0RWxTZWc7XG4gICAgZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcbiAgICBleHBvcnRzLmdldFJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHM7XG4gICAgZXhwb3J0cy5nbG9iYWxEZWZhdWx0cyA9IGdsb2JhbERlZmF1bHRzO1xuICAgIGV4cG9ydHMuZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yO1xuICAgIGV4cG9ydHMuaGFzQmdSZW5kZXJpbmcgPSBoYXNCZ1JlbmRlcmluZztcbiAgICBleHBvcnRzLmh0bWxFc2NhcGUgPSBodG1sRXNjYXBlO1xuICAgIGV4cG9ydHMuaHRtbFRvRWxlbWVudCA9IGh0bWxUb0VsZW1lbnQ7XG4gICAgZXhwb3J0cy5pbnNlcnRBZnRlckVsZW1lbnQgPSBpbnNlcnRBZnRlckVsZW1lbnQ7XG4gICAgZXhwb3J0cy5pbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmU7XG4gICAgZXhwb3J0cy5pbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSA9IGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlO1xuICAgIGV4cG9ydHMuaW50ZXJzZWN0UmFuZ2VzID0gaW50ZXJzZWN0UmFuZ2VzO1xuICAgIGV4cG9ydHMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcbiAgICBleHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xuICAgIGV4cG9ydHMuaXNEYXRlU3BhbnNFcXVhbCA9IGlzRGF0ZVNwYW5zRXF1YWw7XG4gICAgZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuICAgIGV4cG9ydHMuaXNJbnRlcmFjdGlvblZhbGlkID0gaXNJbnRlcmFjdGlvblZhbGlkO1xuICAgIGV4cG9ydHMuaXNNdWx0aURheVJhbmdlID0gaXNNdWx0aURheVJhbmdlO1xuICAgIGV4cG9ydHMuaXNPYmplY3RzU2ltaWxhciA9IGlzT2JqZWN0c1NpbWlsYXI7XG4gICAgZXhwb3J0cy5pc1Byb3BzVmFsaWQgPSBpc1Byb3BzVmFsaWQ7XG4gICAgZXhwb3J0cy5pc1NpbmdsZURheSA9IGlzU2luZ2xlRGF5O1xuICAgIGV4cG9ydHMuaXNWYWxpZERhdGUgPSBpc1ZhbGlkRGF0ZTtcbiAgICBleHBvcnRzLmlzVmFsdWVzU2ltaWxhciA9IGlzVmFsdWVzU2ltaWxhcjtcbiAgICBleHBvcnRzLmxpc3RlbkJ5U2VsZWN0b3IgPSBsaXN0ZW5CeVNlbGVjdG9yO1xuICAgIGV4cG9ydHMubWFwSGFzaCA9IG1hcEhhc2g7XG4gICAgZXhwb3J0cy5tYXRjaENlbGxXaWR0aHMgPSBtYXRjaENlbGxXaWR0aHM7XG4gICAgZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBleHBvcnRzLm1lbW9pemVPdXRwdXQgPSBtZW1vaXplT3V0cHV0O1xuICAgIGV4cG9ydHMubWVtb2l6ZVJlbmRlcmluZyA9IG1lbW9pemVSZW5kZXJpbmc7XG4gICAgZXhwb3J0cy5tZXJnZUV2ZW50U3RvcmVzID0gbWVyZ2VFdmVudFN0b3JlcztcbiAgICBleHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xuICAgIGV4cG9ydHMucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBleHBvcnRzLnBhcnNlQnVzaW5lc3NIb3VycyA9IHBhcnNlQnVzaW5lc3NIb3VycztcbiAgICBleHBvcnRzLnBhcnNlRHJhZ01ldGEgPSBwYXJzZURyYWdNZXRhO1xuICAgIGV4cG9ydHMucGFyc2VFdmVudERlZiA9IHBhcnNlRXZlbnREZWY7XG4gICAgZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSBwYXJzZUZpZWxkU3BlY3M7XG4gICAgZXhwb3J0cy5wYXJzZU1hcmtlciA9IHBhcnNlO1xuICAgIGV4cG9ydHMucG9pbnRJbnNpZGVSZWN0ID0gcG9pbnRJbnNpZGVSZWN0O1xuICAgIGV4cG9ydHMucHJlcGVuZFRvRWxlbWVudCA9IHByZXBlbmRUb0VsZW1lbnQ7XG4gICAgZXhwb3J0cy5wcmV2ZW50Q29udGV4dE1lbnUgPSBwcmV2ZW50Q29udGV4dE1lbnU7XG4gICAgZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuICAgIGV4cG9ydHMucHJldmVudFNlbGVjdGlvbiA9IHByZXZlbnRTZWxlY3Rpb247XG4gICAgZXhwb3J0cy5wcm9jZXNzU2NvcGVkVWlQcm9wcyA9IHByb2Nlc3NTY29wZWRVaVByb3BzO1xuICAgIGV4cG9ydHMucmFuZ2VDb250YWluc01hcmtlciA9IHJhbmdlQ29udGFpbnNNYXJrZXI7XG4gICAgZXhwb3J0cy5yYW5nZUNvbnRhaW5zUmFuZ2UgPSByYW5nZUNvbnRhaW5zUmFuZ2U7XG4gICAgZXhwb3J0cy5yYW5nZXNFcXVhbCA9IHJhbmdlc0VxdWFsO1xuICAgIGV4cG9ydHMucmFuZ2VzSW50ZXJzZWN0ID0gcmFuZ2VzSW50ZXJzZWN0O1xuICAgIGV4cG9ydHMucmVmaW5lUHJvcHMgPSByZWZpbmVQcm9wcztcbiAgICBleHBvcnRzLnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xuICAgIGV4cG9ydHMucmVtb3ZlRXhhY3QgPSByZW1vdmVFeGFjdDtcbiAgICBleHBvcnRzLnJlbmRlckRhdGVDZWxsID0gcmVuZGVyRGF0ZUNlbGw7XG4gICAgZXhwb3J0cy5yZXF1ZXN0SnNvbiA9IHJlcXVlc3RKc29uO1xuICAgIGV4cG9ydHMuc2xpY2VFdmVudFN0b3JlID0gc2xpY2VFdmVudFN0b3JlO1xuICAgIGV4cG9ydHMuc3RhcnRPZkRheSA9IHN0YXJ0T2ZEYXk7XG4gICAgZXhwb3J0cy5zdWJ0cmFjdElubmVyRWxIZWlnaHQgPSBzdWJ0cmFjdElubmVyRWxIZWlnaHQ7XG4gICAgZXhwb3J0cy50cmFuc2xhdGVSZWN0ID0gdHJhbnNsYXRlUmVjdDtcbiAgICBleHBvcnRzLnVuY29tcGVuc2F0ZVNjcm9sbCA9IHVuY29tcGVuc2F0ZVNjcm9sbDtcbiAgICBleHBvcnRzLnVuZGlzdHJpYnV0ZUhlaWdodCA9IHVuZGlzdHJpYnV0ZUhlaWdodDtcbiAgICBleHBvcnRzLnVucHJvbWlzaWZ5ID0gdW5wcm9taXNpZnk7XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBleHBvcnRzLndoZW5UcmFuc2l0aW9uRG9uZSA9IHdoZW5UcmFuc2l0aW9uRG9uZTtcbiAgICBleHBvcnRzLndob2xlRGl2aWRlRHVyYXRpb25zID0gd2hvbGVEaXZpZGVEdXJhdGlvbnM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\nFullCalendar Day Grid Plugin v4.1.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ \"./node_modules/@fullcalendar/core/main.js\")) :\n    undefined;\n}(this, function (exports, core) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    var DayGridDateProfileGenerator = /** @class */ (function (_super) {\n        __extends(DayGridDateProfileGenerator, _super);\n        function DayGridDateProfileGenerator() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        // Computes the date range that will be rendered.\n        DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n            var dateEnv = this.dateEnv;\n            var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n            var start = renderRange.start;\n            var end = renderRange.end;\n            var endOfWeek;\n            // year and month views should be aligned with weeks. this is already done for week\n            if (/^(year|month)$/.test(currentRangeUnit)) {\n                start = dateEnv.startOfWeek(start);\n                // make end-of-week if not already\n                endOfWeek = dateEnv.startOfWeek(end);\n                if (endOfWeek.valueOf() !== end.valueOf()) {\n                    end = core.addWeeks(endOfWeek, 1);\n                }\n            }\n            // ensure 6 weeks\n            if (this.options.monthMode &&\n                this.options.fixedWeekCount) {\n                var rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\n                core.diffWeeks(start, end));\n                end = core.addWeeks(end, 6 - rowCnt);\n            }\n            return { start: start, end: end };\n        };\n        return DayGridDateProfileGenerator;\n    }(core.DateProfileGenerator));\n\n    /* A rectangular panel that is absolutely positioned over other content\n    ------------------------------------------------------------------------------------------------------------------------\n    Options:\n      - className (string)\n      - content (HTML string, element, or element array)\n      - parentEl\n      - top\n      - left\n      - right (the x coord of where the right edge should be. not a \"CSS\" right)\n      - autoHide (boolean)\n      - show (callback)\n      - hide (callback)\n    */\n    var Popover = /** @class */ (function () {\n        function Popover(options) {\n            var _this = this;\n            this.isHidden = true;\n            this.margin = 10; // the space required between the popover and the edges of the scroll container\n            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n            this.documentMousedown = function (ev) {\n                // only hide the popover if the click happened outside the popover\n                if (_this.el && !_this.el.contains(ev.target)) {\n                    _this.hide();\n                }\n            };\n            this.options = options;\n        }\n        // Shows the popover on the specified position. Renders it if not already\n        Popover.prototype.show = function () {\n            if (this.isHidden) {\n                if (!this.el) {\n                    this.render();\n                }\n                this.el.style.display = '';\n                this.position();\n                this.isHidden = false;\n                this.trigger('show');\n            }\n        };\n        // Hides the popover, through CSS, but does not remove it from the DOM\n        Popover.prototype.hide = function () {\n            if (!this.isHidden) {\n                this.el.style.display = 'none';\n                this.isHidden = true;\n                this.trigger('hide');\n            }\n        };\n        // Creates `this.el` and renders content inside of it\n        Popover.prototype.render = function () {\n            var _this = this;\n            var options = this.options;\n            var el = this.el = core.createElement('div', {\n                className: 'fc-popover ' + (options.className || ''),\n                style: {\n                    top: '0',\n                    left: '0'\n                }\n            });\n            if (typeof options.content === 'function') {\n                options.content(el);\n            }\n            options.parentEl.appendChild(el);\n            // when a click happens on anything inside with a 'fc-close' className, hide the popover\n            core.listenBySelector(el, 'click', '.fc-close', function (ev) {\n                _this.hide();\n            });\n            if (options.autoHide) {\n                document.addEventListener('mousedown', this.documentMousedown);\n            }\n        };\n        // Hides and unregisters any handlers\n        Popover.prototype.destroy = function () {\n            this.hide();\n            if (this.el) {\n                core.removeElement(this.el);\n                this.el = null;\n            }\n            document.removeEventListener('mousedown', this.documentMousedown);\n        };\n        // Positions the popover optimally, using the top/left/right options\n        Popover.prototype.position = function () {\n            var options = this.options;\n            var el = this.el;\n            var elDims = el.getBoundingClientRect(); // only used for width,height\n            var origin = core.computeRect(el.offsetParent);\n            var clippingRect = core.computeClippingRect(options.parentEl);\n            var top; // the \"position\" (not \"offset\") values for the popover\n            var left; //\n            // compute top and left\n            top = options.top || 0;\n            if (options.left !== undefined) {\n                left = options.left;\n            }\n            else if (options.right !== undefined) {\n                left = options.right - elDims.width; // derive the left value from the right value\n            }\n            else {\n                left = 0;\n            }\n            // constrain to the view port. if constrained by two edges, give precedence to top/left\n            top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);\n            top = Math.max(top, clippingRect.top + this.margin);\n            left = Math.min(left, clippingRect.right - elDims.width - this.margin);\n            left = Math.max(left, clippingRect.left + this.margin);\n            core.applyStyle(el, {\n                top: top - origin.top,\n                left: left - origin.left\n            });\n        };\n        // Triggers a callback. Calls a function in the option hash of the same name.\n        // Arguments beyond the first `name` are forwarded on.\n        // TODO: better code reuse for this. Repeat code\n        // can kill this???\n        Popover.prototype.trigger = function (name) {\n            if (this.options[name]) {\n                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        };\n        return Popover;\n    }());\n\n    /* Event-rendering methods for the DayGrid class\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // \"Simple\" is bad a name. has nothing to do with SimpleDayGrid\n    var SimpleDayGridEventRenderer = /** @class */ (function (_super) {\n        __extends(SimpleDayGridEventRenderer, _super);\n        function SimpleDayGridEventRenderer() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        // Builds the HTML to be used for the default element for an individual segment\n        SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n            var options = this.context.options;\n            var eventRange = seg.eventRange;\n            var eventDef = eventRange.def;\n            var eventUi = eventRange.ui;\n            var allDay = eventDef.allDay;\n            var isDraggable = eventUi.startEditable;\n            var isResizableFromStart = allDay && seg.isStart && eventUi.durationEditable && options.eventResizableFromStart;\n            var isResizableFromEnd = allDay && seg.isEnd && eventUi.durationEditable;\n            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n            var skinCss = core.cssToStr(this.getSkinCss(eventUi));\n            var timeHtml = '';\n            var timeText;\n            var titleHtml;\n            classes.unshift('fc-day-grid-event', 'fc-h-event');\n            // Only display a timed events time if it is the starting segment\n            if (seg.isStart) {\n                timeText = this.getTimeText(eventRange);\n                if (timeText) {\n                    timeHtml = '<span class=\"fc-time\">' + core.htmlEscape(timeText) + '</span>';\n                }\n            }\n            titleHtml =\n                '<span class=\"fc-title\">' +\n                    (core.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\n                    '</span>';\n            return '<a class=\"' + classes.join(' ') + '\"' +\n                (eventDef.url ?\n                    ' href=\"' + core.htmlEscape(eventDef.url) + '\"' :\n                    '') +\n                (skinCss ?\n                    ' style=\"' + skinCss + '\"' :\n                    '') +\n                '>' +\n                '<div class=\"fc-content\">' +\n                (options.dir === 'rtl' ?\n                    titleHtml + ' ' + timeHtml : // put a natural space in between\n                    timeHtml + ' ' + titleHtml //\n                ) +\n                '</div>' +\n                (isResizableFromStart ?\n                    '<div class=\"fc-resizer fc-start-resizer\"></div>' :\n                    '') +\n                (isResizableFromEnd ?\n                    '<div class=\"fc-resizer fc-end-resizer\"></div>' :\n                    '') +\n                '</a>';\n        };\n        // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined\n        SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {\n            return {\n                hour: 'numeric',\n                minute: '2-digit',\n                omitZeroMinute: true,\n                meridiem: 'narrow'\n            };\n        };\n        SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n            return false; // TODO: somehow consider the originating DayGrid's column count\n        };\n        return SimpleDayGridEventRenderer;\n    }(core.FgEventRenderer));\n\n    /* Event-rendering methods for the DayGrid class\n    ----------------------------------------------------------------------------------------------------------------------*/\n    var DayGridEventRenderer = /** @class */ (function (_super) {\n        __extends(DayGridEventRenderer, _super);\n        function DayGridEventRenderer(dayGrid) {\n            var _this = _super.call(this, dayGrid.context) || this;\n            _this.dayGrid = dayGrid;\n            return _this;\n        }\n        // Renders the given foreground event segments onto the grid\n        DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n            var rowStructs = this.rowStructs = this.renderSegRows(segs);\n            // append to each row's content skeleton\n            this.dayGrid.rowEls.forEach(function (rowNode, i) {\n                rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);\n            });\n            // removes the \"more..\" events popover\n            if (!mirrorInfo) {\n                this.dayGrid.removeSegPopover();\n            }\n        };\n        // Unrenders all currently rendered foreground event segments\n        DayGridEventRenderer.prototype.detachSegs = function () {\n            var rowStructs = this.rowStructs || [];\n            var rowStruct;\n            while ((rowStruct = rowStructs.pop())) {\n                core.removeElement(rowStruct.tbodyEl);\n            }\n            this.rowStructs = null;\n        };\n        // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n        // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n        // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n        DayGridEventRenderer.prototype.renderSegRows = function (segs) {\n            var rowStructs = [];\n            var segRows;\n            var row;\n            segRows = this.groupSegRows(segs); // group into nested arrays\n            // iterate each row of segment groupings\n            for (row = 0; row < segRows.length; row++) {\n                rowStructs.push(this.renderSegRow(row, segRows[row]));\n            }\n            return rowStructs;\n        };\n        // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n        // the segments. Returns object with a bunch of internal data about how the render was calculated.\n        // NOTE: modifies rowSegs\n        DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\n            var dayGrid = this.dayGrid;\n            var colCnt = dayGrid.colCnt, isRtl = dayGrid.isRtl;\n            var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n            var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n            var tbody = document.createElement('tbody');\n            var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n            var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n            var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n            var i;\n            var levelSegs;\n            var col;\n            var tr;\n            var j;\n            var seg;\n            var td;\n            // populates empty cells from the current column (`col`) to `endCol`\n            function emptyCellsUntil(endCol) {\n                while (col < endCol) {\n                    // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n                    td = (loneCellMatrix[i - 1] || [])[col];\n                    if (td) {\n                        td.rowSpan = (td.rowSpan || 1) + 1;\n                    }\n                    else {\n                        td = document.createElement('td');\n                        tr.appendChild(td);\n                    }\n                    cellMatrix[i][col] = td;\n                    loneCellMatrix[i][col] = td;\n                    col++;\n                }\n            }\n            for (i = 0; i < levelCnt; i++) { // iterate through all levels\n                levelSegs = segLevels[i];\n                col = 0;\n                tr = document.createElement('tr');\n                segMatrix.push([]);\n                cellMatrix.push([]);\n                loneCellMatrix.push([]);\n                // levelCnt might be 1 even though there are no actual levels. protect against this.\n                // this single empty row is useful for styling.\n                if (levelSegs) {\n                    for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level\n                        seg = levelSegs[j];\n                        var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;\n                        var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;\n                        emptyCellsUntil(leftCol);\n                        // create a container that occupies or more columns. append the event element.\n                        td = core.createElement('td', { className: 'fc-event-container' }, seg.el);\n                        if (leftCol !== rightCol) {\n                            td.colSpan = rightCol - leftCol + 1;\n                        }\n                        else { // a single-column segment\n                            loneCellMatrix[i][col] = td;\n                        }\n                        while (col <= rightCol) {\n                            cellMatrix[i][col] = td;\n                            segMatrix[i][col] = seg;\n                            col++;\n                        }\n                        tr.appendChild(td);\n                    }\n                }\n                emptyCellsUntil(colCnt); // finish off the row\n                var introHtml = dayGrid.renderProps.renderIntroHtml();\n                if (introHtml) {\n                    if (dayGrid.isRtl) {\n                        core.appendToElement(tr, introHtml);\n                    }\n                    else {\n                        core.prependToElement(tr, introHtml);\n                    }\n                }\n                tbody.appendChild(tr);\n            }\n            return {\n                row: row,\n                tbodyEl: tbody,\n                cellMatrix: cellMatrix,\n                segMatrix: segMatrix,\n                segLevels: segLevels,\n                segs: rowSegs\n            };\n        };\n        // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n        // NOTE: modifies segs\n        DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\n            var _a = this.dayGrid, isRtl = _a.isRtl, colCnt = _a.colCnt;\n            var levels = [];\n            var i;\n            var seg;\n            var j;\n            // Give preference to elements with certain criteria, so they have\n            // a chance to be closer to the top.\n            segs = this.sortEventSegs(segs);\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n                for (j = 0; j < levels.length; j++) {\n                    if (!isDaySegCollision(seg, levels[j])) {\n                        break;\n                    }\n                }\n                // `j` now holds the desired subrow index\n                seg.level = j;\n                seg.leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol; // for sorting only\n                seg.rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol // for sorting only\n                ;\n                (levels[j] || (levels[j] = [])).push(seg);\n            }\n            // order segments left-to-right. very important if calendar is RTL\n            for (j = 0; j < levels.length; j++) {\n                levels[j].sort(compareDaySegCols);\n            }\n            return levels;\n        };\n        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n        DayGridEventRenderer.prototype.groupSegRows = function (segs) {\n            var segRows = [];\n            var i;\n            for (i = 0; i < this.dayGrid.rowCnt; i++) {\n                segRows.push([]);\n            }\n            for (i = 0; i < segs.length; i++) {\n                segRows[segs[i].row].push(segs[i]);\n            }\n            return segRows;\n        };\n        // Computes a default `displayEventEnd` value if one is not expliclty defined\n        DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n            return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\n        };\n        return DayGridEventRenderer;\n    }(SimpleDayGridEventRenderer));\n    // Computes whether two segments' columns collide. They are assumed to be in the same row.\n    function isDaySegCollision(seg, otherSegs) {\n        var i;\n        var otherSeg;\n        for (i = 0; i < otherSegs.length; i++) {\n            otherSeg = otherSegs[i];\n            if (otherSeg.firstCol <= seg.lastCol &&\n                otherSeg.lastCol >= seg.firstCol) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // A cmp function for determining the leftmost event\n    function compareDaySegCols(a, b) {\n        return a.leftCol - b.leftCol;\n    }\n\n    var DayGridMirrorRenderer = /** @class */ (function (_super) {\n        __extends(DayGridMirrorRenderer, _super);\n        function DayGridMirrorRenderer() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n            var sourceSeg = mirrorInfo.sourceSeg;\n            var rowStructs = this.rowStructs = this.renderSegRows(segs);\n            // inject each new event skeleton into each associated row\n            this.dayGrid.rowEls.forEach(function (rowNode, row) {\n                var skeletonEl = core.htmlToElement('<div class=\"fc-mirror-skeleton\"><table></table></div>'); // will be absolutely positioned\n                var skeletonTopEl;\n                var skeletonTop;\n                // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n                if (sourceSeg && sourceSeg.row === row) {\n                    skeletonTopEl = sourceSeg.el;\n                }\n                else {\n                    skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');\n                    if (!skeletonTopEl) { // when no events\n                        skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');\n                    }\n                }\n                skeletonTop = skeletonTopEl.getBoundingClientRect().top -\n                    rowNode.getBoundingClientRect().top; // the offsetParent origin\n                skeletonEl.style.top = skeletonTop + 'px';\n                skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);\n                rowNode.appendChild(skeletonEl);\n            });\n        };\n        return DayGridMirrorRenderer;\n    }(DayGridEventRenderer));\n\n    var DayGridFillRenderer = /** @class */ (function (_super) {\n        __extends(DayGridFillRenderer, _super);\n        function DayGridFillRenderer(dayGrid) {\n            var _this = _super.call(this, dayGrid.context) || this;\n            _this.fillSegTag = 'td'; // override the default tag name\n            _this.dayGrid = dayGrid;\n            return _this;\n        }\n        DayGridFillRenderer.prototype.renderSegs = function (type, segs) {\n            // don't render timed background events\n            if (type === 'bgEvent') {\n                segs = segs.filter(function (seg) {\n                    return seg.eventRange.def.allDay;\n                });\n            }\n            _super.prototype.renderSegs.call(this, type, segs);\n        };\n        DayGridFillRenderer.prototype.attachSegs = function (type, segs) {\n            var els = [];\n            var i;\n            var seg;\n            var skeletonEl;\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                skeletonEl = this.renderFillRow(type, seg);\n                this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);\n                els.push(skeletonEl);\n            }\n            return els;\n        };\n        // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n        DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\n            var dayGrid = this.dayGrid;\n            var colCnt = dayGrid.colCnt, isRtl = dayGrid.isRtl;\n            var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;\n            var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;\n            var startCol = leftCol;\n            var endCol = rightCol + 1;\n            var className;\n            var skeletonEl;\n            var trEl;\n            if (type === 'businessHours') {\n                className = 'bgevent';\n            }\n            else {\n                className = type.toLowerCase();\n            }\n            skeletonEl = core.htmlToElement('<div class=\"fc-' + className + '-skeleton\">' +\n                '<table><tr></tr></table>' +\n                '</div>');\n            trEl = skeletonEl.getElementsByTagName('tr')[0];\n            if (startCol > 0) {\n                core.appendToElement(trEl, \n                // will create (startCol + 1) td's\n                new Array(startCol + 1).join('<td></td>'));\n            }\n            seg.el.colSpan = endCol - startCol;\n            trEl.appendChild(seg.el);\n            if (endCol < colCnt) {\n                core.appendToElement(trEl, \n                // will create (colCnt - endCol) td's\n                new Array(colCnt - endCol + 1).join('<td></td>'));\n            }\n            var introHtml = dayGrid.renderProps.renderIntroHtml();\n            if (introHtml) {\n                if (dayGrid.isRtl) {\n                    core.appendToElement(trEl, introHtml);\n                }\n                else {\n                    core.prependToElement(trEl, introHtml);\n                }\n            }\n            return skeletonEl;\n        };\n        return DayGridFillRenderer;\n    }(core.FillRenderer));\n\n    var DayTile = /** @class */ (function (_super) {\n        __extends(DayTile, _super);\n        function DayTile(context, el) {\n            var _this = _super.call(this, context, el) || this;\n            var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);\n            var renderFrame = _this.renderFrame = core.memoizeRendering(_this._renderFrame);\n            _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);\n            _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n            _this.renderEventDrag = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n            _this.renderEventResize = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n            context.calendar.registerInteractiveComponent(_this, {\n                el: _this.el,\n                useEventCenter: false\n            });\n            return _this;\n        }\n        DayTile.prototype.render = function (props) {\n            this.renderFrame(props.date);\n            this.renderFgEvents(props.fgSegs);\n            this.renderEventSelection(props.eventSelection);\n            this.renderEventDrag(props.eventDragInstances);\n            this.renderEventResize(props.eventResizeInstances);\n        };\n        DayTile.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this.renderFrame.unrender(); // should unrender everything else\n            this.calendar.unregisterInteractiveComponent(this);\n        };\n        DayTile.prototype._renderFrame = function (date) {\n            var _a = this, theme = _a.theme, dateEnv = _a.dateEnv;\n            var title = dateEnv.format(date, core.createFormatter(this.opt('dayPopoverFormat')) // TODO: cache\n            );\n            this.el.innerHTML =\n                '<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' +\n                    '<span class=\"fc-title\">' +\n                    core.htmlEscape(title) +\n                    '</span>' +\n                    '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' +\n                    '</div>' +\n                    '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' +\n                    '<div class=\"fc-event-container\"></div>' +\n                    '</div>';\n            this.segContainerEl = this.el.querySelector('.fc-event-container');\n        };\n        DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n            var date = this.props.date; // HACK\n            if (positionLeft < elWidth && positionTop < elHeight) {\n                return {\n                    component: this,\n                    dateSpan: {\n                        allDay: true,\n                        range: { start: date, end: core.addDays(date, 1) }\n                    },\n                    dayEl: this.el,\n                    rect: {\n                        left: 0,\n                        top: 0,\n                        right: elWidth,\n                        bottom: elHeight\n                    },\n                    layer: 1\n                };\n            }\n        };\n        return DayTile;\n    }(core.DateComponent));\n    var DayTileEventRenderer = /** @class */ (function (_super) {\n        __extends(DayTileEventRenderer, _super);\n        function DayTileEventRenderer(dayTile) {\n            var _this = _super.call(this, dayTile.context) || this;\n            _this.dayTile = dayTile;\n            return _this;\n        }\n        DayTileEventRenderer.prototype.attachSegs = function (segs) {\n            for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                var seg = segs_1[_i];\n                this.dayTile.segContainerEl.appendChild(seg.el);\n            }\n        };\n        DayTileEventRenderer.prototype.detachSegs = function (segs) {\n            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n                var seg = segs_2[_i];\n                core.removeElement(seg.el);\n            }\n        };\n        return DayTileEventRenderer;\n    }(SimpleDayGridEventRenderer));\n\n    var DayBgRow = /** @class */ (function () {\n        function DayBgRow(context) {\n            this.context = context;\n        }\n        DayBgRow.prototype.renderHtml = function (props) {\n            var parts = [];\n            if (props.renderIntroHtml) {\n                parts.push(props.renderIntroHtml());\n            }\n            for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {\n                var cell = _a[_i];\n                parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));\n            }\n            if (!props.cells.length) {\n                parts.push('<td class=\"fc-day ' + this.context.theme.getClass('widgetContent') + '\"></td>');\n            }\n            if (this.context.options.dir === 'rtl') {\n                parts.reverse();\n            }\n            return '<tr>' + parts.join('') + '</tr>';\n        };\n        return DayBgRow;\n    }());\n    function renderCellHtml(date, dateProfile, context, otherAttrs) {\n        var dateEnv = context.dateEnv, theme = context.theme;\n        var isDateValid = core.rangeContainsMarker(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n        var classes = core.getDayClasses(date, dateProfile, context);\n        classes.unshift('fc-day', theme.getClass('widgetContent'));\n        return '<td class=\"' + classes.join(' ') + '\"' +\n            (isDateValid ?\n                ' data-date=\"' + dateEnv.formatIso(date, { omitTime: true }) + '\"' :\n                '') +\n            (otherAttrs ?\n                ' ' + otherAttrs :\n                '') +\n            '></td>';\n    }\n\n    var DAY_NUM_FORMAT = core.createFormatter({ day: 'numeric' });\n    var WEEK_NUM_FORMAT = core.createFormatter({ week: 'numeric' });\n    var DayGrid = /** @class */ (function (_super) {\n        __extends(DayGrid, _super);\n        function DayGrid(context, el, renderProps) {\n            var _this = _super.call(this, context, el) || this;\n            _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\n            _this.isCellSizesDirty = false;\n            var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);\n            var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);\n            _this.mirrorRenderer = new DayGridMirrorRenderer(_this);\n            var renderCells = _this.renderCells = core.memoizeRendering(_this._renderCells, _this._unrenderCells);\n            _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);\n            _this.renderDateSelection = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);\n            _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);\n            _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);\n            _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n            _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);\n            _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);\n            _this.renderProps = renderProps;\n            return _this;\n        }\n        DayGrid.prototype.render = function (props) {\n            var cells = props.cells;\n            this.rowCnt = cells.length;\n            this.colCnt = cells[0].length;\n            this.renderCells(cells, props.isRigid);\n            this.renderBusinessHours(props.businessHourSegs);\n            this.renderDateSelection(props.dateSelectionSegs);\n            this.renderBgEvents(props.bgEventSegs);\n            this.renderFgEvents(props.fgEventSegs);\n            this.renderEventSelection(props.eventSelection);\n            this.renderEventDrag(props.eventDrag);\n            this.renderEventResize(props.eventResize);\n            if (this.segPopoverTile) {\n                this.updateSegPopoverTile();\n            }\n        };\n        DayGrid.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this.renderCells.unrender(); // will unrender everything else\n        };\n        DayGrid.prototype.getCellRange = function (row, col) {\n            var start = this.props.cells[row][col].date;\n            var end = core.addDays(start, 1);\n            return { start: start, end: end };\n        };\n        DayGrid.prototype.updateSegPopoverTile = function (date, segs) {\n            var ownProps = this.props;\n            this.segPopoverTile.receiveProps({\n                date: date || this.segPopoverTile.props.date,\n                fgSegs: segs || this.segPopoverTile.props.fgSegs,\n                eventSelection: ownProps.eventSelection,\n                eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,\n                eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null\n            });\n        };\n        /* Date Rendering\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype._renderCells = function (cells, isRigid) {\n            var _a = this, view = _a.view, dateEnv = _a.dateEnv;\n            var _b = this, rowCnt = _b.rowCnt, colCnt = _b.colCnt;\n            var html = '';\n            var row;\n            var col;\n            for (row = 0; row < rowCnt; row++) {\n                html += this.renderDayRowHtml(row, isRigid);\n            }\n            this.el.innerHTML = html;\n            this.rowEls = core.findElements(this.el, '.fc-row');\n            this.cellEls = core.findElements(this.el, '.fc-day, .fc-disabled-day');\n            if (this.isRtl) {\n                this.cellEls.reverse();\n            }\n            this.rowPositions = new core.PositionCache(this.el, this.rowEls, false, true // vertical\n            );\n            this.colPositions = new core.PositionCache(this.el, this.cellEls.slice(0, colCnt), // only the first row\n            true, false // horizontal\n            );\n            // trigger dayRender with each cell's element\n            for (row = 0; row < rowCnt; row++) {\n                for (col = 0; col < colCnt; col++) {\n                    this.publiclyTrigger('dayRender', [\n                        {\n                            date: dateEnv.toDate(cells[row][col].date),\n                            el: this.getCellEl(row, col),\n                            view: view\n                        }\n                    ]);\n                }\n            }\n            this.isCellSizesDirty = true;\n        };\n        DayGrid.prototype._unrenderCells = function () {\n            this.removeSegPopover();\n        };\n        // Generates the HTML for a single row, which is a div that wraps a table.\n        // `row` is the row number.\n        DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\n            var theme = this.theme;\n            var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\n            if (isRigid) {\n                classes.push('fc-rigid');\n            }\n            var bgRow = new DayBgRow(this.context);\n            return '' +\n                '<div class=\"' + classes.join(' ') + '\">' +\n                '<div class=\"fc-bg\">' +\n                '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                bgRow.renderHtml({\n                    cells: this.props.cells[row],\n                    dateProfile: this.props.dateProfile,\n                    renderIntroHtml: this.renderProps.renderBgIntroHtml\n                }) +\n                '</table>' +\n                '</div>' +\n                '<div class=\"fc-content-skeleton\">' +\n                '<table>' +\n                (this.getIsNumbersVisible() ?\n                    '<thead>' +\n                        this.renderNumberTrHtml(row) +\n                        '</thead>' :\n                    '') +\n                '</table>' +\n                '</div>' +\n                '</div>';\n        };\n        DayGrid.prototype.getIsNumbersVisible = function () {\n            return this.getIsDayNumbersVisible() ||\n                this.renderProps.cellWeekNumbersVisible ||\n                this.renderProps.colWeekNumbersVisible;\n        };\n        DayGrid.prototype.getIsDayNumbersVisible = function () {\n            return this.rowCnt > 1;\n        };\n        /* Grid Number Rendering\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype.renderNumberTrHtml = function (row) {\n            var intro = this.renderProps.renderNumberIntroHtml(row, this);\n            return '' +\n                '<tr>' +\n                (this.isRtl ? '' : intro) +\n                this.renderNumberCellsHtml(row) +\n                (this.isRtl ? intro : '') +\n                '</tr>';\n        };\n        DayGrid.prototype.renderNumberCellsHtml = function (row) {\n            var htmls = [];\n            var col;\n            var date;\n            for (col = 0; col < this.colCnt; col++) {\n                date = this.props.cells[row][col].date;\n                htmls.push(this.renderNumberCellHtml(date));\n            }\n            if (this.isRtl) {\n                htmls.reverse();\n            }\n            return htmls.join('');\n        };\n        // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n        // The number row will only exist if either day numbers or week numbers are turned on.\n        DayGrid.prototype.renderNumberCellHtml = function (date) {\n            var _a = this, view = _a.view, dateEnv = _a.dateEnv;\n            var html = '';\n            var isDateValid = core.rangeContainsMarker(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n            var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\n            var classes;\n            var weekCalcFirstDow;\n            if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {\n                // no numbers in day cell (week number must be along the side)\n                return '<td></td>'; //  will create an empty space above events :(\n            }\n            classes = core.getDayClasses(date, this.props.dateProfile, this.context);\n            classes.unshift('fc-day-top');\n            if (this.renderProps.cellWeekNumbersVisible) {\n                weekCalcFirstDow = dateEnv.weekDow;\n            }\n            html += '<td class=\"' + classes.join(' ') + '\"' +\n                (isDateValid ?\n                    ' data-date=\"' + dateEnv.formatIso(date, { omitTime: true }) + '\"' :\n                    '') +\n                '>';\n            if (this.renderProps.cellWeekNumbersVisible && (date.getUTCDay() === weekCalcFirstDow)) {\n                html += core.buildGotoAnchorHtml(view, { date: date, type: 'week' }, { 'class': 'fc-week-number' }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML\n                );\n            }\n            if (isDayNumberVisible) {\n                html += core.buildGotoAnchorHtml(view, date, { 'class': 'fc-day-number' }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML\n                );\n            }\n            html += '</td>';\n            return html;\n        };\n        /* Sizing\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype.updateSize = function (isResize) {\n            var _a = this, fillRenderer = _a.fillRenderer, eventRenderer = _a.eventRenderer, mirrorRenderer = _a.mirrorRenderer;\n            if (isResize ||\n                this.isCellSizesDirty ||\n                this.view.calendar.isEventsUpdated // hack\n            ) {\n                this.buildPositionCaches();\n                this.isCellSizesDirty = false;\n            }\n            fillRenderer.computeSizes(isResize);\n            eventRenderer.computeSizes(isResize);\n            mirrorRenderer.computeSizes(isResize);\n            fillRenderer.assignSizes(isResize);\n            eventRenderer.assignSizes(isResize);\n            mirrorRenderer.assignSizes(isResize);\n        };\n        DayGrid.prototype.buildPositionCaches = function () {\n            this.buildColPositions();\n            this.buildRowPositions();\n        };\n        DayGrid.prototype.buildColPositions = function () {\n            this.colPositions.build();\n        };\n        DayGrid.prototype.buildRowPositions = function () {\n            this.rowPositions.build();\n            this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n        };\n        /* Hit System\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {\n            var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;\n            var col = colPositions.leftToIndex(leftPosition);\n            var row = rowPositions.topToIndex(topPosition);\n            if (row != null && col != null) {\n                return {\n                    row: row,\n                    col: col,\n                    dateSpan: {\n                        range: this.getCellRange(row, col),\n                        allDay: true\n                    },\n                    dayEl: this.getCellEl(row, col),\n                    relativeRect: {\n                        left: colPositions.lefts[col],\n                        right: colPositions.rights[col],\n                        top: rowPositions.tops[row],\n                        bottom: rowPositions.bottoms[row]\n                    }\n                };\n            }\n        };\n        /* Cell System\n        ------------------------------------------------------------------------------------------------------------------*/\n        // FYI: the first column is the leftmost column, regardless of date\n        DayGrid.prototype.getCellEl = function (row, col) {\n            return this.cellEls[row * this.colCnt + col];\n        };\n        /* Event Drag Visualization\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype._renderEventDrag = function (state) {\n            if (state) {\n                this.eventRenderer.hideByHash(state.affectedInstances);\n                this.fillRenderer.renderSegs('highlight', state.segs);\n            }\n        };\n        DayGrid.prototype._unrenderEventDrag = function (state) {\n            if (state) {\n                this.eventRenderer.showByHash(state.affectedInstances);\n                this.fillRenderer.unrender('highlight');\n            }\n        };\n        /* Event Resize Visualization\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype._renderEventResize = function (state) {\n            if (state) {\n                this.eventRenderer.hideByHash(state.affectedInstances);\n                this.fillRenderer.renderSegs('highlight', state.segs);\n                this.mirrorRenderer.renderSegs(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });\n            }\n        };\n        DayGrid.prototype._unrenderEventResize = function (state) {\n            if (state) {\n                this.eventRenderer.showByHash(state.affectedInstances);\n                this.fillRenderer.unrender('highlight');\n                this.mirrorRenderer.unrender(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });\n            }\n        };\n        /* More+ Link Popover\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGrid.prototype.removeSegPopover = function () {\n            if (this.segPopover) {\n                this.segPopover.hide(); // in handler, will call segPopover's removeElement\n            }\n        };\n        // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n        // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n        DayGrid.prototype.limitRows = function (levelLimit) {\n            var rowStructs = this.eventRenderer.rowStructs || [];\n            var row; // row #\n            var rowLevelLimit;\n            for (row = 0; row < rowStructs.length; row++) {\n                this.unlimitRow(row);\n                if (!levelLimit) {\n                    rowLevelLimit = false;\n                }\n                else if (typeof levelLimit === 'number') {\n                    rowLevelLimit = levelLimit;\n                }\n                else {\n                    rowLevelLimit = this.computeRowLevelLimit(row);\n                }\n                if (rowLevelLimit !== false) {\n                    this.limitRow(row, rowLevelLimit);\n                }\n            }\n        };\n        // Computes the number of levels a row will accomodate without going outside its bounds.\n        // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n        // `row` is the row number.\n        DayGrid.prototype.computeRowLevelLimit = function (row) {\n            var rowEl = this.rowEls[row]; // the containing \"fake\" row div\n            var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!\n            var trEls = core.findChildren(this.eventRenderer.rowStructs[row].tbodyEl);\n            var i;\n            var trEl;\n            // Reveal one level <tr> at a time and stop when we find one out of bounds\n            for (i = 0; i < trEls.length; i++) {\n                trEl = trEls[i];\n                trEl.classList.remove('fc-limited'); // reset to original state (reveal)\n                if (trEl.getBoundingClientRect().bottom > rowBottom) {\n                    return i;\n                }\n            }\n            return false; // should not limit at all\n        };\n        // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n        // `row` is the row number.\n        // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n        DayGrid.prototype.limitRow = function (row, levelLimit) {\n            var _this = this;\n            var _a = this, colCnt = _a.colCnt, isRtl = _a.isRtl;\n            var rowStruct = this.eventRenderer.rowStructs[row];\n            var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n            var col = 0; // col #, left-to-right (not chronologically)\n            var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n            var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row\n            var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n            var i;\n            var seg;\n            var segsBelow; // array of segment objects below `seg` in the current `col`\n            var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n            var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n            var td;\n            var rowSpan;\n            var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n            var j;\n            var moreTd;\n            var moreWrap;\n            var moreLink;\n            // Iterates through empty level cells and places \"more\" links inside if need be\n            var emptyCellsUntil = function (endCol) {\n                while (col < endCol) {\n                    segsBelow = _this.getCellSegs(row, col, levelLimit);\n                    if (segsBelow.length) {\n                        td = cellMatrix[levelLimit - 1][col];\n                        moreLink = _this.renderMoreLink(row, col, segsBelow);\n                        moreWrap = core.createElement('div', null, moreLink);\n                        td.appendChild(moreWrap);\n                        moreNodes.push(moreWrap);\n                    }\n                    col++;\n                }\n            };\n            if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?\n                levelSegs = rowStruct.segLevels[levelLimit - 1];\n                cellMatrix = rowStruct.cellMatrix;\n                limitedNodes = core.findChildren(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit\n                limitedNodes.forEach(function (node) {\n                    node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array\n                });\n                // iterate though segments in the last allowable level\n                for (i = 0; i < levelSegs.length; i++) {\n                    seg = levelSegs[i];\n                    var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;\n                    var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;\n                    emptyCellsUntil(leftCol); // process empty cells before the segment\n                    // determine *all* segments below `seg` that occupy the same columns\n                    colSegsBelow = [];\n                    totalSegsBelow = 0;\n                    while (col <= rightCol) {\n                        segsBelow = this.getCellSegs(row, col, levelLimit);\n                        colSegsBelow.push(segsBelow);\n                        totalSegsBelow += segsBelow.length;\n                        col++;\n                    }\n                    if (totalSegsBelow) { // do we need to replace this segment with one or many \"more\" links?\n                        td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell\n                        rowSpan = td.rowSpan || 1;\n                        segMoreNodes = [];\n                        // make a replacement <td> for each column the segment occupies. will be one for each colspan\n                        for (j = 0; j < colSegsBelow.length; j++) {\n                            moreTd = core.createElement('td', { className: 'fc-more-cell', rowSpan: rowSpan });\n                            segsBelow = colSegsBelow[j];\n                            moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\n                            );\n                            moreWrap = core.createElement('div', null, moreLink);\n                            moreTd.appendChild(moreWrap);\n                            segMoreNodes.push(moreTd);\n                            moreNodes.push(moreTd);\n                        }\n                        td.classList.add('fc-limited');\n                        core.insertAfterElement(td, segMoreNodes);\n                        limitedNodes.push(td);\n                    }\n                }\n                emptyCellsUntil(this.colCnt); // finish off the level\n                rowStruct.moreEls = moreNodes; // for easy undoing later\n                rowStruct.limitedEls = limitedNodes; // for easy undoing later\n            }\n        };\n        // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n        // `row` is a row number.\n        DayGrid.prototype.unlimitRow = function (row) {\n            var rowStruct = this.eventRenderer.rowStructs[row];\n            if (rowStruct.moreEls) {\n                rowStruct.moreEls.forEach(core.removeElement);\n                rowStruct.moreEls = null;\n            }\n            if (rowStruct.limitedEls) {\n                rowStruct.limitedEls.forEach(function (limitedEl) {\n                    limitedEl.classList.remove('fc-limited');\n                });\n                rowStruct.limitedEls = null;\n            }\n        };\n        // Renders an <a> element that represents hidden event element for a cell.\n        // Responsible for attaching click handler as well.\n        DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\n            var _this = this;\n            var _a = this, view = _a.view, dateEnv = _a.dateEnv;\n            var a = core.createElement('a', { className: 'fc-more' });\n            a.innerText = this.getMoreLinkText(hiddenSegs.length);\n            a.addEventListener('click', function (ev) {\n                var clickOption = _this.opt('eventLimitClick');\n                var _col = _this.isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n                var date = _this.props.cells[row][_col].date;\n                var moreEl = ev.currentTarget;\n                var dayEl = _this.getCellEl(row, col);\n                var allSegs = _this.getCellSegs(row, col);\n                // rescope the segments to be within the cell's date\n                var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n                var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n                if (typeof clickOption === 'function') {\n                    // the returned value can be an atomic option\n                    clickOption = _this.publiclyTrigger('eventLimitClick', [\n                        {\n                            date: dateEnv.toDate(date),\n                            allDay: true,\n                            dayEl: dayEl,\n                            moreEl: moreEl,\n                            segs: reslicedAllSegs,\n                            hiddenSegs: reslicedHiddenSegs,\n                            jsEvent: ev,\n                            view: view\n                        }\n                    ]);\n                }\n                if (clickOption === 'popover') {\n                    _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n                }\n                else if (typeof clickOption === 'string') { // a view name\n                    view.calendar.zoomTo(date, clickOption);\n                }\n            });\n            return a;\n        };\n        // Reveals the popover that displays all events within a cell\n        DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\n            var _this = this;\n            var _a = this, calendar = _a.calendar, view = _a.view, theme = _a.theme;\n            var _col = this.isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n            var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>\n            var topEl; // the element we want to match the top coordinate of\n            var options;\n            if (this.rowCnt === 1) {\n                topEl = view.el; // will cause the popover to cover any sort of header\n            }\n            else {\n                topEl = this.rowEls[row]; // will align with top of row\n            }\n            options = {\n                className: 'fc-more-popover ' + theme.getClass('popover'),\n                parentEl: view.el,\n                top: core.computeRect(topEl).top,\n                autoHide: true,\n                content: function (el) {\n                    _this.segPopoverTile = new DayTile(_this.context, el);\n                    _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);\n                },\n                hide: function () {\n                    _this.segPopoverTile.destroy();\n                    _this.segPopoverTile = null;\n                    _this.segPopover.destroy();\n                    _this.segPopover = null;\n                }\n            };\n            // Determine horizontal coordinate.\n            // We use the moreWrap instead of the <td> to avoid border confusion.\n            if (this.isRtl) {\n                options.right = core.computeRect(moreWrap).right + 1; // +1 to be over cell border\n            }\n            else {\n                options.left = core.computeRect(moreWrap).left - 1; // -1 to be over cell border\n            }\n            this.segPopover = new Popover(options);\n            this.segPopover.show();\n            calendar.releaseAfterSizingTriggers(); // hack for eventPositioned\n        };\n        // Given the events within an array of segment objects, reslice them to be in a single day\n        DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\n            var dayStart = dayDate;\n            var dayEnd = core.addDays(dayStart, 1);\n            var dayRange = { start: dayStart, end: dayEnd };\n            var newSegs = [];\n            for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                var seg = segs_1[_i];\n                var eventRange = seg.eventRange;\n                var origRange = eventRange.range;\n                var slicedRange = core.intersectRanges(origRange, dayRange);\n                if (slicedRange) {\n                    newSegs.push(__assign({}, seg, { eventRange: {\n                            def: eventRange.def,\n                            ui: __assign({}, eventRange.ui, { durationEditable: false }),\n                            instance: eventRange.instance,\n                            range: slicedRange\n                        }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() }));\n                }\n            }\n            return newSegs;\n        };\n        // Generates the text that should be inside a \"more\" link, given the number of events it represents\n        DayGrid.prototype.getMoreLinkText = function (num) {\n            var opt = this.opt('eventLimitText');\n            if (typeof opt === 'function') {\n                return opt(num);\n            }\n            else {\n                return '+' + num + ' ' + opt;\n            }\n        };\n        // Returns segments within a given cell.\n        // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n        DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\n            var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\n            var level = startLevel || 0;\n            var segs = [];\n            var seg;\n            while (level < segMatrix.length) {\n                seg = segMatrix[level][col];\n                if (seg) {\n                    segs.push(seg);\n                }\n                level++;\n            }\n            return segs;\n        };\n        return DayGrid;\n    }(core.DateComponent));\n\n    var WEEK_NUM_FORMAT$1 = core.createFormatter({ week: 'numeric' });\n    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n    // It is responsible for managing width/height.\n    var DayGridView = /** @class */ (function (_super) {\n        __extends(DayGridView, _super);\n        function DayGridView(context, viewSpec, dateProfileGenerator, parentEl) {\n            var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;\n            /* Header Rendering\n            ------------------------------------------------------------------------------------------------------------------*/\n            // Generates the HTML that will go before the day-of week header cells\n            _this.renderHeadIntroHtml = function () {\n                var theme = _this.theme;\n                if (_this.colWeekNumbersVisible) {\n                    return '' +\n                        '<th class=\"fc-week-number ' + theme.getClass('widgetHeader') + '\" ' + _this.weekNumberStyleAttr() + '>' +\n                        '<span>' + // needed for matchCellWidths\n                        core.htmlEscape(_this.opt('weekLabel')) +\n                        '</span>' +\n                        '</th>';\n                }\n                return '';\n            };\n            /* Day Grid Rendering\n            ------------------------------------------------------------------------------------------------------------------*/\n            // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n            _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {\n                var dateEnv = _this.dateEnv;\n                var weekStart = dayGrid.props.cells[row][0].date;\n                if (_this.colWeekNumbersVisible) {\n                    return '' +\n                        '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '>' +\n                        core.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\n                        _this, { date: weekStart, type: 'week', forceOff: dayGrid.colCnt === 1 }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML\n                        ) +\n                        '</td>';\n                }\n                return '';\n            };\n            // Generates the HTML that goes before the day bg cells for each day-row\n            _this.renderDayGridBgIntroHtml = function () {\n                var theme = _this.theme;\n                if (_this.colWeekNumbersVisible) {\n                    return '<td class=\"fc-week-number ' + theme.getClass('widgetContent') + '\" ' + _this.weekNumberStyleAttr() + '></td>';\n                }\n                return '';\n            };\n            // Generates the HTML that goes before every other type of row generated by DayGrid.\n            // Affects mirror-skeleton and highlight-skeleton rows.\n            _this.renderDayGridIntroHtml = function () {\n                if (_this.colWeekNumbersVisible) {\n                    return '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '></td>';\n                }\n                return '';\n            };\n            _this.el.classList.add('fc-dayGrid-view');\n            _this.el.innerHTML = _this.renderSkeletonHtml();\n            _this.scroller = new core.ScrollComponent('hidden', // overflow x\n            'auto' // overflow y\n            );\n            var dayGridContainerEl = _this.scroller.el;\n            _this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);\n            dayGridContainerEl.classList.add('fc-day-grid-container');\n            var dayGridEl = core.createElement('div', { className: 'fc-day-grid' });\n            dayGridContainerEl.appendChild(dayGridEl);\n            var cellWeekNumbersVisible;\n            if (_this.opt('weekNumbers')) {\n                if (_this.opt('weekNumbersWithinDays')) {\n                    cellWeekNumbersVisible = true;\n                    _this.colWeekNumbersVisible = false;\n                }\n                else {\n                    cellWeekNumbersVisible = false;\n                    _this.colWeekNumbersVisible = true;\n                }\n            }\n            else {\n                _this.colWeekNumbersVisible = false;\n                cellWeekNumbersVisible = false;\n            }\n            _this.dayGrid = new DayGrid(_this.context, dayGridEl, {\n                renderNumberIntroHtml: _this.renderDayGridNumberIntroHtml,\n                renderBgIntroHtml: _this.renderDayGridBgIntroHtml,\n                renderIntroHtml: _this.renderDayGridIntroHtml,\n                colWeekNumbersVisible: _this.colWeekNumbersVisible,\n                cellWeekNumbersVisible: cellWeekNumbersVisible\n            });\n            return _this;\n        }\n        DayGridView.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this.dayGrid.destroy();\n            this.scroller.destroy();\n        };\n        // Builds the HTML skeleton for the view.\n        // The day-grid component will render inside of a container defined by this HTML.\n        DayGridView.prototype.renderSkeletonHtml = function () {\n            var theme = this.theme;\n            return '' +\n                '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                (this.opt('columnHeader') ?\n                    '<thead class=\"fc-head\">' +\n                        '<tr>' +\n                        '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\n                        '</tr>' +\n                        '</thead>' :\n                    '') +\n                '<tbody class=\"fc-body\">' +\n                '<tr>' +\n                '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' +\n                '</tr>' +\n                '</tbody>' +\n                '</table>';\n        };\n        // Generates an HTML attribute string for setting the width of the week number column, if it is known\n        DayGridView.prototype.weekNumberStyleAttr = function () {\n            if (this.weekNumberWidth != null) {\n                return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n            }\n            return '';\n        };\n        // Determines whether each row should have a constant height\n        DayGridView.prototype.hasRigidRows = function () {\n            var eventLimit = this.opt('eventLimit');\n            return eventLimit && typeof eventLimit !== 'number';\n        };\n        /* Dimensions\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n            _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first\n            this.dayGrid.updateSize(isResize);\n        };\n        // Refreshes the horizontal dimensions of the view\n        DayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n            var dayGrid = this.dayGrid;\n            var eventLimit = this.opt('eventLimit');\n            var headRowEl = this.header ? this.header.el : null; // HACK\n            var scrollerHeight;\n            var scrollbarWidths;\n            // hack to give the view some height prior to dayGrid's columns being rendered\n            // TODO: separate setting height from scroller VS dayGrid.\n            if (!dayGrid.rowEls) {\n                if (!isAuto) {\n                    scrollerHeight = this.computeScrollerHeight(viewHeight);\n                    this.scroller.setHeight(scrollerHeight);\n                }\n                return;\n            }\n            if (this.colWeekNumbersVisible) {\n                // Make sure all week number cells running down the side have the same width.\n                this.weekNumberWidth = core.matchCellWidths(core.findElements(this.el, '.fc-week-number'));\n            }\n            // reset all heights to be natural\n            this.scroller.clear();\n            if (headRowEl) {\n                core.uncompensateScroll(headRowEl);\n            }\n            dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n            // is the event limit a constant level number?\n            if (eventLimit && typeof eventLimit === 'number') {\n                dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n            }\n            // distribute the height to the rows\n            // (viewHeight is a \"recommended\" value if isAuto)\n            scrollerHeight = this.computeScrollerHeight(viewHeight);\n            this.setGridHeight(scrollerHeight, isAuto);\n            // is the event limit dynamically calculated?\n            if (eventLimit && typeof eventLimit !== 'number') {\n                dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n            }\n            if (!isAuto) { // should we force dimensions of the scroll container?\n                this.scroller.setHeight(scrollerHeight);\n                scrollbarWidths = this.scroller.getScrollbarWidths();\n                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\n                    if (headRowEl) {\n                        core.compensateScroll(headRowEl, scrollbarWidths);\n                    }\n                    // doing the scrollbar compensation might have created text overflow which created more height. redo\n                    scrollerHeight = this.computeScrollerHeight(viewHeight);\n                    this.scroller.setHeight(scrollerHeight);\n                }\n                // guarantees the same scrollbar widths\n                this.scroller.lockOverflow(scrollbarWidths);\n            }\n        };\n        // given a desired total height of the view, returns what the height of the scroller should be\n        DayGridView.prototype.computeScrollerHeight = function (viewHeight) {\n            return viewHeight -\n                core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n        };\n        // Sets the height of just the DayGrid component in this view\n        DayGridView.prototype.setGridHeight = function (height, isAuto) {\n            if (this.opt('monthMode')) {\n                // if auto, make the height of each row the height that it would be if there were 6 weeks\n                if (isAuto) {\n                    height *= this.dayGrid.rowCnt / 6;\n                }\n                core.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n            }\n            else {\n                if (isAuto) {\n                    core.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n                }\n                else {\n                    core.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n                }\n            }\n        };\n        /* Scroll\n        ------------------------------------------------------------------------------------------------------------------*/\n        DayGridView.prototype.computeDateScroll = function (timeMs) {\n            return { top: 0 };\n        };\n        DayGridView.prototype.queryDateScroll = function () {\n            return { top: this.scroller.getScrollTop() };\n        };\n        DayGridView.prototype.applyDateScroll = function (scroll) {\n            if (scroll.top !== undefined) {\n                this.scroller.setScrollTop(scroll.top);\n            }\n        };\n        return DayGridView;\n    }(core.View));\n    DayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;\n\n    var SimpleDayGrid = /** @class */ (function (_super) {\n        __extends(SimpleDayGrid, _super);\n        function SimpleDayGrid(context, dayGrid) {\n            var _this = _super.call(this, context, dayGrid.el) || this;\n            _this.slicer = new DayGridSlicer();\n            _this.dayGrid = dayGrid;\n            context.calendar.registerInteractiveComponent(_this, { el: _this.dayGrid.el });\n            return _this;\n        }\n        SimpleDayGrid.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            this.calendar.unregisterInteractiveComponent(this);\n        };\n        SimpleDayGrid.prototype.render = function (props) {\n            var dayGrid = this.dayGrid;\n            var dateProfile = props.dateProfile, dayTable = props.dayTable;\n            dayGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, dayGrid, dayTable), { dateProfile: dateProfile, cells: dayTable.cells, isRigid: props.isRigid }));\n        };\n        SimpleDayGrid.prototype.buildPositionCaches = function () {\n            this.dayGrid.buildPositionCaches();\n        };\n        SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {\n            var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);\n            if (rawHit) {\n                return {\n                    component: this.dayGrid,\n                    dateSpan: rawHit.dateSpan,\n                    dayEl: rawHit.dayEl,\n                    rect: {\n                        left: rawHit.relativeRect.left,\n                        right: rawHit.relativeRect.right,\n                        top: rawHit.relativeRect.top,\n                        bottom: rawHit.relativeRect.bottom\n                    },\n                    layer: 0\n                };\n            }\n        };\n        return SimpleDayGrid;\n    }(core.DateComponent));\n    var DayGridSlicer = /** @class */ (function (_super) {\n        __extends(DayGridSlicer, _super);\n        function DayGridSlicer() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {\n            return dayTable.sliceRange(dateRange);\n        };\n        return DayGridSlicer;\n    }(core.Slicer));\n\n    var DayGridView$1 = /** @class */ (function (_super) {\n        __extends(DayGridView, _super);\n        function DayGridView(_context, viewSpec, dateProfileGenerator, parentEl) {\n            var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;\n            _this.buildDayTable = core.memoize(buildDayTable);\n            if (_this.opt('columnHeader')) {\n                _this.header = new core.DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));\n            }\n            _this.simpleDayGrid = new SimpleDayGrid(_this.context, _this.dayGrid);\n            return _this;\n        }\n        DayGridView.prototype.destroy = function () {\n            _super.prototype.destroy.call(this);\n            if (this.header) {\n                this.header.destroy();\n            }\n            this.simpleDayGrid.destroy();\n        };\n        DayGridView.prototype.render = function (props) {\n            _super.prototype.render.call(this, props);\n            var dateProfile = this.props.dateProfile;\n            var dayTable = this.dayTable =\n                this.buildDayTable(dateProfile, this.dateProfileGenerator);\n            if (this.header) {\n                this.header.receiveProps({\n                    dateProfile: dateProfile,\n                    dates: dayTable.headerDates,\n                    datesRepDistinctDays: dayTable.rowCnt === 1,\n                    renderIntroHtml: this.renderHeadIntroHtml\n                });\n            }\n            this.simpleDayGrid.receiveProps({\n                dateProfile: dateProfile,\n                dayTable: dayTable,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                isRigid: this.hasRigidRows(),\n                nextDayThreshold: this.nextDayThreshold\n            });\n        };\n        return DayGridView;\n    }(DayGridView));\n    function buildDayTable(dateProfile, dateProfileGenerator) {\n        var daySeries = new core.DaySeries(dateProfile.renderRange, dateProfileGenerator);\n        return new core.DayTable(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n    }\n\n    var main = core.createPlugin({\n        defaultView: 'dayGridMonth',\n        views: {\n            dayGrid: DayGridView$1,\n            dayGridDay: {\n                type: 'dayGrid',\n                duration: { days: 1 }\n            },\n            dayGridWeek: {\n                type: 'dayGrid',\n                duration: { weeks: 1 }\n            },\n            dayGridMonth: {\n                type: 'dayGrid',\n                duration: { months: 1 },\n                monthMode: true,\n                fixedWeekCount: true\n            }\n        }\n    });\n\n    exports.AbstractDayGridView = DayGridView;\n    exports.DayBgRow = DayBgRow;\n    exports.DayGrid = DayGrid;\n    exports.DayGridSlicer = DayGridSlicer;\n    exports.DayGridView = DayGridView$1;\n    exports.SimpleDayGrid = SimpleDayGrid;\n    exports.buildBasicDayTable = buildDayTable;\n    exports.default = main;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanM/M2NkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHFFQUFvQjtBQUNoSCxJQUFJLFNBQ3dGO0FBQzVGLENBQUMsaUNBQWlDOztBQUVsQztBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RWhFLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciBEYXkgR3JpZCBQbHVnaW4gdjQuMS4wXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAxOSBBZGFtIFNoYXdcbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9jb3JlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BmdWxsY2FsZW5kYXIvY29yZSddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5GdWxsQ2FsZW5kYXJEYXlHcmlkID0ge30sIGdsb2JhbC5GdWxsQ2FsZW5kYXIpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGNvcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcblxuICAgIHZhciBEYXlHcmlkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEYXlHcmlkRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICAgIERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5kYXRlRW52O1xuICAgICAgICAgICAgdmFyIHJlbmRlclJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGVuZCA9IHJlbmRlclJhbmdlLmVuZDtcbiAgICAgICAgICAgIHZhciBlbmRPZldlZWs7XG4gICAgICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgICAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydCk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjb3JlLmFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9udGhNb2RlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpeGVkV2Vla0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgICAgICAgICAgY29yZS5kaWZmV2Vla3Moc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGNvcmUuYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICB9KGNvcmUuRGF0ZVByb2ZpbGVHZW5lcmF0b3IpKTtcblxuICAgIC8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgT3B0aW9uczpcbiAgICAgIC0gY2xhc3NOYW1lIChzdHJpbmcpXG4gICAgICAtIGNvbnRlbnQgKEhUTUwgc3RyaW5nLCBlbGVtZW50LCBvciBlbGVtZW50IGFycmF5KVxuICAgICAgLSBwYXJlbnRFbFxuICAgICAgLSB0b3BcbiAgICAgIC0gbGVmdFxuICAgICAgLSByaWdodCAodGhlIHggY29vcmQgb2Ygd2hlcmUgdGhlIHJpZ2h0IGVkZ2Ugc2hvdWxkIGJlLiBub3QgYSBcIkNTU1wiIHJpZ2h0KVxuICAgICAgLSBhdXRvSGlkZSAoYm9vbGVhbilcbiAgICAgIC0gc2hvdyAoY2FsbGJhY2spXG4gICAgICAtIGhpZGUgKGNhbGxiYWNrKVxuICAgICovXG4gICAgdmFyIFBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBvcG92ZXIob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXJnaW4gPSAxMDsgLy8gdGhlIHNwYWNlIHJlcXVpcmVkIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lclxuICAgICAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZWwgJiYgIV90aGlzLmVsLmNvbnRhaW5zKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlcyBgdGhpcy5lbGAgYW5kIHJlbmRlcnMgY29udGVudCBpbnNpZGUgb2YgaXRcbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXIgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyksXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcwJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAvLyB3aGVuIGEgY2xpY2sgaGFwcGVucyBvbiBhbnl0aGluZyBpbnNpZGUgd2l0aCBhICdmYy1jbG9zZScgY2xhc3NOYW1lLCBoaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICBjb3JlLmxpc3RlbkJ5U2VsZWN0b3IoZWwsICdjbGljaycsICcuZmMtY2xvc2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5kb2N1bWVudE1vdXNlZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEhpZGVzIGFuZCB1bnJlZ2lzdGVycyBhbnkgaGFuZGxlcnNcbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgICAgICBjb3JlLnJlbW92ZUVsZW1lbnQodGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUG9zaXRpb25zIHRoZSBwb3BvdmVyIG9wdGltYWxseSwgdXNpbmcgdGhlIHRvcC9sZWZ0L3JpZ2h0IG9wdGlvbnNcbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICB2YXIgZWxEaW1zID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIG9ubHkgdXNlZCBmb3Igd2lkdGgsaGVpZ2h0XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gY29yZS5jb21wdXRlUmVjdChlbC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgdmFyIGNsaXBwaW5nUmVjdCA9IGNvcmUuY29tcHV0ZUNsaXBwaW5nUmVjdChvcHRpb25zLnBhcmVudEVsKTtcbiAgICAgICAgICAgIHZhciB0b3A7IC8vIHRoZSBcInBvc2l0aW9uXCIgKG5vdCBcIm9mZnNldFwiKSB2YWx1ZXMgZm9yIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICB2YXIgbGVmdDsgLy9cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdG9wIGFuZCBsZWZ0XG4gICAgICAgICAgICB0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnJpZ2h0IC0gZWxEaW1zLndpZHRoOyAvLyBkZXJpdmUgdGhlIGxlZnQgdmFsdWUgZnJvbSB0aGUgcmlnaHQgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIGNsaXBwaW5nUmVjdC5ib3R0b20gLSBlbERpbXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW4pO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBjbGlwcGluZ1JlY3QudG9wICsgdGhpcy5tYXJnaW4pO1xuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGNsaXBwaW5nUmVjdC5yaWdodCAtIGVsRGltcy53aWR0aCAtIHRoaXMubWFyZ2luKTtcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBjbGlwcGluZ1JlY3QubGVmdCArIHRoaXMubWFyZ2luKTtcbiAgICAgICAgICAgIGNvcmUuYXBwbHlTdHlsZShlbCwge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wIC0gb3JpZ2luLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb3JpZ2luLmxlZnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAgICAvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXG4gICAgICAgIC8vIGNhbiBraWxsIHRoaXM/Pz9cbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9wb3ZlcjtcbiAgICB9KCkpO1xuXG4gICAgLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgLy8gXCJTaW1wbGVcIiBpcyBiYWQgYSBuYW1lLiBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNpbXBsZURheUdyaWRcbiAgICB2YXIgU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGRzIHRoZSBIVE1MIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IGVsZW1lbnQgZm9yIGFuIGluZGl2aWR1YWwgc2VnbWVudFxuICAgICAgICBTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIG1pcnJvckluZm8pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICB2YXIgZXZlbnRVaSA9IGV2ZW50UmFuZ2UudWk7XG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gZXZlbnREZWYuYWxsRGF5O1xuICAgICAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gZXZlbnRVaS5zdGFydEVkaXRhYmxlO1xuICAgICAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gYWxsRGF5ICYmIHNlZy5pc1N0YXJ0ICYmIGV2ZW50VWkuZHVyYXRpb25FZGl0YWJsZSAmJiBvcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xuICAgICAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9IGFsbERheSAmJiBzZWcuaXNFbmQgJiYgZXZlbnRVaS5kdXJhdGlvbkVkaXRhYmxlO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kLCBtaXJyb3JJbmZvKTtcbiAgICAgICAgICAgIHZhciBza2luQ3NzID0gY29yZS5jc3NUb1N0cih0aGlzLmdldFNraW5Dc3MoZXZlbnRVaSkpO1xuICAgICAgICAgICAgdmFyIHRpbWVIdG1sID0gJyc7XG4gICAgICAgICAgICB2YXIgdGltZVRleHQ7XG4gICAgICAgICAgICB2YXIgdGl0bGVIdG1sO1xuICAgICAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktZ3JpZC1ldmVudCcsICdmYy1oLWV2ZW50Jyk7XG4gICAgICAgICAgICAvLyBPbmx5IGRpc3BsYXkgYSB0aW1lZCBldmVudHMgdGltZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmcgc2VnbWVudFxuICAgICAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KGV2ZW50UmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgY29yZS5odG1sRXNjYXBlKHRpbWVUZXh0KSArICc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aXRsZUh0bWwgPVxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXG4gICAgICAgICAgICAgICAgICAgIChjb3JlLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPic7XG4gICAgICAgICAgICByZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG4gICAgICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XG4gICAgICAgICAgICAgICAgICAgICcgaHJlZj1cIicgKyBjb3JlLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxuICAgICAgICAgICAgICAgICAgICAnJykgK1xuICAgICAgICAgICAgICAgIChza2luQ3NzID9cbiAgICAgICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAgICAgJz4nICtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5kaXIgPT09ICdydGwnID9cbiAgICAgICAgICAgICAgICAgICAgdGl0bGVIdG1sICsgJyAnICsgdGltZUh0bWwgOiAvLyBwdXQgYSBuYXR1cmFsIHNwYWNlIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgdGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgLy9cbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIj48L2Rpdj4nIDpcbiAgICAgICAgICAgICAgICAgICAgJycpICtcbiAgICAgICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tRW5kID9cbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCI+PC9kaXY+JyA6XG4gICAgICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAgICAgJzwvYT4nO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgZXZlbnRUaW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICAgIFNpbXBsZURheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgICAgICAgICAgICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVyaWRpZW06ICduYXJyb3cnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gVE9ETzogc29tZWhvdyBjb25zaWRlciB0aGUgb3JpZ2luYXRpbmcgRGF5R3JpZCdzIGNvbHVtbiBjb3VudFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXI7XG4gICAgfShjb3JlLkZnRXZlbnRSZW5kZXJlcikpO1xuXG4gICAgLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgdmFyIERheUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRFdmVudFJlbmRlcmVyKGRheUdyaWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRheUdyaWQuY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmRheUdyaWQgPSBkYXlHcmlkO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmRlcnMgdGhlIGdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxuICAgICAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBtaXJyb3JJbmZvKSB7XG4gICAgICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yb3dFbHMuZm9yRWFjaChmdW5jdGlvbiAocm93Tm9kZSwgaSkge1xuICAgICAgICAgICAgICAgIHJvd05vZGUucXVlcnlTZWxlY3RvcignLmZjLWNvbnRlbnQtc2tlbGV0b24gPiB0YWJsZScpLmFwcGVuZENoaWxkKHJvd1N0cnVjdHNbaV0udGJvZHlFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcbiAgICAgICAgICAgIGlmICghbWlycm9ySW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHNcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFNlZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyB8fCBbXTtcbiAgICAgICAgICAgIHZhciByb3dTdHJ1Y3Q7XG4gICAgICAgICAgICB3aGlsZSAoKHJvd1N0cnVjdCA9IHJvd1N0cnVjdHMucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgY29yZS5yZW1vdmVFbGVtZW50KHJvd1N0cnVjdC50Ym9keUVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93U3RydWN0cyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFVzZXMgdGhlIGdpdmVuIGV2ZW50cyBhcnJheSB0byBnZW5lcmF0ZSA8dGJvZHk+IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvbi5cbiAgICAgICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiByb3dTdHJ1Y3Qgb2JqZWN0cyAoc2VlIHRoZSBib3R0b20gb2YgYHJlbmRlclNlZ1Jvd2ApLlxuICAgICAgICAvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzZWdSb3dzO1xuICAgICAgICAgICAgdmFyIHJvdztcbiAgICAgICAgICAgIHNlZ1Jvd3MgPSB0aGlzLmdyb3VwU2VnUm93cyhzZWdzKTsgLy8gZ3JvdXAgaW50byBuZXN0ZWQgYXJyYXlzXG4gICAgICAgICAgICAvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXG4gICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHNlZ1Jvd3MubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIHJvd1N0cnVjdHMucHVzaCh0aGlzLnJlbmRlclNlZ1Jvdyhyb3csIHNlZ1Jvd3Nbcm93XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd1N0cnVjdHM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXG4gICAgICAgIC8vIHRoZSBzZWdtZW50cy4gUmV0dXJucyBvYmplY3Qgd2l0aCBhIGJ1bmNoIG9mIGludGVybmFsIGRhdGEgYWJvdXQgaG93IHRoZSByZW5kZXIgd2FzIGNhbGN1bGF0ZWQuXG4gICAgICAgIC8vIE5PVEU6IG1vZGlmaWVzIHJvd1NlZ3NcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1JvdyA9IGZ1bmN0aW9uIChyb3csIHJvd1NlZ3MpIHtcbiAgICAgICAgICAgIHZhciBkYXlHcmlkID0gdGhpcy5kYXlHcmlkO1xuICAgICAgICAgICAgdmFyIGNvbENudCA9IGRheUdyaWQuY29sQ250LCBpc1J0bCA9IGRheUdyaWQuaXNSdGw7XG4gICAgICAgICAgICB2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xuICAgICAgICAgICAgdmFyIGxldmVsQ250ID0gTWF0aC5tYXgoMSwgc2VnTGV2ZWxzLmxlbmd0aCk7IC8vIGVuc3VyZSBhdCBsZWFzdCBvbmUgbGV2ZWxcbiAgICAgICAgICAgIHZhciB0Ym9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgICAgICB2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXG4gICAgICAgICAgICB2YXIgY2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIGFsbCA8dGQ+IGVsZW1lbnRzIG9mIHRoZSBsZXZlbCtjb2wgbWF0cml4XG4gICAgICAgICAgICB2YXIgbG9uZUNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciA8dGQ+IGVsZW1lbnRzIHRoYXQgb25seSB0YWtlIHVwIGEgc2luZ2xlIGNvbHVtblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGV2ZWxTZWdzO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIHZhciB0cjtcbiAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgdmFyIHNlZztcbiAgICAgICAgICAgIHZhciB0ZDtcbiAgICAgICAgICAgIC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXG4gICAgICAgICAgICBmdW5jdGlvbiBlbXB0eUNlbGxzVW50aWwoZW5kQ29sKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXG4gICAgICAgICAgICAgICAgICAgIHRkID0gKGxvbmVDZWxsTWF0cml4W2kgLSAxXSB8fCBbXSlbY29sXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5yb3dTcGFuID0gKHRkLnJvd1NwYW4gfHwgMSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuICAgICAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbENudDsgaSsrKSB7IC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgbGV2ZWxzXG4gICAgICAgICAgICAgICAgbGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xuICAgICAgICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgICAgICAgICAgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgIHNlZ01hdHJpeC5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4LnB1c2goW10pO1xuICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4LnB1c2goW10pO1xuICAgICAgICAgICAgICAgIC8vIGxldmVsQ250IG1pZ2h0IGJlIDEgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGFjdHVhbCBsZXZlbHMuIHByb3RlY3QgYWdhaW5zdCB0aGlzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsU2Vncykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaisrKSB7IC8vIGl0ZXJhdGUgdGhyb3VnaCBzZWdtZW50cyBpbiBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRDb2wgPSBpc1J0bCA/IChjb2xDbnQgLSAxIC0gc2VnLmxhc3RDb2wpIDogc2VnLmZpcnN0Q29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbChsZWZ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IG9jY3VwaWVzIG9yIG1vcmUgY29sdW1ucy4gYXBwZW5kIHRoZSBldmVudCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ3RkJywgeyBjbGFzc05hbWU6ICdmYy1ldmVudC1jb250YWluZXInIH0sIHNlZy5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdENvbCAhPT0gcmlnaHRDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZC5jb2xTcGFuID0gcmlnaHRDb2wgLSBsZWZ0Q29sICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhIHNpbmdsZS1jb2x1bW4gc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPD0gcmlnaHRDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNYXRyaXhbaV1bY29sXSA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XG4gICAgICAgICAgICAgICAgdmFyIGludHJvSHRtbCA9IGRheUdyaWQucmVuZGVyUHJvcHMucmVuZGVySW50cm9IdG1sKCk7XG4gICAgICAgICAgICAgICAgaWYgKGludHJvSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF5R3JpZC5pc1J0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5hcHBlbmRUb0VsZW1lbnQodHIsIGludHJvSHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnByZXBlbmRUb0VsZW1lbnQodHIsIGludHJvSHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGJvZHkuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICB0Ym9keUVsOiB0Ym9keSxcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4OiBjZWxsTWF0cml4LFxuICAgICAgICAgICAgICAgIHNlZ01hdHJpeDogc2VnTWF0cml4LFxuICAgICAgICAgICAgICAgIHNlZ0xldmVsczogc2VnTGV2ZWxzLFxuICAgICAgICAgICAgICAgIHNlZ3M6IHJvd1NlZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YWNrcyBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHdoaWNoIGFyZSBhbGwgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3csIGludG8gc3ViYXJyYXlzIG9mIHZlcnRpY2FsIGxldmVscy5cbiAgICAgICAgLy8gTk9URTogbW9kaWZpZXMgc2Vnc1xuICAgICAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRTZWdMZXZlbHMgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5kYXlHcmlkLCBpc1J0bCA9IF9hLmlzUnRsLCBjb2xDbnQgPSBfYS5jb2xDbnQ7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBzZWc7XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIC8vIEdpdmUgcHJlZmVyZW5jZSB0byBlbGVtZW50cyB3aXRoIGNlcnRhaW4gY3JpdGVyaWEsIHNvIHRoZXkgaGF2ZVxuICAgICAgICAgICAgLy8gYSBjaGFuY2UgdG8gYmUgY2xvc2VyIHRvIHRoZSB0b3AuXG4gICAgICAgICAgICBzZWdzID0gdGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlIHRvcG1vc3QsIHVudGlsIHRoZSBzZWdtZW50IGRvZXNuJ3QgY29sbGlkZSB3aXRoIG90aGVyIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGF5U2VnQ29sbGlzaW9uKHNlZywgbGV2ZWxzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYGpgIG5vdyBob2xkcyB0aGUgZGVzaXJlZCBzdWJyb3cgaW5kZXhcbiAgICAgICAgICAgICAgICBzZWcubGV2ZWwgPSBqO1xuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDsgLy8gZm9yIHNvcnRpbmcgb25seVxuICAgICAgICAgICAgICAgIHNlZy5yaWdodENvbCA9IGlzUnRsID8gKGNvbENudCAtIDEgLSBzZWcuZmlyc3RDb2wpIDogc2VnLmxhc3RDb2wgLy8gZm9yIHNvcnRpbmcgb25seVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldmVsc1tqXS5zb3J0KGNvbXBhcmVEYXlTZWdDb2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XG4gICAgICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5ncm91cFNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgdmFyIHNlZ1Jvd3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF5R3JpZC5yb3dDbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlZ1Jvd3MucHVzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlZ1Jvd3Nbc2Vnc1tpXS5yb3ddLnB1c2goc2Vnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VnUm93cztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXlHcmlkLmNvbENudCA9PT0gMTsgLy8gd2UnbGwgbGlrZWx5IGhhdmUgc3BhY2UgaWYgdGhlcmUncyBvbmx5IG9uZSBkYXlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWRFdmVudFJlbmRlcmVyO1xuICAgIH0oU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIpKTtcbiAgICAvLyBDb21wdXRlcyB3aGV0aGVyIHR3byBzZWdtZW50cycgY29sdW1ucyBjb2xsaWRlLiBUaGV5IGFyZSBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdy5cbiAgICBmdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG90aGVyU2VnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdGhlclNlZyA9IG90aGVyU2Vnc1tpXTtcbiAgICAgICAgICAgIGlmIChvdGhlclNlZy5maXJzdENvbCA8PSBzZWcubGFzdENvbCAmJlxuICAgICAgICAgICAgICAgIG90aGVyU2VnLmxhc3RDb2wgPj0gc2VnLmZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XG4gICAgZnVuY3Rpb24gY29tcGFyZURheVNlZ0NvbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5sZWZ0Q29sIC0gYi5sZWZ0Q29sO1xuICAgIH1cblxuICAgIHZhciBEYXlHcmlkTWlycm9yUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEYXlHcmlkTWlycm9yUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRNaXJyb3JSZW5kZXJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBEYXlHcmlkTWlycm9yUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2VncywgbWlycm9ySW5mbykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVNlZyA9IG1pcnJvckluZm8uc291cmNlU2VnO1xuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XG4gICAgICAgICAgICAvLyBpbmplY3QgZWFjaCBuZXcgZXZlbnQgc2tlbGV0b24gaW50byBlYWNoIGFzc29jaWF0ZWQgcm93XG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucm93RWxzLmZvckVhY2goZnVuY3Rpb24gKHJvd05vZGUsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbkVsID0gY29yZS5odG1sVG9FbGVtZW50KCc8ZGl2IGNsYXNzPVwiZmMtbWlycm9yLXNrZWxldG9uXCI+PHRhYmxlPjwvdGFibGU+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXG4gICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wRWw7XG4gICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5yb3cgPT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgICBza2VsZXRvblRvcEVsID0gc291cmNlU2VnLmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHJvd05vZGUucXVlcnlTZWxlY3RvcignLmZjLWNvbnRlbnQtc2tlbGV0b24gdGJvZHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsKSB7IC8vIHdoZW4gbm8gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBza2VsZXRvblRvcEVsID0gcm93Tm9kZS5xdWVyeVNlbGVjdG9yKCcuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wID0gc2tlbGV0b25Ub3BFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLVxuICAgICAgICAgICAgICAgICAgICByb3dOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDsgLy8gdGhlIG9mZnNldFBhcmVudCBvcmlnaW5cbiAgICAgICAgICAgICAgICBza2VsZXRvbkVsLnN0eWxlLnRvcCA9IHNrZWxldG9uVG9wICsgJ3B4JztcbiAgICAgICAgICAgICAgICBza2VsZXRvbkVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuYXBwZW5kQ2hpbGQocm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xuICAgICAgICAgICAgICAgIHJvd05vZGUuYXBwZW5kQ2hpbGQoc2tlbGV0b25FbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWRNaXJyb3JSZW5kZXJlcjtcbiAgICB9KERheUdyaWRFdmVudFJlbmRlcmVyKSk7XG5cbiAgICB2YXIgRGF5R3JpZEZpbGxSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRGaWxsUmVuZGVyZXIoZGF5R3JpZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF5R3JpZC5jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZmlsbFNlZ1RhZyA9ICd0ZCc7IC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gZGF5R3JpZDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHJlbmRlciB0aW1lZCBiYWNrZ3JvdW5kIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xuICAgICAgICAgICAgICAgIHNlZ3MgPSBzZWdzLmZpbHRlcihmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJTZWdzLmNhbGwodGhpcywgdHlwZSwgc2Vncyk7XG4gICAgICAgIH07XG4gICAgICAgIERheUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xuICAgICAgICAgICAgdmFyIGVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgc2VnO1xuICAgICAgICAgICAgdmFyIHNrZWxldG9uRWw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICAgICAgc2tlbGV0b25FbCA9IHRoaXMucmVuZGVyRmlsbFJvdyh0eXBlLCBzZWcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yb3dFbHNbc2VnLnJvd10uYXBwZW5kQ2hpbGQoc2tlbGV0b25FbCk7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2goc2tlbGV0b25FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgcm93IG9mIGEgZmlsbC4gUmVxdWlyZXMgdGhlIHNlZydzIGVsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGaWxsUm93ID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xuICAgICAgICAgICAgdmFyIGRheUdyaWQgPSB0aGlzLmRheUdyaWQ7XG4gICAgICAgICAgICB2YXIgY29sQ250ID0gZGF5R3JpZC5jb2xDbnQsIGlzUnRsID0gZGF5R3JpZC5pc1J0bDtcbiAgICAgICAgICAgIHZhciBsZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDtcbiAgICAgICAgICAgIHZhciByaWdodENvbCA9IGlzUnRsID8gKGNvbENudCAtIDEgLSBzZWcuZmlyc3RDb2wpIDogc2VnLmxhc3RDb2w7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2wgPSBsZWZ0Q29sO1xuICAgICAgICAgICAgdmFyIGVuZENvbCA9IHJpZ2h0Q29sICsgMTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgICAgICB2YXIgc2tlbGV0b25FbDtcbiAgICAgICAgICAgIHZhciB0ckVsO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdiZ2V2ZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNrZWxldG9uRWwgPSBjb3JlLmh0bWxUb0VsZW1lbnQoJzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xuICAgICAgICAgICAgICAgICc8dGFibGU+PHRyPjwvdHI+PC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+Jyk7XG4gICAgICAgICAgICB0ckVsID0gc2tlbGV0b25FbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHInKVswXTtcbiAgICAgICAgICAgIGlmIChzdGFydENvbCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGVuZFRvRWxlbWVudCh0ckVsLCBcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGNyZWF0ZSAoc3RhcnRDb2wgKyAxKSB0ZCdzXG4gICAgICAgICAgICAgICAgbmV3IEFycmF5KHN0YXJ0Q29sICsgMSkuam9pbignPHRkPjwvdGQ+JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VnLmVsLmNvbFNwYW4gPSBlbmRDb2wgLSBzdGFydENvbDtcbiAgICAgICAgICAgIHRyRWwuYXBwZW5kQ2hpbGQoc2VnLmVsKTtcbiAgICAgICAgICAgIGlmIChlbmRDb2wgPCBjb2xDbnQpIHtcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGVuZFRvRWxlbWVudCh0ckVsLCBcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGNyZWF0ZSAoY29sQ250IC0gZW5kQ29sKSB0ZCdzXG4gICAgICAgICAgICAgICAgbmV3IEFycmF5KGNvbENudCAtIGVuZENvbCArIDEpLmpvaW4oJzx0ZD48L3RkPicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnRyb0h0bWwgPSBkYXlHcmlkLnJlbmRlclByb3BzLnJlbmRlckludHJvSHRtbCgpO1xuICAgICAgICAgICAgaWYgKGludHJvSHRtbCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXlHcmlkLmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcmUuYXBwZW5kVG9FbGVtZW50KHRyRWwsIGludHJvSHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3JlLnByZXBlbmRUb0VsZW1lbnQodHJFbCwgaW50cm9IdG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2tlbGV0b25FbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWRGaWxsUmVuZGVyZXI7XG4gICAgfShjb3JlLkZpbGxSZW5kZXJlcikpO1xuXG4gICAgdmFyIERheVRpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEYXlUaWxlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEYXlUaWxlKGNvbnRleHQsIGVsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBlbCkgfHwgdGhpcztcbiAgICAgICAgICAgIHZhciBldmVudFJlbmRlcmVyID0gX3RoaXMuZXZlbnRSZW5kZXJlciA9IG5ldyBEYXlUaWxlRXZlbnRSZW5kZXJlcihfdGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRnJhbWUgPSBfdGhpcy5yZW5kZXJGcmFtZSA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5fcmVuZGVyRnJhbWUpO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRmdFdmVudHMgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZXZlbnRSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZXZlbnRSZW5kZXJlciksIGV2ZW50UmVuZGVyZXIudW5yZW5kZXIuYmluZChldmVudFJlbmRlcmVyKSwgW3JlbmRlckZyYW1lXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbiA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhldmVudFJlbmRlcmVyLnNlbGVjdEJ5SW5zdGFuY2VJZC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVuc2VsZWN0QnlJbnN0YW5jZUlkLmJpbmQoZXZlbnRSZW5kZXJlciksIFtfdGhpcy5yZW5kZXJGZ0V2ZW50c10pO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnREcmFnID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIuaGlkZUJ5SGFzaC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnNob3dCeUhhc2guYmluZChldmVudFJlbmRlcmVyKSwgW3JlbmRlckZyYW1lXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFJlc2l6ZSA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhldmVudFJlbmRlcmVyLmhpZGVCeUhhc2guYmluZChldmVudFJlbmRlcmVyKSwgZXZlbnRSZW5kZXJlci5zaG93QnlIYXNoLmJpbmQoZXZlbnRSZW5kZXJlciksIFtyZW5kZXJGcmFtZV0pO1xuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhci5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XG4gICAgICAgICAgICAgICAgZWw6IF90aGlzLmVsLFxuICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRGF5VGlsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZyYW1lKHByb3BzLmRhdGUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGZ0V2ZW50cyhwcm9wcy5mZ1NlZ3MpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbihwcm9wcy5ldmVudFNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWdJbnN0YW5jZXMpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZUluc3RhbmNlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERheVRpbGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUudW5yZW5kZXIoKTsgLy8gc2hvdWxkIHVucmVuZGVyIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIERheVRpbGUucHJvdG90eXBlLl9yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCB0aGVtZSA9IF9hLnRoZW1lLCBkYXRlRW52ID0gX2EuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGNvcmUuY3JlYXRlRm9ybWF0dGVyKHRoaXMub3B0KCdkYXlQb3BvdmVyRm9ybWF0JykpIC8vIFRPRE86IGNhY2hlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuICAgICAgICAgICAgICAgICAgICBjb3JlLmh0bWxFc2NhcGUodGl0bGUpICtcbiAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSArICdcIj48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgICAgICB0aGlzLnNlZ0NvbnRhaW5lckVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtY29udGFpbmVyJyk7XG4gICAgICAgIH07XG4gICAgICAgIERheVRpbGUucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMucHJvcHMuZGF0ZTsgLy8gSEFDS1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGNvcmUuYWRkRGF5cyhkYXRlLCAxKSB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmVsLFxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheVRpbGU7XG4gICAgfShjb3JlLkRhdGVDb21wb25lbnQpKTtcbiAgICB2YXIgRGF5VGlsZUV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEYXlUaWxlRXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGF5VGlsZUV2ZW50UmVuZGVyZXIoZGF5VGlsZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF5VGlsZS5jb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZGF5VGlsZSA9IGRheVRpbGU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRGF5VGlsZUV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRheVRpbGUuc2VnQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoc2VnLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGF5VGlsZUV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcbiAgICAgICAgICAgICAgICBjb3JlLnJlbW92ZUVsZW1lbnQoc2VnLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheVRpbGVFdmVudFJlbmRlcmVyO1xuICAgIH0oU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIpKTtcblxuICAgIHZhciBEYXlCZ1JvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGF5QmdSb3coY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBEYXlCZ1Jvdy5wcm90b3R5cGUucmVuZGVySHRtbCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcHMucmVuZGVySW50cm9IdG1sKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwcm9wcy5yZW5kZXJJbnRyb0h0bWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcHJvcHMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChyZW5kZXJDZWxsSHRtbChjZWxsLmRhdGUsIHByb3BzLmRhdGVQcm9maWxlLCB0aGlzLmNvbnRleHQsIGNlbGwuaHRtbEF0dHJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByb3BzLmNlbGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJzx0ZCBjbGFzcz1cImZjLWRheSAnICsgdGhpcy5jb250ZXh0LnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy5kaXIgPT09ICdydGwnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICc8dHI+JyArIHBhcnRzLmpvaW4oJycpICsgJzwvdHI+JztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUJnUm93O1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2VsbEh0bWwoZGF0ZSwgZGF0ZVByb2ZpbGUsIGNvbnRleHQsIG90aGVyQXR0cnMpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIHRoZW1lID0gY29udGV4dC50aGVtZTtcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gY29yZS5yYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxuICAgICAgICB2YXIgY2xhc3NlcyA9IGNvcmUuZ2V0RGF5Q2xhc3NlcyhkYXRlLCBkYXRlUHJvZmlsZSwgY29udGV4dCk7XG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5JywgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSk7XG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG4gICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGUsIHsgb21pdFRpbWU6IHRydWUgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAnJykgK1xuICAgICAgICAgICAgKG90aGVyQXR0cnMgP1xuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxuICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAnPjwvdGQ+JztcbiAgICB9XG5cbiAgICB2YXIgREFZX05VTV9GT1JNQVQgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xuICAgIHZhciBXRUVLX05VTV9GT1JNQVQgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdudW1lcmljJyB9KTtcbiAgICB2YXIgRGF5R3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERheUdyaWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWQoY29udGV4dCwgZWwsIHJlbmRlclByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBlbCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmJvdHRvbUNvb3JkUGFkZGluZyA9IDA7IC8vIGhhY2sgZm9yIGV4dGVuZGluZyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBsYXN0IHJvdyBvZiB0aGUgY29vcmRpbmF0ZSBncmlkXG4gICAgICAgICAgICBfdGhpcy5pc0NlbGxTaXplc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRSZW5kZXJlciA9IF90aGlzLmV2ZW50UmVuZGVyZXIgPSBuZXcgRGF5R3JpZEV2ZW50UmVuZGVyZXIoX3RoaXMpO1xuICAgICAgICAgICAgdmFyIGZpbGxSZW5kZXJlciA9IF90aGlzLmZpbGxSZW5kZXJlciA9IG5ldyBEYXlHcmlkRmlsbFJlbmRlcmVyKF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLm1pcnJvclJlbmRlcmVyID0gbmV3IERheUdyaWRNaXJyb3JSZW5kZXJlcihfdGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyQ2VsbHMgPSBfdGhpcy5yZW5kZXJDZWxscyA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5fcmVuZGVyQ2VsbHMsIF90aGlzLl91bnJlbmRlckNlbGxzKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1c2luZXNzSG91cnMgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MuYmluZChmaWxsUmVuZGVyZXIsICdidXNpbmVzc0hvdXJzJyksIGZpbGxSZW5kZXJlci51bnJlbmRlci5iaW5kKGZpbGxSZW5kZXJlciwgJ2J1c2luZXNzSG91cnMnKSwgW3JlbmRlckNlbGxzXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXRlU2VsZWN0aW9uID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnaGlnaGxpZ2h0JyksIGZpbGxSZW5kZXJlci51bnJlbmRlci5iaW5kKGZpbGxSZW5kZXJlciwgJ2hpZ2hsaWdodCcpLCBbcmVuZGVyQ2VsbHNdKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJnRXZlbnRzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnYmdFdmVudCcpLCBmaWxsUmVuZGVyZXIudW5yZW5kZXIuYmluZChmaWxsUmVuZGVyZXIsICdiZ0V2ZW50JyksIFtyZW5kZXJDZWxsc10pO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRmdFdmVudHMgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZXZlbnRSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZXZlbnRSZW5kZXJlciksIGV2ZW50UmVuZGVyZXIudW5yZW5kZXIuYmluZChldmVudFJlbmRlcmVyKSwgW3JlbmRlckNlbGxzXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbiA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhldmVudFJlbmRlcmVyLnNlbGVjdEJ5SW5zdGFuY2VJZC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVuc2VsZWN0QnlJbnN0YW5jZUlkLmJpbmQoZXZlbnRSZW5kZXJlciksIFtfdGhpcy5yZW5kZXJGZ0V2ZW50c10pO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnREcmFnID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKF90aGlzLl9yZW5kZXJFdmVudERyYWcsIF90aGlzLl91bnJlbmRlckV2ZW50RHJhZywgW3JlbmRlckNlbGxzXSk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFJlc2l6ZSA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5fcmVuZGVyRXZlbnRSZXNpemUsIF90aGlzLl91bnJlbmRlckV2ZW50UmVzaXplLCBbcmVuZGVyQ2VsbHNdKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlclByb3BzID0gcmVuZGVyUHJvcHM7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBwcm9wcy5jZWxscztcbiAgICAgICAgICAgIHRoaXMucm93Q250ID0gY2VsbHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jb2xDbnQgPSBjZWxsc1swXS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNlbGxzKGNlbGxzLCBwcm9wcy5pc1JpZ2lkKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnRXZlbnRzKHByb3BzLmJnRXZlbnRTZWdzKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmdFdmVudHMocHJvcHMuZmdFdmVudFNlZ3MpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbihwcm9wcy5ldmVudFNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWdQb3BvdmVyVGlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VnUG9wb3ZlclRpbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxscy51bnJlbmRlcigpOyAvLyB3aWxsIHVucmVuZGVyIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29yZS5hZGREYXlzKHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUudXBkYXRlU2VnUG9wb3ZlclRpbGUgPSBmdW5jdGlvbiAoZGF0ZSwgc2Vncykge1xuICAgICAgICAgICAgdmFyIG93blByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHRoaXMuc2VnUG9wb3ZlclRpbGUucmVjZWl2ZVByb3BzKHtcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlIHx8IHRoaXMuc2VnUG9wb3ZlclRpbGUucHJvcHMuZGF0ZSxcbiAgICAgICAgICAgICAgICBmZ1NlZ3M6IHNlZ3MgfHwgdGhpcy5zZWdQb3BvdmVyVGlsZS5wcm9wcy5mZ1NlZ3MsXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IG93blByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZ0luc3RhbmNlczogb3duUHJvcHMuZXZlbnREcmFnID8gb3duUHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZUluc3RhbmNlczogb3duUHJvcHMuZXZlbnRSZXNpemUgPyBvd25Qcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiBEYXRlIFJlbmRlcmluZ1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5fcmVuZGVyQ2VsbHMgPSBmdW5jdGlvbiAoY2VsbHMsIGlzUmlnaWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHZpZXcgPSBfYS52aWV3LCBkYXRlRW52ID0gX2EuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMsIHJvd0NudCA9IF9iLnJvd0NudCwgY29sQ250ID0gX2IuY29sQ250O1xuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgICAgIHZhciByb3c7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLnJlbmRlckRheVJvd0h0bWwocm93LCBpc1JpZ2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHRoaXMucm93RWxzID0gY29yZS5maW5kRWxlbWVudHModGhpcy5lbCwgJy5mYy1yb3cnKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVscyA9IGNvcmUuZmluZEVsZW1lbnRzKHRoaXMuZWwsICcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1J0bCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbEVscy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBjb3JlLlBvc2l0aW9uQ2FjaGUodGhpcy5lbCwgdGhpcy5yb3dFbHMsIGZhbHNlLCB0cnVlIC8vIHZlcnRpY2FsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgY29yZS5Qb3NpdGlvbkNhY2hlKHRoaXMuZWwsIHRoaXMuY2VsbEVscy5zbGljZSgwLCBjb2xDbnQpLCAvLyBvbmx5IHRoZSBmaXJzdCByb3dcbiAgICAgICAgICAgIHRydWUsIGZhbHNlIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcbiAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5UmVuZGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKGNlbGxzW3Jvd11bY29sXS5kYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0NlbGxTaXplc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuX3VucmVuZGVyQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckRheVJvd0h0bWwgPSBmdW5jdGlvbiAocm93LCBpc1JpZ2lkKSB7XG4gICAgICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLXJvdycsICdmYy13ZWVrJywgdGhlbWUuZ2V0Q2xhc3MoJ2RheVJvdycpXTtcbiAgICAgICAgICAgIGlmIChpc1JpZ2lkKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1yaWdpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJnUm93ID0gbmV3IERheUJnUm93KHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICBiZ1Jvdy5yZW5kZXJIdG1sKHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHM6IHRoaXMucHJvcHMuY2VsbHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckludHJvSHRtbDogdGhpcy5yZW5kZXJQcm9wcy5yZW5kZXJCZ0ludHJvSHRtbFxuICAgICAgICAgICAgICAgIH0pICtcbiAgICAgICAgICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXG4gICAgICAgICAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRJc051bWJlcnNWaXNpYmxlKCkgP1xuICAgICAgICAgICAgICAgICAgICAnPHRoZWFkPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOdW1iZXJUckh0bWwocm93KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcbiAgICAgICAgICAgICAgICAgICAgJycpICtcbiAgICAgICAgICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgIH07XG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NudCA+IDE7XG4gICAgICAgIH07XG4gICAgICAgIC8qIEdyaWQgTnVtYmVyIFJlbmRlcmluZ1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJUckh0bWwgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICB2YXIgaW50cm8gPSB0aGlzLnJlbmRlclByb3BzLnJlbmRlck51bWJlckludHJvSHRtbChyb3csIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuICcnICtcbiAgICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICh0aGlzLmlzUnRsID8gJycgOiBpbnRybykgK1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyQ2VsbHNIdG1sKHJvdykgK1xuICAgICAgICAgICAgICAgICh0aGlzLmlzUnRsID8gaW50cm8gOiAnJykgK1xuICAgICAgICAgICAgICAgICc8L3RyPic7XG4gICAgICAgIH07XG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckNlbGxzSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciBodG1scyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIHZhciBkYXRlO1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyTnVtYmVyQ2VsbEh0bWwoZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcbiAgICAgICAgICAgICAgICBodG1scy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIDx0ZD5zIG9mIHRoZSBcIm51bWJlclwiIHJvdyBpbiB0aGUgRGF5R3JpZCdzIGNvbnRlbnQgc2tlbGV0b24uXG4gICAgICAgIC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckNlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHZpZXcgPSBfYS52aWV3LCBkYXRlRW52ID0gX2EuZGF0ZUVudjtcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSBjb3JlLnJhbmdlQ29udGFpbnNNYXJrZXIodGhpcy5wcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cbiAgICAgICAgICAgIHZhciBpc0RheU51bWJlclZpc2libGUgPSB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSAmJiBpc0RhdGVWYWxpZDtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzO1xuICAgICAgICAgICAgdmFyIHdlZWtDYWxjRmlyc3REb3c7XG4gICAgICAgICAgICBpZiAoIWlzRGF5TnVtYmVyVmlzaWJsZSAmJiAhdGhpcy5yZW5kZXJQcm9wcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbnVtYmVycyBpbiBkYXkgY2VsbCAod2VlayBudW1iZXIgbXVzdCBiZSBhbG9uZyB0aGUgc2lkZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZD48L3RkPic7IC8vICB3aWxsIGNyZWF0ZSBhbiBlbXB0eSBzcGFjZSBhYm92ZSBldmVudHMgOihcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzZXMgPSBjb3JlLmdldERheUNsYXNzZXMoZGF0ZSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LXRvcCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUHJvcHMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHdlZWtDYWxjRmlyc3REb3cgPSBkYXRlRW52LndlZWtEb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcbiAgICAgICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xuICAgICAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlRW52LmZvcm1hdElzbyhkYXRlLCB7IG9taXRUaW1lOiB0cnVlIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAgICAgJz4nO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUHJvcHMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSAmJiAoZGF0ZS5nZXRVVENEYXkoKSA9PT0gd2Vla0NhbGNGaXJzdERvdykpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9IGNvcmUuYnVpbGRHb3RvQW5jaG9ySHRtbCh2aWV3LCB7IGRhdGU6IGRhdGUsIHR5cGU6ICd3ZWVrJyB9LCB7ICdjbGFzcyc6ICdmYy13ZWVrLW51bWJlcicgfSwgZGF0ZUVudi5mb3JtYXQoZGF0ZSwgV0VFS19OVU1fRk9STUFUKSAvLyBpbm5lciBIVE1MXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RheU51bWJlclZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9IGNvcmUuYnVpbGRHb3RvQW5jaG9ySHRtbCh2aWV3LCBkYXRlLCB7ICdjbGFzcyc6ICdmYy1kYXktbnVtYmVyJyB9LCBkYXRlRW52LmZvcm1hdChkYXRlLCBEQVlfTlVNX0ZPUk1BVCkgLy8gaW5uZXIgSFRNTFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyogU2l6aW5nXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGZpbGxSZW5kZXJlciA9IF9hLmZpbGxSZW5kZXJlciwgZXZlbnRSZW5kZXJlciA9IF9hLmV2ZW50UmVuZGVyZXIsIG1pcnJvclJlbmRlcmVyID0gX2EubWlycm9yUmVuZGVyZXI7XG4gICAgICAgICAgICBpZiAoaXNSZXNpemUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ2VsbFNpemVzRGlydHkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuY2FsZW5kYXIuaXNFdmVudHNVcGRhdGVkIC8vIGhhY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQb3NpdGlvbkNhY2hlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDZWxsU2l6ZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbFJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XG4gICAgICAgICAgICBldmVudFJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XG4gICAgICAgICAgICBtaXJyb3JSZW5kZXJlci5jb21wdXRlU2l6ZXMoaXNSZXNpemUpO1xuICAgICAgICAgICAgZmlsbFJlbmRlcmVyLmFzc2lnblNpemVzKGlzUmVzaXplKTtcbiAgICAgICAgICAgIGV2ZW50UmVuZGVyZXIuYXNzaWduU2l6ZXMoaXNSZXNpemUpO1xuICAgICAgICAgICAgbWlycm9yUmVuZGVyZXIuYXNzaWduU2l6ZXMoaXNSZXNpemUpO1xuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5idWlsZFBvc2l0aW9uQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZENvbFBvc2l0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFJvd1Bvc2l0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5idWlsZENvbFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY29sUG9zaXRpb25zLmJ1aWxkKCk7XG4gICAgICAgIH07XG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmJ1aWxkUm93UG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMuYnVpbGQoKTtcbiAgICAgICAgICAgIHRoaXMucm93UG9zaXRpb25zLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xuICAgICAgICB9O1xuICAgICAgICAvKiBIaXQgU3lzdGVtXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnBvc2l0aW9uVG9IaXQgPSBmdW5jdGlvbiAobGVmdFBvc2l0aW9uLCB0b3BQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgY29sUG9zaXRpb25zID0gX2EuY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgPSBfYS5yb3dQb3NpdGlvbnM7XG4gICAgICAgICAgICB2YXIgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcm93ID0gcm93UG9zaXRpb25zLnRvcFRvSW5kZXgodG9wUG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICBkYXRlU3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogQ2VsbCBTeXN0ZW1cbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgLy8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsRWwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxFbHNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xuICAgICAgICB9O1xuICAgICAgICAvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuX3JlbmRlckV2ZW50RHJhZyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmhpZGVCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2hpZ2hsaWdodCcsIHN0YXRlLnNlZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5fdW5yZW5kZXJFdmVudERyYWcgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zaG93QnlIYXNoKHN0YXRlLmFmZmVjdGVkSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl9yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmhpZGVCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2hpZ2hsaWdodCcsIHN0YXRlLnNlZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yUmVuZGVyZXIucmVuZGVyU2VncyhzdGF0ZS5zZWdzLCB7IGlzUmVzaXppbmc6IHRydWUsIHNvdXJjZVNlZzogc3RhdGUuc291cmNlU2VnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5fdW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNob3dCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvclJlbmRlcmVyLnVucmVuZGVyKHN0YXRlLnNlZ3MsIHsgaXNSZXNpemluZzogdHJ1ZSwgc291cmNlU2VnOiBzdGF0ZS5zb3VyY2VTZWcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIE1vcmUrIExpbmsgUG9wb3ZlclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW1vdmVTZWdQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VnUG9wb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VnUG9wb3Zlci5oaWRlKCk7IC8vIGluIGhhbmRsZXIsIHdpbGwgY2FsbCBzZWdQb3BvdmVyJ3MgcmVtb3ZlRWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBMaW1pdHMgdGhlIG51bWJlciBvZiBcImxldmVsc1wiICh2ZXJ0aWNhbGx5IHN0YWNraW5nIGxheWVycyBvZiBldmVudHMpIGZvciBlYWNoIHJvdyBvZiB0aGUgZ3JpZC5cbiAgICAgICAgLy8gYGxldmVsTGltaXRgIGNhbiBiZSBmYWxzZSAoZG9uJ3QgbGltaXQpLCBhIG51bWJlciwgb3IgdHJ1ZSAoc2hvdWxkIGJlIGNvbXB1dGVkKS5cbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3dzID0gZnVuY3Rpb24gKGxldmVsTGltaXQpIHtcbiAgICAgICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHMgfHwgW107XG4gICAgICAgICAgICB2YXIgcm93OyAvLyByb3cgI1xuICAgICAgICAgICAgdmFyIHJvd0xldmVsTGltaXQ7XG4gICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd1N0cnVjdHMubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5saW1pdFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgIGlmICghbGV2ZWxMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZXZlbExpbWl0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gbGV2ZWxMaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSB0aGlzLmNvbXB1dGVSb3dMZXZlbExpbWl0KHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0Um93KHJvdywgcm93TGV2ZWxMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIGxldmVscyBhIHJvdyB3aWxsIGFjY29tb2RhdGUgd2l0aG91dCBnb2luZyBvdXRzaWRlIGl0cyBib3VuZHMuXG4gICAgICAgIC8vIEFzc3VtZXMgdGhlIHJvdyBpcyBcInJpZ2lkXCIgKG1haW50YWlucyBhIGNvbnN0YW50IGhlaWdodCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW5zaWRlKS5cbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmNvbXB1dGVSb3dMZXZlbExpbWl0ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIHJvd0VsID0gdGhpcy5yb3dFbHNbcm93XTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxuICAgICAgICAgICAgdmFyIHJvd0JvdHRvbSA9IHJvd0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQhXG4gICAgICAgICAgICB2YXIgdHJFbHMgPSBjb3JlLmZpbmRDaGlsZHJlbih0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgdHJFbDtcbiAgICAgICAgICAgIC8vIFJldmVhbCBvbmUgbGV2ZWwgPHRyPiBhdCBhIHRpbWUgYW5kIHN0b3Agd2hlbiB3ZSBmaW5kIG9uZSBvdXQgb2YgYm91bmRzXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ckVsID0gdHJFbHNbaV07XG4gICAgICAgICAgICAgICAgdHJFbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXG4gICAgICAgICAgICAgICAgaWYgKHRyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tID4gcm93Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2hvdWxkIG5vdCBsaW1pdCBhdCBhbGxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTGltaXRzIHRoZSBnaXZlbiBncmlkIHJvdyB0byB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIGFuZCBpbmplY3RzIFwibW9yZVwiIGxpbmtzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG4gICAgICAgIC8vIGBsZXZlbExpbWl0YCBpcyBhIG51bWJlciBmb3IgdGhlIG1heGltdW0gKGluY2x1c2l2ZSkgbnVtYmVyIG9mIGxldmVscyBhbGxvd2VkLlxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5saW1pdFJvdyA9IGZ1bmN0aW9uIChyb3csIGxldmVsTGltaXQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb2xDbnQgPSBfYS5jb2xDbnQsIGlzUnRsID0gX2EuaXNSdGw7XG4gICAgICAgICAgICB2YXIgcm93U3RydWN0ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XTtcbiAgICAgICAgICAgIHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xuICAgICAgICAgICAgdmFyIGNvbCA9IDA7IC8vIGNvbCAjLCBsZWZ0LXRvLXJpZ2h0IChub3QgY2hyb25vbG9naWNhbGx5KVxuICAgICAgICAgICAgdmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XG4gICAgICAgICAgICB2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4gZWxlbWVudHMgaW4gdGhlIHJvd1xuICAgICAgICAgICAgdmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIHNlZztcbiAgICAgICAgICAgIHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxuICAgICAgICAgICAgdmFyIHRvdGFsU2Vnc0JlbG93OyAvLyB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgYmVsb3cgYHNlZ2AgaW4gYW55IG9mIHRoZSBjb2x1bW5zIGBzZWdgIG9jY3VwaWVzXG4gICAgICAgICAgICB2YXIgY29sU2Vnc0JlbG93OyAvLyBhcnJheSBvZiBzZWdtZW50IGFycmF5cywgYmVsb3cgc2VnLCBvbmUgZm9yIGVhY2ggY29sdW1uIChvZmZzZXQgZnJvbSBzZWdzJ3MgZmlyc3QgY29sdW1uKVxuICAgICAgICAgICAgdmFyIHRkO1xuICAgICAgICAgICAgdmFyIHJvd1NwYW47XG4gICAgICAgICAgICB2YXIgc2VnTW9yZU5vZGVzOyAvLyBhcnJheSBvZiBcIm1vcmVcIiA8dGQ+IGNlbGxzIHRoYXQgd2lsbCBzdGFuZC1pbiBmb3IgdGhlIGN1cnJlbnQgc2VnJ3MgY2VsbFxuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICB2YXIgbW9yZVRkO1xuICAgICAgICAgICAgdmFyIG1vcmVXcmFwO1xuICAgICAgICAgICAgdmFyIG1vcmVMaW5rO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXG4gICAgICAgICAgICB2YXIgZW1wdHlDZWxsc1VudGlsID0gZnVuY3Rpb24gKGVuZENvbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vnc0JlbG93Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSBfdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGNvbCwgc2Vnc0JlbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVXcmFwID0gY29yZS5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCBtb3JlTGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5hcHBlbmRDaGlsZChtb3JlV3JhcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlV3JhcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkgeyAvLyBpcyBpdCBhY3R1YWxseSBvdmVyIHRoZSBsaW1pdD9cbiAgICAgICAgICAgICAgICBsZXZlbFNlZ3MgPSByb3dTdHJ1Y3Quc2VnTGV2ZWxzW2xldmVsTGltaXQgLSAxXTtcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XG4gICAgICAgICAgICAgICAgbGltaXRlZE5vZGVzID0gY29yZS5maW5kQ2hpbGRyZW4ocm93U3RydWN0LnRib2R5RWwpLnNsaWNlKGxldmVsTGltaXQpOyAvLyBnZXQgbGV2ZWwgPHRyPiBlbGVtZW50cyBwYXN0IHRoZSBsaW1pdFxuICAgICAgICAgICAgICAgIGxpbWl0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnZmMtbGltaXRlZCcpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSB0aG91Z2ggc2VnbWVudHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbDtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKGxlZnRDb2wpOyAvLyBwcm9jZXNzIGVtcHR5IGNlbGxzIGJlZm9yZSB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgKmFsbCogc2VnbWVudHMgYmVsb3cgYHNlZ2AgdGhhdCBvY2N1cHkgdGhlIHNhbWUgY29sdW1uc1xuICAgICAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxTZWdzQmVsb3cgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29sIDw9IHJpZ2h0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNlZ3NCZWxvdy5wdXNoKHNlZ3NCZWxvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNlZ3NCZWxvdyArPSBzZWdzQmVsb3cubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsU2Vnc0JlbG93KSB7IC8vIGRvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGlzIHNlZ21lbnQgd2l0aCBvbmUgb3IgbWFueSBcIm1vcmVcIiBsaW5rcz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bbGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NwYW4gPSB0ZC5yb3dTcGFuIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSByZXBsYWNlbWVudCA8dGQ+IGZvciBlYWNoIGNvbHVtbiB0aGUgc2VnbWVudCBvY2N1cGllcy4gd2lsbCBiZSBvbmUgZm9yIGVhY2ggY29sc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZCA9IGNvcmUuY3JlYXRlRWxlbWVudCgndGQnLCB7IGNsYXNzTmFtZTogJ2ZjLW1vcmUtY2VsbCcsIHJvd1NwYW46IHJvd1NwYW4gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gY29sU2Vnc0JlbG93W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGxlZnRDb2wgKyBqLCBbc2VnXS5jb25jYXQoc2Vnc0JlbG93KSAvLyBjb3VudCBzZWcgYXMgaGlkZGVuIHRvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsIG1vcmVMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQuYXBwZW5kQ2hpbGQobW9yZVdyYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01vcmVOb2Rlcy5wdXNoKG1vcmVUZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVRkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRkLmNsYXNzTGlzdC5hZGQoJ2ZjLWxpbWl0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaW5zZXJ0QWZ0ZXJFbGVtZW50KHRkLCBzZWdNb3JlTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRlZE5vZGVzLnB1c2godGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbCh0aGlzLmNvbENudCk7IC8vIGZpbmlzaCBvZmYgdGhlIGxldmVsXG4gICAgICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBtb3JlTm9kZXM7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9IGxpbWl0ZWROb2RlczsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cbiAgICAgICAgLy8gYHJvd2AgaXMgYSByb3cgbnVtYmVyLlxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS51bmxpbWl0Um93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XG4gICAgICAgICAgICBpZiAocm93U3RydWN0Lm1vcmVFbHMpIHtcbiAgICAgICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscy5mb3JFYWNoKGNvcmUucmVtb3ZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd1N0cnVjdC5saW1pdGVkRWxzKSB7XG4gICAgICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMuZm9yRWFjaChmdW5jdGlvbiAobGltaXRlZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ZWRFbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy1saW1pdGVkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxuICAgICAgICAvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTW9yZUxpbmsgPSBmdW5jdGlvbiAocm93LCBjb2wsIGhpZGRlblNlZ3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCB2aWV3ID0gX2EudmlldywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XG4gICAgICAgICAgICB2YXIgYSA9IGNvcmUuY3JlYXRlRWxlbWVudCgnYScsIHsgY2xhc3NOYW1lOiAnZmMtbW9yZScgfSk7XG4gICAgICAgICAgICBhLmlubmVyVGV4dCA9IHRoaXMuZ2V0TW9yZUxpbmtUZXh0KGhpZGRlblNlZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tPcHRpb24gPSBfdGhpcy5vcHQoJ2V2ZW50TGltaXRDbGljaycpO1xuICAgICAgICAgICAgICAgIHZhciBfY29sID0gX3RoaXMuaXNSdGwgPyBfdGhpcy5jb2xDbnQgLSBjb2wgLSAxIDogY29sOyAvLyBIQUNLOiBwcm9wcy5jZWxscyBoYXMgZGlmZmVyZW50IGRpciBzeXN0ZW0/XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5wcm9wcy5jZWxsc1tyb3ddW19jb2xdLmRhdGU7XG4gICAgICAgICAgICAgICAgdmFyIG1vcmVFbCA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRheUVsID0gX3RoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsU2VncyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICAvLyByZXNjb3BlIHRoZSBzZWdtZW50cyB0byBiZSB3aXRoaW4gdGhlIGNlbGwncyBkYXRlXG4gICAgICAgICAgICAgICAgdmFyIHJlc2xpY2VkQWxsU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGFsbFNlZ3MsIGRhdGUpO1xuICAgICAgICAgICAgICAgIHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gYXRvbWljIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjbGlja09wdGlvbiA9IF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbDogZGF5RWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUVsOiBtb3JlRWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnczogcmVzbGljZWRBbGxTZWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2VncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xpY2tPcHRpb24gPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIuem9vbVRvKGRhdGUsIGNsaWNrT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXZlYWxzIHRoZSBwb3BvdmVyIHRoYXQgZGlzcGxheXMgYWxsIGV2ZW50cyB3aXRoaW4gYSBjZWxsXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnNob3dTZWdQb3BvdmVyID0gZnVuY3Rpb24gKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGNhbGVuZGFyID0gX2EuY2FsZW5kYXIsIHZpZXcgPSBfYS52aWV3LCB0aGVtZSA9IF9hLnRoZW1lO1xuICAgICAgICAgICAgdmFyIF9jb2wgPSB0aGlzLmlzUnRsID8gdGhpcy5jb2xDbnQgLSBjb2wgLSAxIDogY29sOyAvLyBIQUNLOiBwcm9wcy5jZWxscyBoYXMgZGlmZmVyZW50IGRpciBzeXN0ZW0/XG4gICAgICAgICAgICB2YXIgbW9yZVdyYXAgPSBtb3JlTGluay5wYXJlbnROb2RlOyAvLyB0aGUgPGRpdj4gd3JhcHBlciBhcm91bmQgdGhlIDxhPlxuICAgICAgICAgICAgdmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxuICAgICAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dDbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0b3BFbCA9IHZpZXcuZWw7IC8vIHdpbGwgY2F1c2UgdGhlIHBvcG92ZXIgdG8gY292ZXIgYW55IHNvcnQgb2YgaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BFbCA9IHRoaXMucm93RWxzW3Jvd107IC8vIHdpbGwgYWxpZ24gd2l0aCB0b3Agb2Ygcm93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZjLW1vcmUtcG9wb3ZlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcbiAgICAgICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcbiAgICAgICAgICAgICAgICB0b3A6IGNvcmUuY29tcHV0ZVJlY3QodG9wRWwpLnRvcCxcbiAgICAgICAgICAgICAgICBhdXRvSGlkZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlclRpbGUgPSBuZXcgRGF5VGlsZShfdGhpcy5jb250ZXh0LCBlbCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVNlZ1BvcG92ZXJUaWxlKF90aGlzLnByb3BzLmNlbGxzW3Jvd11bX2NvbF0uZGF0ZSwgc2Vncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXJUaWxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlclRpbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yaWdodCA9IGNvcmUuY29tcHV0ZVJlY3QobW9yZVdyYXApLnJpZ2h0ICsgMTsgLy8gKzEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gY29yZS5jb21wdXRlUmVjdChtb3JlV3JhcCkubGVmdCAtIDE7IC8vIC0xIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VnUG9wb3ZlciA9IG5ldyBQb3BvdmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZWdQb3BvdmVyLnNob3coKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLnJlbGVhc2VBZnRlclNpemluZ1RyaWdnZXJzKCk7IC8vIGhhY2sgZm9yIGV2ZW50UG9zaXRpb25lZFxuICAgICAgICB9O1xuICAgICAgICAvLyBHaXZlbiB0aGUgZXZlbnRzIHdpdGhpbiBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMsIHJlc2xpY2UgdGhlbSB0byBiZSBpbiBhIHNpbmdsZSBkYXlcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVzbGljZURheVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZGF5RGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRheVN0YXJ0ID0gZGF5RGF0ZTtcbiAgICAgICAgICAgIHZhciBkYXlFbmQgPSBjb3JlLmFkZERheXMoZGF5U3RhcnQsIDEpO1xuICAgICAgICAgICAgdmFyIGRheVJhbmdlID0geyBzdGFydDogZGF5U3RhcnQsIGVuZDogZGF5RW5kIH07XG4gICAgICAgICAgICB2YXIgbmV3U2VncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAgICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGNvcmUuaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwgZGF5UmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWdzLnB1c2goX19hc3NpZ24oe30sIHNlZywgeyBldmVudFJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aTogX19hc3NpZ24oe30sIGV2ZW50UmFuZ2UudWksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5zdGFydC52YWx1ZU9mKCksIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLmVuZC52YWx1ZU9mKCkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTZWdzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRNb3JlTGlua1RleHQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXRUZXh0Jyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHQobnVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnKycgKyBudW0gKyAnICcgKyBvcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJldHVybnMgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gY2VsbC5cbiAgICAgICAgLy8gSWYgYHN0YXJ0TGV2ZWxgIGlzIHNwZWNpZmllZCwgcmV0dXJucyBvbmx5IGV2ZW50cyBpbmNsdWRpbmcgYW5kIGJlbG93IHRoYXQgbGV2ZWwuIE90aGVyd2lzZSByZXR1cm5zIGFsbCBzZWdzLlxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsU2VncyA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xuICAgICAgICAgICAgdmFyIHNlZ01hdHJpeCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd10uc2VnTWF0cml4O1xuICAgICAgICAgICAgdmFyIGxldmVsID0gc3RhcnRMZXZlbCB8fCAwO1xuICAgICAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBzZWc7XG4gICAgICAgICAgICB3aGlsZSAobGV2ZWwgPCBzZWdNYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xuICAgICAgICAgICAgICAgIGlmIChzZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWQ7XG4gICAgfShjb3JlLkRhdGVDb21wb25lbnQpKTtcblxuICAgIHZhciBXRUVLX05VTV9GT1JNQVQkMSA9IGNvcmUuY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ251bWVyaWMnIH0pO1xuICAgIC8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBEYXlHcmlkIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuICAgIC8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG4gICAgdmFyIERheUdyaWRWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGF5R3JpZFZpZXcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRWaWV3KGNvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHx8IHRoaXM7XG4gICAgICAgICAgICAvKiBIZWFkZXIgUmVuZGVyaW5nXG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xuICAgICAgICAgICAgX3RoaXMucmVuZGVySGVhZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlbWUgPSBfdGhpcy50aGVtZTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgX3RoaXMud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaHRtbEVzY2FwZShfdGhpcy5vcHQoJ3dlZWtMYWJlbCcpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGg+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIERheSBHcmlkIFJlbmRlcmluZ1xuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIGNvbnRlbnQtc2tlbGV0b24gY2VsbHMgdGhhdCBkaXNwbGF5IHRoZSBkYXkvd2VlayBudW1iZXJzXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXlHcmlkTnVtYmVySW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdywgZGF5R3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZGF0ZUVudjtcbiAgICAgICAgICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gZGF5R3JpZC5wcm9wcy5jZWxsc1tyb3ddWzBdLmRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIF90aGlzLndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmJ1aWxkR290b0FuY2hvckh0bWwoLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMsIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiBkYXlHcmlkLmNvbENudCA9PT0gMSB9LCBkYXRlRW52LmZvcm1hdCh3ZWVrU3RhcnQsIFdFRUtfTlVNX0ZPUk1BVCQxKSAvLyBpbm5lciBIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RkPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgZGF5IGJnIGNlbGxzIGZvciBlYWNoIGRheS1yb3dcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckRheUdyaWRCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlbWUgPSBfdGhpcy50aGVtZTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIF90aGlzLndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgZXZlcnkgb3RoZXIgdHlwZSBvZiByb3cgZ2VuZXJhdGVkIGJ5IERheUdyaWQuXG4gICAgICAgICAgICAvLyBBZmZlY3RzIG1pcnJvci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXlHcmlkSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyBfdGhpcy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWRheUdyaWQtdmlldycpO1xuICAgICAgICAgICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gX3RoaXMucmVuZGVyU2tlbGV0b25IdG1sKCk7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBjb3JlLlNjcm9sbENvbXBvbmVudCgnaGlkZGVuJywgLy8gb3ZlcmZsb3cgeFxuICAgICAgICAgICAgJ2F1dG8nIC8vIG92ZXJmbG93IHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgZGF5R3JpZENvbnRhaW5lckVsID0gX3RoaXMuc2Nyb2xsZXIuZWw7XG4gICAgICAgICAgICBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmRDaGlsZChkYXlHcmlkQ29udGFpbmVyRWwpO1xuICAgICAgICAgICAgZGF5R3JpZENvbnRhaW5lckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWRheS1ncmlkLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdmFyIGRheUdyaWRFbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy1kYXktZ3JpZCcgfSk7XG4gICAgICAgICAgICBkYXlHcmlkQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoZGF5R3JpZEVsKTtcbiAgICAgICAgICAgIHZhciBjZWxsV2Vla051bWJlcnNWaXNpYmxlO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnMnKSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzV2l0aGluRGF5cycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gbmV3IERheUdyaWQoX3RoaXMuY29udGV4dCwgZGF5R3JpZEVsLCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTnVtYmVySW50cm9IdG1sOiBfdGhpcy5yZW5kZXJEYXlHcmlkTnVtYmVySW50cm9IdG1sLFxuICAgICAgICAgICAgICAgIHJlbmRlckJnSW50cm9IdG1sOiBfdGhpcy5yZW5kZXJEYXlHcmlkQmdJbnRyb0h0bWwsXG4gICAgICAgICAgICAgICAgcmVuZGVySW50cm9IdG1sOiBfdGhpcy5yZW5kZXJEYXlHcmlkSW50cm9IdG1sLFxuICAgICAgICAgICAgICAgIGNvbFdlZWtOdW1iZXJzVmlzaWJsZTogX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlLFxuICAgICAgICAgICAgICAgIGNlbGxXZWVrTnVtYmVyc1Zpc2libGU6IGNlbGxXZWVrTnVtYmVyc1Zpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRheUdyaWQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXG4gICAgICAgIC8vIFRoZSBkYXktZ3JpZCBjb21wb25lbnQgd2lsbCByZW5kZXIgaW5zaWRlIG9mIGEgY29udGFpbmVyIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy50aGVtZTtcbiAgICAgICAgICAgIHJldHVybiAnJyArXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XG4gICAgICAgICAgICAgICAgICAgICc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XG4gICAgICAgICAgICAgICAgICAgICcnKSArXG4gICAgICAgICAgICAgICAgJzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj48L3RkPicgK1xuICAgICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAgICAgICAgICc8L3RhYmxlPic7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS53ZWVrTnVtYmVyU3R5bGVBdHRyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9O1xuICAgICAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgZWFjaCByb3cgc2hvdWxkIGhhdmUgYSBjb25zdGFudCBoZWlnaHRcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLmhhc1JpZ2lkUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcbiAgICAgICAgfTtcbiAgICAgICAgLyogRGltZW5zaW9uc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCBpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKTsgLy8gd2lsbCBjYWxsIHVwZGF0ZUJhc2VTaXplLiBpbXBvcnRhbnQgdGhhdCBleGVjdXRlcyBmaXJzdFxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnVwZGF0ZVNpemUoaXNSZXNpemUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUudXBkYXRlQmFzZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xuICAgICAgICAgICAgdmFyIGRheUdyaWQgPSB0aGlzLmRheUdyaWQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG4gICAgICAgICAgICB2YXIgaGVhZFJvd0VsID0gdGhpcy5oZWFkZXIgPyB0aGlzLmhlYWRlci5lbCA6IG51bGw7IC8vIEhBQ0tcbiAgICAgICAgICAgIHZhciBzY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XG4gICAgICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gZGF5R3JpZCdzIGNvbHVtbnMgYmVpbmcgcmVuZGVyZWRcbiAgICAgICAgICAgIC8vIFRPRE86IHNlcGFyYXRlIHNldHRpbmcgaGVpZ2h0IGZyb20gc2Nyb2xsZXIgVlMgZGF5R3JpZC5cbiAgICAgICAgICAgIGlmICghZGF5R3JpZC5yb3dFbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXV0bykge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgd2VlayBudW1iZXIgY2VsbHMgcnVubmluZyBkb3duIHRoZSBzaWRlIGhhdmUgdGhlIHNhbWUgd2lkdGguXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSBjb3JlLm1hdGNoQ2VsbFdpZHRocyhjb3JlLmZpbmRFbGVtZW50cyh0aGlzLmVsLCAnLmZjLXdlZWstbnVtYmVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGhlaWdodHMgdG8gYmUgbmF0dXJhbFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKGhlYWRSb3dFbCkge1xuICAgICAgICAgICAgICAgIGNvcmUudW5jb21wZW5zYXRlU2Nyb2xsKGhlYWRSb3dFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcbiAgICAgICAgICAgIC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cbiAgICAgICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGZpcnN0IHNvIHRoZSBoZWlnaHQgY2FuIHJlZGlzdHJpYnV0ZSBhZnRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXG4gICAgICAgICAgICAvLyAodmlld0hlaWdodCBpcyBhIFwicmVjb21tZW5kZWRcIiB2YWx1ZSBpZiBpc0F1dG8pXG4gICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zZXRHcmlkSGVpZ2h0KHNjcm9sbGVySGVpZ2h0LCBpc0F1dG8pO1xuICAgICAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XG4gICAgICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBhZnRlciB0aGUgZ3JpZCdzIHJvdyBoZWlnaHRzIGhhdmUgYmVlbiBzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRSb3dFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5jb21wZW5zYXRlU2Nyb2xsKGhlYWRSb3dFbCwgc2Nyb2xsYmFyV2lkdGhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3SGVpZ2h0IC1cbiAgICAgICAgICAgICAgICBjb3JlLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxuICAgICAgICB9O1xuICAgICAgICAvLyBTZXRzIHRoZSBoZWlnaHQgb2YganVzdCB0aGUgRGF5R3JpZCBjb21wb25lbnQgaW4gdGhpcyB2aWV3XG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5zZXRHcmlkSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgaXNBdXRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHQoJ21vbnRoTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYXV0bywgbWFrZSB0aGUgaGVpZ2h0IG9mIGVhY2ggcm93IHRoZSBoZWlnaHQgdGhhdCBpdCB3b3VsZCBiZSBpZiB0aGVyZSB3ZXJlIDYgd2Vla3NcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLmRheUdyaWQucm93Q250IC8gNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29yZS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0F1dG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29yZS51bmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0Vscyk7IC8vIGxldCB0aGUgcm93cyBiZSB0aGVpciBuYXR1cmFsIGhlaWdodCB3aXRoIG5vIGV4cGFuZGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29yZS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBTY3JvbGxcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLmNvbXB1dGVEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHRpbWVNcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwIH07XG4gICAgICAgIH07XG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5xdWVyeURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERheUdyaWRWaWV3O1xuICAgIH0oY29yZS5WaWV3KSk7XG4gICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBEYXlHcmlkRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG5cbiAgICB2YXIgU2ltcGxlRGF5R3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNpbXBsZURheUdyaWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZURheUdyaWQoY29udGV4dCwgZGF5R3JpZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgZGF5R3JpZC5lbCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnNsaWNlciA9IG5ldyBEYXlHcmlkU2xpY2VyKCk7XG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gZGF5R3JpZDtcbiAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXIucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywgeyBlbDogX3RoaXMuZGF5R3JpZC5lbCB9KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBTaW1wbGVEYXlHcmlkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2ltcGxlRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgZGF5R3JpZCA9IHRoaXMuZGF5R3JpZDtcbiAgICAgICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZSA9IHByb3BzLmRheVRhYmxlO1xuICAgICAgICAgICAgZGF5R3JpZC5yZWNlaXZlUHJvcHMoX19hc3NpZ24oe30sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBkYXlHcmlkLCBkYXlUYWJsZSksIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBjZWxsczogZGF5VGFibGUuY2VsbHMsIGlzUmlnaWQ6IHByb3BzLmlzUmlnaWQgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBTaW1wbGVEYXlHcmlkLnByb3RvdHlwZS5idWlsZFBvc2l0aW9uQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmJ1aWxkUG9zaXRpb25DYWNoZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2ltcGxlRGF5R3JpZC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICAgICAgdmFyIHJhd0hpdCA9IHRoaXMuZGF5R3JpZC5wb3NpdGlvblRvSGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApO1xuICAgICAgICAgICAgaWYgKHJhd0hpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcy5kYXlHcmlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogcmF3SGl0LmRhdGVTcGFuLFxuICAgICAgICAgICAgICAgICAgICBkYXlFbDogcmF3SGl0LmRheUVsLFxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByYXdIaXQucmVsYXRpdmVSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmF3SGl0LnJlbGF0aXZlUmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcmF3SGl0LnJlbGF0aXZlUmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJhd0hpdC5yZWxhdGl2ZVJlY3QuYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZURheUdyaWQ7XG4gICAgfShjb3JlLkRhdGVDb21wb25lbnQpKTtcbiAgICB2YXIgRGF5R3JpZFNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRTbGljZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRTbGljZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRGF5R3JpZFNsaWNlci5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChkYXRlUmFuZ2UsIGRheVRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5VGFibGUuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF5R3JpZFNsaWNlcjtcbiAgICB9KGNvcmUuU2xpY2VyKSk7XG5cbiAgICB2YXIgRGF5R3JpZFZpZXckMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRWaWV3LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEYXlHcmlkVmlldyhfY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX2NvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5idWlsZERheVRhYmxlID0gY29yZS5tZW1vaXplKGJ1aWxkRGF5VGFibGUpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnY29sdW1uSGVhZGVyJykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXIgPSBuZXcgY29yZS5EYXlIZWFkZXIoX3RoaXMuY29udGV4dCwgX3RoaXMuZWwucXVlcnlTZWxlY3RvcignLmZjLWhlYWQtY29udGFpbmVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2ltcGxlRGF5R3JpZCA9IG5ldyBTaW1wbGVEYXlHcmlkKF90aGlzLmNvbnRleHQsIF90aGlzLmRheUdyaWQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpbXBsZURheUdyaWQuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgICAgICB2YXIgZGF5VGFibGUgPSB0aGlzLmRheVRhYmxlID1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRGF5VGFibGUoZGF0ZVByb2ZpbGUsIHRoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIucmVjZWl2ZVByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgICAgICBkYXRlczogZGF5VGFibGUuaGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZS5yb3dDbnQgPT09IDEsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckludHJvSHRtbDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpbXBsZURheUdyaWQucmVjZWl2ZVByb3BzKHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF5VGFibGU6IGRheVRhYmxlLFxuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLFxuICAgICAgICAgICAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICAgICAgICAgICAgaXNSaWdpZDogdGhpcy5oYXNSaWdpZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkOiB0aGlzLm5leHREYXlUaHJlc2hvbGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF5R3JpZFZpZXc7XG4gICAgfShEYXlHcmlkVmlldykpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkRGF5VGFibGUoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgY29yZS5EYXlTZXJpZXMoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkRheVRhYmxlKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG4gICAgfVxuXG4gICAgdmFyIG1haW4gPSBjb3JlLmNyZWF0ZVBsdWdpbih7XG4gICAgICAgIGRlZmF1bHRWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgIGRheUdyaWQ6IERheUdyaWRWaWV3JDEsXG4gICAgICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICAgICAgbW9udGhNb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4cG9ydHMuQWJzdHJhY3REYXlHcmlkVmlldyA9IERheUdyaWRWaWV3O1xuICAgIGV4cG9ydHMuRGF5QmdSb3cgPSBEYXlCZ1JvdztcbiAgICBleHBvcnRzLkRheUdyaWQgPSBEYXlHcmlkO1xuICAgIGV4cG9ydHMuRGF5R3JpZFNsaWNlciA9IERheUdyaWRTbGljZXI7XG4gICAgZXhwb3J0cy5EYXlHcmlkVmlldyA9IERheUdyaWRWaWV3JDE7XG4gICAgZXhwb3J0cy5TaW1wbGVEYXlHcmlkID0gU2ltcGxlRGF5R3JpZDtcbiAgICBleHBvcnRzLmJ1aWxkQmFzaWNEYXlUYWJsZSA9IGJ1aWxkRGF5VGFibGU7XG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n");

/***/ }),

/***/ "./resources/js/calendar.js":
/*!**********************************!*\
  !*** ./resources/js/calendar.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core */ \"./node_modules/@fullcalendar/core/main.js\");\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fullcalendar_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/bootstrap */ \"./node_modules/@fullcalendar/bootstrap/main.js\");\n/* harmony import */ var _fullcalendar_bootstrap__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_bootstrap__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n$(document).ready(function () {\n  var mainCalendar = mainCalendarInit();\n  mainCalendar.render();\n\n  function mainCalendarInit() {\n    var calendarEl = document.getElementById('calendar');\n    var calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__[\"Calendar\"](calendarEl, {\n      plugins: [_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1___default.a, _fullcalendar_bootstrap__WEBPACK_IMPORTED_MODULE_2___default.a],\n      themeSystem: 'bootstrap',\n      defaultView: 'dayGridMonth',\n      events: route('schedules.sessions').url(),\n      firstDay: 1,\n      showNonCurrentDates: false,\n      fixedWeekCount: false,\n      height: 'auto',\n      aspectRatio: 1.5,\n      eventColor: '#2196f3',\n      eventTextColor: '#FFF',\n      eventOrder: \"id\",\n      customButtons: {\n        modify: {\n          text: 'Modify Schedule',\n          click: function click() {\n            $('#modifySchedule').modal();\n          }\n        },\n        eventAdd: {\n          text: 'Add Event',\n          click: function click() {\n            $('#addEvent').modal();\n          }\n        }\n      },\n      header: {\n        left: 'prev,next',\n        center: 'title',\n        right: 'modify,eventAdd'\n      },\n      eventClick: function eventClick(info) {\n        if (info.event.extendedProps.description == 'session') {\n          sessionDetailsInit(info);\n        } else if (info.event.extendedProps.description == 'event') {\n          $(\"#addEvent\").modal();\n          var id = info.event.id;\n          var start = info.event.start;\n          var title = info.event.title;\n          eventDetails(id, start, title);\n        }\n      }\n    });\n    return calendar;\n  }\n\n  function eventDetails(id, start, title) {\n    var startDate = new Date(start);\n    var eventId = id;\n    $('#eventdate').datepicker('update', startDate);\n    $('#eventid').val(eventId);\n    $('#description').val(title);\n    $('<input>').attr({\n      type: 'hidden',\n      id: 'eventId',\n      name: 'id',\n      value: eventId\n    }).appendTo('#eventForm');\n    $('#eventForm').attr(\"action\", route('events.update'));\n    $('#eventDelete').css('display', 'block');\n  }\n\n  function sessionDetailsInit(info) {\n    $('#session-name').text(info.event.title);\n    $('#session-date').text(moment(info.event.start).format(\"MMMM Do YYYY\"));\n    $('#session-id').val(info.event.id);\n\n    if (moment(info.event.start).isSame(new Date(), 'day')) {\n      $('#btn-study').show();\n    }\n\n    var status = info.event.extendedProps.status;\n    $('#session-status').text(status);\n\n    switch (status) {\n      case \"Incomplete\":\n        $('#session-status').css(\"background-color\", \"#6c757d\");\n        break;\n\n      case \"Completed\":\n        $('#session-status').css(\"background-color\", \"#28a745\");\n        break;\n\n      case \"Failed\":\n        $('#session-status').css(\"background-color\", \"#dc3545\");\n        break;\n\n      default:\n        $('#session-status').css(\"background-color\", \"#6c757d\");\n    }\n\n    $('#session-date-new').datepicker({\n      maxViewMode: 'years',\n      format: \"yyyy-mm-dd\",\n      autoclose: true,\n      todayHighlight: true,\n      weekStart: 1\n    });\n\n    if (typeof window.scheduleStartDate !== 'undefined' && typeof window.scheduleEndDate !== 'undefined') {\n      $('#session-date-new').datepicker('setStartDate', window.scheduleStartDate);\n      $('#session-date-new').datepicker('setEndDate', window.scheduleEndDate);\n    }\n\n    $('#session-date-new').datepicker('setDate', new Date(info.event.start));\n    $('#session-change-btn').click(function () {\n      $('#session-change-form').show('slow');\n    });\n    $('#sessionDetails').on('hidden.bs.modal', function (e) {\n      $(\"#session-change-form\").hide();\n    });\n    $(\"#sessionDetails\").modal();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY2FsZW5kYXIuanM/OGVlNiJdLCJuYW1lcyI6WyIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsIm1haW5DYWxlbmRhciIsIm1haW5DYWxlbmRhckluaXQiLCJyZW5kZXIiLCJjYWxlbmRhckVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjYWxlbmRhciIsIkNhbGVuZGFyIiwicGx1Z2lucyIsImRheUdyaWRQbHVnaW4iLCJib290c3RyYXBQbHVnaW4iLCJ0aGVtZVN5c3RlbSIsImRlZmF1bHRWaWV3IiwiZXZlbnRzIiwicm91dGUiLCJ1cmwiLCJmaXJzdERheSIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJmaXhlZFdlZWtDb3VudCIsImhlaWdodCIsImFzcGVjdFJhdGlvIiwiZXZlbnRDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRPcmRlciIsImN1c3RvbUJ1dHRvbnMiLCJtb2RpZnkiLCJ0ZXh0IiwiY2xpY2siLCJtb2RhbCIsImV2ZW50QWRkIiwiaGVhZGVyIiwibGVmdCIsImNlbnRlciIsInJpZ2h0IiwiZXZlbnRDbGljayIsImluZm8iLCJldmVudCIsImV4dGVuZGVkUHJvcHMiLCJkZXNjcmlwdGlvbiIsInNlc3Npb25EZXRhaWxzSW5pdCIsImlkIiwic3RhcnQiLCJ0aXRsZSIsImV2ZW50RGV0YWlscyIsInN0YXJ0RGF0ZSIsIkRhdGUiLCJldmVudElkIiwiZGF0ZXBpY2tlciIsInZhbCIsImF0dHIiLCJ0eXBlIiwibmFtZSIsInZhbHVlIiwiYXBwZW5kVG8iLCJjc3MiLCJtb21lbnQiLCJmb3JtYXQiLCJpc1NhbWUiLCJzaG93Iiwic3RhdHVzIiwibWF4Vmlld01vZGUiLCJhdXRvY2xvc2UiLCJ0b2RheUhpZ2hsaWdodCIsIndlZWtTdGFydCIsIndpbmRvdyIsInNjaGVkdWxlU3RhcnREYXRlIiwic2NoZWR1bGVFbmREYXRlIiwib24iLCJlIiwiaGlkZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FB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QUFELENBQUQsQ0FBeUI2QixLQUF6QixDQUErQixZQUFVO0FBQ3hDN0IsT0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEI0RCxJQUExQixDQUErQixNQUEvQjtBQUNBLEtBRkQ7QUFJQTVELEtBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCcUUsRUFBckIsQ0FBd0IsaUJBQXhCLEVBQTJDLFVBQVVDLENBQVYsRUFBYTtBQUN2RHRFLE9BQUMsQ0FBQyxzQkFBRCxDQUFELENBQTBCdUUsSUFBMUI7QUFDQSxLQUZEO0FBSUF2RSxLQUFDLENBQUMsaUJBQUQsQ0FBRCxDQUFxQjhCLEtBQXJCO0FBQ0E7QUFFRCxDQXBJRCIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jYWxlbmRhci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbGVuZGFyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlJztcbmltcG9ydCBkYXlHcmlkUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCc7XG5pbXBvcnQgYm9vdHN0cmFwUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvYm9vdHN0cmFwJztcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblxuXHR2YXIgbWFpbkNhbGVuZGFyID0gbWFpbkNhbGVuZGFySW5pdCgpO1xuXHRcblx0bWFpbkNhbGVuZGFyLnJlbmRlcigpO1xuXHRcblx0ZnVuY3Rpb24gbWFpbkNhbGVuZGFySW5pdCgpXG5cdHtcblx0XHR2YXIgY2FsZW5kYXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxlbmRhcicpO1xuICAgIFx0dmFyIGNhbGVuZGFyID0gbmV3IENhbGVuZGFyKGNhbGVuZGFyRWwsIHtcblx0XHRcdHBsdWdpbnM6IFsgZGF5R3JpZFBsdWdpbiwgYm9vdHN0cmFwUGx1Z2luIF0sXG5cdFx0XHR0aGVtZVN5c3RlbTogJ2Jvb3RzdHJhcCcsXG5cdFx0XHRkZWZhdWx0VmlldzogJ2RheUdyaWRNb250aCcsXG5cdFx0XHRldmVudHM6IHJvdXRlKCdzY2hlZHVsZXMuc2Vzc2lvbnMnKS51cmwoKSxcblx0XHRcdGZpcnN0RGF5OiAxLFxuXHRcdFx0c2hvd05vbkN1cnJlbnREYXRlczogZmFsc2UsXG5cdFx0XHRmaXhlZFdlZWtDb3VudDogZmFsc2UsXG5cdFx0XHRoZWlnaHQ6ICdhdXRvJyxcblx0XHRcdGFzcGVjdFJhdGlvOiAxLjUsXG5cdFx0XHRldmVudENvbG9yOiAnIzIxOTZmMycsXG5cdFx0XHRldmVudFRleHRDb2xvcjogJyNGRkYnLFxuXHRcdFx0ZXZlbnRPcmRlcjogXCJpZFwiLFxuXHRcdFx0Y3VzdG9tQnV0dG9uczoge1xuXHRcdFx0XHRtb2RpZnkgOiB7XG5cdFx0XHRcdFx0dGV4dDogJ01vZGlmeSBTY2hlZHVsZScsXG5cdFx0XHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JCgnI21vZGlmeVNjaGVkdWxlJykubW9kYWwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGV2ZW50QWRkIDoge1xuXHRcdFx0XHRcdHRleHQ6ICdBZGQgRXZlbnQnLFxuXHRcdFx0XHRcdGNsaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdCQoJyNhZGRFdmVudCcpLm1vZGFsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGVhZGVyOiB7XG5cdFx0XHRcdGxlZnQ6ICdwcmV2LG5leHQnLFxuXHRcdFx0XHRjZW50ZXI6ICd0aXRsZScsXG5cdFx0XHRcdHJpZ2h0OiAnbW9kaWZ5LGV2ZW50QWRkJ1xuXHRcdFx0fSxcblx0XHRcdGV2ZW50Q2xpY2s6IGZ1bmN0aW9uKGluZm8pIHtcblx0XHRcdFx0aWYoaW5mby5ldmVudC5leHRlbmRlZFByb3BzLmRlc2NyaXB0aW9uID09ICdzZXNzaW9uJylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNlc3Npb25EZXRhaWxzSW5pdChpbmZvKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKGluZm8uZXZlbnQuZXh0ZW5kZWRQcm9wcy5kZXNjcmlwdGlvbiA9PSAnZXZlbnQnKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0JChcIiNhZGRFdmVudFwiKS5tb2RhbCgpO1xuXHRcdFx0XHRcdHZhciBpZCA9IGluZm8uZXZlbnQuaWQ7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gaW5mby5ldmVudC5zdGFydDtcblx0XHRcdFx0XHR2YXIgdGl0bGUgPSBpbmZvLmV2ZW50LnRpdGxlO1xuXHRcdFx0XHRcdGV2ZW50RGV0YWlscyhpZCwgc3RhcnQsIHRpdGxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhbGVuZGFyO1xuXHR9XG5cdFxuXHQgIFxuXHRmdW5jdGlvbiBldmVudERldGFpbHMoaWQsIHN0YXJ0LCB0aXRsZSlcblx0e1xuXHRcdHZhciBzdGFydERhdGUgPSBuZXcgRGF0ZShzdGFydCk7XG5cdFx0dmFyIGV2ZW50SWQgPSBpZDtcblx0XHQkKCcjZXZlbnRkYXRlJykuZGF0ZXBpY2tlcigndXBkYXRlJywgc3RhcnREYXRlKTtcblx0XHQkKCcjZXZlbnRpZCcpLnZhbChldmVudElkKTtcblx0XHQkKCcjZGVzY3JpcHRpb24nKS52YWwodGl0bGUpO1xuXHRcdCQoJzxpbnB1dD4nKS5hdHRyKHtcblx0XHRcdHR5cGU6ICdoaWRkZW4nLFxuXHRcdFx0aWQ6ICdldmVudElkJyxcblx0XHRcdG5hbWU6ICdpZCcsXG5cdFx0XHR2YWx1ZTogZXZlbnRJZFxuXHRcdH0pLmFwcGVuZFRvKCcjZXZlbnRGb3JtJyk7XG5cdFx0JCgnI2V2ZW50Rm9ybScpLmF0dHIoXCJhY3Rpb25cIiwgcm91dGUoJ2V2ZW50cy51cGRhdGUnKSk7XG5cdFx0JCgnI2V2ZW50RGVsZXRlJykuY3NzKCdkaXNwbGF5JywnYmxvY2snKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlc3Npb25EZXRhaWxzSW5pdChpbmZvKVxuXHR7XG5cdFx0JCgnI3Nlc3Npb24tbmFtZScpLnRleHQoaW5mby5ldmVudC50aXRsZSk7XG5cdFx0JCgnI3Nlc3Npb24tZGF0ZScpLnRleHQobW9tZW50KGluZm8uZXZlbnQuc3RhcnQpLmZvcm1hdChcIk1NTU0gRG8gWVlZWVwiKSk7XG5cdFx0JCgnI3Nlc3Npb24taWQnKS52YWwoaW5mby5ldmVudC5pZClcblxuXHRcdGlmKG1vbWVudChpbmZvLmV2ZW50LnN0YXJ0KS5pc1NhbWUobmV3IERhdGUoKSwgJ2RheScpKXtcblx0XHRcdCQoJyNidG4tc3R1ZHknKS5zaG93KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHN0YXR1cyA9IGluZm8uZXZlbnQuZXh0ZW5kZWRQcm9wcy5zdGF0dXM7XG5cdFx0JCgnI3Nlc3Npb24tc3RhdHVzJykudGV4dChzdGF0dXMpO1xuXHRcdHN3aXRjaChzdGF0dXMpIHtcblx0XHRcdGNhc2UgXCJJbmNvbXBsZXRlXCI6XG5cdFx0XHRcdCQoJyNzZXNzaW9uLXN0YXR1cycpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjNmM3NTdkXCIpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIkNvbXBsZXRlZFwiOlxuXHRcdFx0XHQkKCcjc2Vzc2lvbi1zdGF0dXMnKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzI4YTc0NVwiKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSBcIkZhaWxlZFwiOlxuXHRcdFx0XHQkKCcjc2Vzc2lvbi1zdGF0dXMnKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2RjMzU0NVwiKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0JCgnI3Nlc3Npb24tc3RhdHVzJykuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM2Yzc1N2RcIilcblx0XHR9XG5cblx0XHRcblx0XHQkKCcjc2Vzc2lvbi1kYXRlLW5ldycpLmRhdGVwaWNrZXIoe1xuXHRcdFx0bWF4Vmlld01vZGU6ICd5ZWFycycsXG5cdFx0XHRmb3JtYXQ6IFwieXl5eS1tbS1kZFwiLFxuXHRcdFx0YXV0b2Nsb3NlOiB0cnVlLFxuXHRcdFx0dG9kYXlIaWdobGlnaHQ6IHRydWUsXG5cdFx0XHR3ZWVrU3RhcnQ6IDFcblx0XHR9KTtcblxuXHRcdGlmICgodHlwZW9mIHdpbmRvdy5zY2hlZHVsZVN0YXJ0RGF0ZSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2Ygd2luZG93LnNjaGVkdWxlRW5kRGF0ZSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG5cdFx0XHQkKCcjc2Vzc2lvbi1kYXRlLW5ldycpLmRhdGVwaWNrZXIoJ3NldFN0YXJ0RGF0ZScsIHdpbmRvdy5zY2hlZHVsZVN0YXJ0RGF0ZSk7XG5cdFx0XHQkKCcjc2Vzc2lvbi1kYXRlLW5ldycpLmRhdGVwaWNrZXIoJ3NldEVuZERhdGUnLCB3aW5kb3cuc2NoZWR1bGVFbmREYXRlKTtcblx0XHR9XG5cdFx0XG5cblx0XHQkKCcjc2Vzc2lvbi1kYXRlLW5ldycpLmRhdGVwaWNrZXIoJ3NldERhdGUnLCBuZXcgRGF0ZShpbmZvLmV2ZW50LnN0YXJ0KSlcblxuXHRcdCQoJyNzZXNzaW9uLWNoYW5nZS1idG4nKS5jbGljayhmdW5jdGlvbigpe1xuXHRcdFx0JCgnI3Nlc3Npb24tY2hhbmdlLWZvcm0nKS5zaG93KCdzbG93Jyk7XG5cdFx0fSk7XG5cblx0XHQkKCcjc2Vzc2lvbkRldGFpbHMnKS5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdCQoXCIjc2Vzc2lvbi1jaGFuZ2UtZm9ybVwiKS5oaWRlKCk7XG5cdFx0fSk7XG5cblx0XHQkKFwiI3Nlc3Npb25EZXRhaWxzXCIpLm1vZGFsKCk7XG5cdH1cblx0XG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/calendar.js\n");

/***/ }),

/***/ 3:
/*!****************************************!*\
  !*** multi ./resources/js/calendar.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/dave/development/project/php/study-assistant/resources/js/calendar.js */"./resources/js/calendar.js");


/***/ })

/******/ });